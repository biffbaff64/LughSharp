// ///////////////////////////////////////////////////////////////////////////////
// MIT License
//
// Copyright (c) 2024 Richard Ikin / Red 7 Projects and Contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// ///////////////////////////////////////////////////////////////////////////////

using System.Drawing;
using Corelib.LibCore.Graphics.G2D;
using Corelib.LibCore.Input;
using Corelib.LibCore.Maths;
using Corelib.LibCore.Scenes.Scene2D.Listeners;
using Corelib.LibCore.Scenes.Scene2D.Utils;
using Corelib.LibCore.Utils;
using Corelib.LibCore.Utils.Collections;
using Corelib.LibCore.Utils.Exceptions;
using Corelib.LibCore.Utils.Pooling;
using Color = Corelib.LibCore.Graphics.Color;
using Platform = Corelib.LibCore.Core.Platform;

namespace Corelib.LibCore.Scenes.Scene2D.UI;

/// A single-line text input field.
/// <para>
/// The preferred height of a text field is the height of the <see cref="Font"/>
/// and <see cref="TextFieldStyle.Background"/>. The preferred width of a text field is 150,
/// a relatively arbitrary size.
/// </para>
/// <para>
/// The text field will copy the currently selected text when ctrl+c is pressed, and
/// paste any text in the clipboard when ctrl+v is pressed. Clipboard functionality is
/// provided via the <see cref="IClipboard"/> interface.
/// </para>
/// <para>
/// The text field allows you to specify an <see cref="IOnScreenKeyboard"/> for displaying
/// a softkeyboard and piping all key events generated by the keyboard to the text field.
/// There are two standard implementations, one for the desktop and one for Android.
/// The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The
/// Android <see cref="IOnScreenKeyboard"/> implementation will bring up the default IME.
/// </para>
[PublicAPI]
public class TextField : Widget
{
    protected const char CARRIAGE_RETURN = '\r';
    protected const char NEWLINE         = '\n';
    protected const char TAB             = '\t';
    protected const char BACKSPACE       = '\u0008';
    protected const char DELETE          = '\u007f';
    protected const char BULLET          = '\u0095';

    public static float KeyRepeatInitialTime = 0.4f;
    public static float KeyRepeatTime        = 0.1f;

    private readonly BlinkTaskManager     _blink;
    private readonly IClipboard           _clipboard;
    private readonly KeyRepeatTaskManager _keyRepeat;
    private readonly bool                 _onlyFontChars = true;
    private readonly int                  _textAlign     = Align.LEFT;
    private readonly Vector2              _tmp1          = new();
    private readonly Vector2              _tmp2          = new();
    private readonly Vector2              _tmp3          = new();

    private CancellationToken        _blinkCancellationToken;
    private Task?                    _blinkTask;
    private CancellationTokenSource? _blinkTokenSource;

    private bool                     _cursorOn;
    private bool                     _focused;
    private InputListener?           _inputListener;
    private IOnscreenKeyboard        _keyboard = new DefaultOnscreenKeyboard();
    private CancellationToken        _keyRepeatCancellationToken;
    private Task?                    _keyRepeatTask;
    private CancellationTokenSource? _keyRepeatTokenSource;
    private long                     _lastChangeTime;
    private StringBuilder?           _passwordBuffer;
    private char                     _passwordCharacter = BULLET;
    private bool                     _passwordMode;
    private float                    _renderOffset;
    private float                    _selectionWidth;
    private float                    _selectionX;
    private string?                  _undoText = "";
    private int                      _visibleTextEnd;
    private int                      _visibleTextStart;

    // ========================================================================

    public TextField( string? text, Skin skin )
        : this( text, skin.Get< TextFieldStyle >() )
    {
    }

    public TextField( string? text, Skin skin, string styleName )
        : this( text, skin.Get< TextFieldStyle >( styleName ) )
    {
    }

    public TextField( string? text, TextFieldStyle style )
    {
        _clipboard = Gdx.App.Clipboard!;
        _blink     = new BlinkTaskManager( this );
        _keyRepeat = new KeyRepeatTaskManager( this );

        NonVirtualInitialise( text, style );
    }

    // ========================================================================

    public TextFieldStyle?     Style                    { get; set; }
    public string?             Text                     { get; set; }
    public string?             MessageText              { get; set; }
    public int                 Cursor                   { get; set; }
    public int                 SelectionStart           { get; set; }
    public bool                HasSelection             { get; set; }
    public bool                WriteEnters              { get; set; }
    public GlyphLayout         Layout                   { get; set; } = new();
    public List< float >       GlyphPositions           { get; set; } = [ ];
    public string?             DisplayText              { get; set; }
    public float               FontOffset               { get; set; }
    public float               TextHeight               { get; set; }
    public float               TextOffset               { get; set; }
    public bool                FocusTraversal           { get; set; } = true;
    public bool                ProgrammaticChangeEvents { get; set; }
    public bool                Disabled                 { get; set; }
    public ITextFieldFilter?   Filter                   { get; set; }
    public ITextFieldListener? Listener                 { get; set; }
    public int                 MaxLength                { get; set; }

    // ========================================================================

    public override float PrefHeight
    {
        get
        {
            float topAndBottom = 0, minHeight = 0;

            if ( Style?.Background != null )
            {
                topAndBottom = Math.Max( topAndBottom, Style.Background.BottomHeight + Style.Background.TopHeight );
                minHeight    = Math.Max( minHeight, Style.Background.MinHeight );
            }

            if ( Style?.FocusedBackground != null )
            {
                topAndBottom = Math.Max( topAndBottom,
                                         Style.FocusedBackground.BottomHeight + Style.FocusedBackground.TopHeight );

                minHeight = Math.Max( minHeight, Style.FocusedBackground.MinHeight );
            }

            if ( Style?.DisabledBackground != null )
            {
                topAndBottom = Math.Max( topAndBottom,
                                         Style.DisabledBackground.BottomHeight + Style.DisabledBackground.TopHeight );

                minHeight = Math.Max( minHeight, Style.DisabledBackground.MinHeight );
            }

            return Math.Max( topAndBottom + TextHeight, minHeight );
        }
    }

    /// <summary>
    /// If true, the text in this text field will be shown as bullet characters.
    /// <see cref="PasswordCharacter"/>
    /// </summary>
    public bool PasswordMode
    {
        get => _passwordMode;
        set
        {
            _passwordMode = value;
            UpdateDisplayText();
        }
    }

    public char PasswordCharacter
    {
        get => _passwordCharacter;
        set
        {
            _passwordCharacter = value;

            if ( PasswordMode )
            {
                UpdateDisplayText();
            }
        }
    }

    public virtual float GetPrefWidth()
    {
        return 150;
    }

    public virtual float GetPrefHeight()
    {
        return PrefHeight;
    }

    // ========================================================================

    /// <summary>
    /// Not a good idea to call virtual methods from a constructor, so...
    /// </summary>
    private void NonVirtualInitialise( string? text, TextFieldStyle style )
    {
        SetStyle( style );
        Initialise();
        SetText( text );
        SetSize( GetPrefWidth(), GetPrefHeight() );
    }

    public virtual void Initialise()
    {
        _inputListener = CreateInputListener();

        _blink.Create();
        _keyRepeat.Create();
    }

    protected virtual InputListener CreateInputListener()
    {
        return new TextFieldClickListener( this );
    }

    public virtual void SetStyle( TextFieldStyle style )
    {
        ArgumentNullException.ThrowIfNull( style );
        ArgumentNullException.ThrowIfNull( style.Font );

        Style = style;

        TextHeight = style.Font.GetCapHeight() - ( style.Font.GetDescent() * 2 );

        if ( Text != null )
        {
            UpdateDisplayText();
        }

        InvalidateHierarchy();
    }

    /// <summary>
    /// </summary>
    public virtual void CalculateOffsets()
    {
        var visibleWidth = Width;
        var background   = GetBackgroundDrawable();

        if ( background != null )
        {
            visibleWidth -= background.LeftWidth + background.RightWidth;
        }

        var glyphCount     = GlyphPositions.Count;
        var glyphPositions = GlyphPositions.ToArray();

        // Check if the cursor has gone out the left or right side of
        // the visible area and adjust renderOffset if necessary.
        var distance = glyphPositions[ Math.Max( 0, Cursor - 1 ) ] + _renderOffset;

        if ( distance <= 0 )
        {
            _renderOffset -= distance;
        }
        else
        {
            var index = Math.Min( glyphCount - 1, Cursor + 1 );
            var minX  = glyphPositions[ index ] - visibleWidth;

            if ( -_renderOffset < minX )
            {
                _renderOffset = -minX;
            }
        }

        // Prevent renderOffset from starting too close to the end, eg after text was deleted.
        var maxOffset = 0f;
        var width     = glyphPositions[ glyphCount - 1 ];

        for ( var i = glyphCount - 2; i >= 0; i-- )
        {
            var x = glyphPositions[ i ];

            if ( ( width - x ) > visibleWidth )
            {
                break;
            }

            maxOffset = x;
        }

        if ( -_renderOffset > maxOffset )
        {
            _renderOffset = -maxOffset;
        }

        // calculate first visible char based on render offset
        _visibleTextStart = 0;

        var startX = 0f;

        for ( var i = 0; i < glyphCount; i++ )
        {
            if ( glyphPositions[ i ] >= -_renderOffset )
            {
                _visibleTextStart = i;
                startX            = glyphPositions[ i ];

                break;
            }
        }

        // calculate last visible char based on visible width and render offset
        var end  = _visibleTextStart + 1;
        var endX = visibleWidth - _renderOffset;

        for ( var n = Math.Min( DisplayText!.Length, glyphCount ); end <= n; end++ )
        {
            if ( glyphPositions[ end ] > endX )
            {
                break;
            }
        }

        _visibleTextEnd = Math.Max( 0, end - 1 );

        if ( ( _textAlign & Align.LEFT ) == 0 )
        {
            TextOffset = ( visibleWidth - glyphPositions[ _visibleTextEnd ] - FontOffset ) + startX;

            if ( ( _textAlign & Align.CENTER ) != 0 )
            {
                TextOffset = ( float ) Math.Round( TextOffset * 0.5f );
            }
        }
        else
        {
            TextOffset = startX + _renderOffset;
        }

        // calculate selection x position and width
        if ( HasSelection )
        {
            var minIndex = Math.Min( Cursor, SelectionStart );
            var maxIndex = Math.Max( Cursor, SelectionStart );
            var minX     = Math.Max( glyphPositions[ minIndex ] - glyphPositions[ _visibleTextStart ], -TextOffset );
            var maxX     = Math.Min( glyphPositions[ maxIndex ] - glyphPositions[ _visibleTextStart ], visibleWidth - TextOffset );

            _selectionX     = minX;
            _selectionWidth = maxX - minX - Style!.Font!.Data.CursorX;
        }
    }

    protected virtual int LetterUnderCursor( float x )
    {
        if ( Style == null )
        {
            return GlyphPositions.Count - 1;
        }

        x -= ( TextOffset + FontOffset ) - Style.Font!.Data.CursorX - GlyphPositions[ _visibleTextStart ];

        var background = GetBackgroundDrawable();

        if ( background != null )
        {
            x -= Style.Background!.LeftWidth;
        }

        var n              = GlyphPositions.Count;
        var glyphPositions = GlyphPositions.ToArray();

        for ( var i = 1; i < n; i++ )
        {
            if ( glyphPositions[ i ] > x )
            {
                if ( ( glyphPositions[ i ] - x ) <= ( x - glyphPositions[ i - 1 ] ) )
                {
                    return i;
                }

                return i - 1;
            }
        }

        return n - 1;
    }

    protected virtual bool IsWordCharacter( char c )
    {
        return char.IsLetterOrDigit( c );
    }

    protected virtual int[] WordUnderCursor( int at )
    {
        var text  = Text;
        var right = Text!.Length;
        var left  = 0;
        var index = at;

        if ( at >= text?.Length )
        {
            left  = text.Length;
            right = 0;
        }
        else
        {
            if ( text != null )
            {
                for ( ; index < right; index++ )
                {
                    if ( !IsWordCharacter( text[ index ] ) )
                    {
                        right = index;

                        break;
                    }
                }

                for ( index = at - 1; index > -1; index-- )
                {
                    if ( !IsWordCharacter( text[ index ] ) )
                    {
                        left = index + 1;

                        break;
                    }
                }
            }
        }

        return [ left, right ];
    }

    protected virtual int[] WordUnderCursor( float x )
    {
        return WordUnderCursor( LetterUnderCursor( x ) );
    }

    protected virtual bool WithinMaxLength( int size )
    {
        return ( MaxLength <= 0 ) || ( size < MaxLength );
    }

    protected virtual IDrawable? GetBackgroundDrawable()
    {
        if ( Disabled && ( Style?.DisabledBackground != null ) )
        {
            return Style.DisabledBackground;
        }

        if ( ( Style?.FocusedBackground != null ) && HasKeyboardFocus() )
        {
            return Style.FocusedBackground;
        }

        return Style?.Background;
    }

    public override void Draw( IBatch batch, float parentAlpha )
    {
        if ( Style == null )
        {
            return;
        }

        var focused = HasKeyboardFocus();

        if ( ( focused != _focused ) || ( focused && ( _blinkTask?.Status != TaskStatus.Running ) ) )
        {
            _focused = focused;
            _blink.Cancel();
            _cursorOn = focused;

            if ( focused )
            {
                _blink.Start();
            }
            else
            {
                _keyRepeat.Cancel();
            }
        }
        else if ( !focused )
        {
            _cursorOn = false;
        }

        var font = Style.Font!;

        //@formatter:off
        var fontColor = Disabled && ( Style.DisabledFontColor != null )
                            ? Style.DisabledFontColor
                            : focused && ( Style.FocusedFontColor != null )
                                ? Style.FocusedFontColor
                                : Style.FontColor;
        //@formatter:on

        var selection   = Style.Selection;
        var cursorPatch = Style.Cursor;
        var background  = GetBackgroundDrawable();

        var x            = X;
        var y            = Y;
        var width        = Width;
        var height       = Height;
        var bgLeftWidth  = 0f;
        var bgRightWidth = 0f;

        batch.SetColor( Color.R, Color.G, Color.B, Color.A * parentAlpha );

        if ( background != null )
        {
            background.Draw( batch, x, y, width, height );
            bgLeftWidth  = background.LeftWidth;
            bgRightWidth = background.RightWidth;
        }

        var textY = GetTextY( font, background );

        CalculateOffsets();

        if ( focused && HasSelection && ( selection != null ) )
        {
            DrawSelection( selection, batch, font, x + bgLeftWidth, y + textY );
        }

        var yOffset = font.Flipped ? -TextHeight : 0;

        if ( DisplayText?.Length == 0 )
        {
            if ( !focused && ( MessageText != null ) )
            {
                var messageFont = Style?.MessageFont ?? font;

                if ( Style?.MessageFontColor != null )
                {
                    messageFont.SetColor( Style.MessageFontColor.R,
                                          Style.MessageFontColor.G,
                                          Style.MessageFontColor.B,
                                          Style.MessageFontColor.A * Color.A * parentAlpha );
                }
                else
                {
                    messageFont.SetColor( 0.7f, 0.7f, 0.7f, Color.A * parentAlpha );
                }

                DrawMessageText( batch, messageFont, x + bgLeftWidth, y + textY + yOffset, width - bgLeftWidth - bgRightWidth );
            }
        }
        else
        {
            font.SetColor( fontColor!.R, fontColor.G, fontColor.B, fontColor.A * Color.A * parentAlpha );
            DrawText( batch, font, x + bgLeftWidth, y + textY + yOffset );
        }

        if ( !Disabled && _cursorOn && ( cursorPatch != null ) )
        {
            DrawCursor( cursorPatch, batch, font, x + bgLeftWidth, y + textY );
        }
    }

    protected virtual float GetTextY( BitmapFont font, IDrawable? background )
    {
        var height = Height;
        var textY  = ( TextHeight / 2 ) + font.GetDescent();

        if ( background != null )
        {
            var bottom = background.BottomHeight;

            textY = textY + ( ( height - background.TopHeight - bottom ) / 2 ) + bottom;
        }
        else
        {
            textY += height / 2;
        }

        if ( font.UseIntegerPositions )
        {
            textY = ( int ) textY;
        }

        return textY;
    }

    protected virtual void DrawSelection( IDrawable selection, IBatch batch, BitmapFont font, float x, float y )
    {
        selection.Draw( batch,
                        x + TextOffset + _selectionX + FontOffset,
                        y - TextHeight - font.GetDescent(),
                        _selectionWidth,
                        TextHeight );
    }

    protected virtual void DrawText( IBatch batch, BitmapFont font, float x, float y )
    {
        if ( DisplayText != null )
        {
            font.Draw( batch, DisplayText, x + TextOffset, y, _visibleTextStart, _visibleTextEnd, 0, Align.LEFT, false );
        }
    }

    protected virtual void DrawMessageText( IBatch batch, BitmapFont font, float x, float y, float maxWidth )
    {
        if ( MessageText != null )
        {
            font.Draw( batch, MessageText, x, y, 0, MessageText.Length, maxWidth, _textAlign, false, "..." );
        }
    }

    protected virtual void DrawCursor( IDrawable cursorPatch, IBatch batch, BitmapFont font, float x, float y )
    {
        cursorPatch.Draw( batch,
                          ( ( x + TextOffset + GlyphPositions[ Cursor ] )
                          - GlyphPositions[ _visibleTextStart ] )
                        + FontOffset
                        + font.Data.CursorX,
                          y - TextHeight - font.GetDescent(),
                          cursorPatch.MinWidth,
                          TextHeight );
    }

    public virtual void UpdateDisplayText()
    {
        var font       = Style?.Font ?? new BitmapFont();
        var data       = font.Data;
        var text       = Text ?? string.Empty;
        var textLength = text.Length;
        var buffer     = new StringBuilder();

        for ( var i = 0; i < textLength; i++ )
        {
            var c = text[ i ];
            buffer.Append( data.HasGlyph( c ) ? c : ' ' );
        }

        var newDisplayText = buffer.ToString();

        if ( _passwordMode && data.HasGlyph( _passwordCharacter ) )
        {
            _passwordBuffer ??= new StringBuilder( newDisplayText.Length );

            if ( _passwordBuffer.Length > textLength )
            {
                _passwordBuffer.Length = textLength;
            }
            else
            {
                for ( var i = _passwordBuffer.Length; i < textLength; i++ )
                {
                    _passwordBuffer.Append( _passwordCharacter );
                }
            }

            DisplayText = _passwordBuffer?.ToString();
        }
        else
        {
            DisplayText = newDisplayText;
        }

        Layout.SetText( font, DisplayText?.Replace( '\r', ' ' ).Replace( '\n', ' ' )! );
        GlyphPositions.Clear();

        float x = 0;

        if ( Layout.Runs.Count > 0 )
        {
            var           run       = Layout.Runs.First();
            List< float > xAdvances = run.XAdvances;

            FontOffset = xAdvances.First();

            for ( int i = 1, n = xAdvances.Count; i < n; i++ )
            {
                GlyphPositions.Add( x );
                x += xAdvances[ i ];
            }
        }
        else
        {
            FontOffset = 0;
        }

        GlyphPositions.Add( x );

        _visibleTextStart = Math.Min( _visibleTextStart, GlyphPositions.Count - 1 );
        _visibleTextEnd   = MathUtils.Clamp( _visibleTextEnd, _visibleTextStart, GlyphPositions.Count - 1 );

        if ( SelectionStart > newDisplayText.Length )
        {
            SelectionStart = textLength;
        }
    }

    public virtual void SetText( string? str )
    {
        str ??= string.Empty;

        if ( str.Equals( Text ) )
        {
            return;
        }

        ClearSelection();

        var oldText = Text;
        Text = string.Empty;

        Paste( str, false );

        if ( ProgrammaticChangeEvents )
        {
            ChangeText( oldText!, Text );
        }

        Cursor = 0;
    }

    /// <summary>
    /// Copies the contents of this TextField to the <see cref="IClipboard"/>
    /// implementation set on this TextField.
    /// </summary>
    public void Copy()
    {
        if ( HasSelection && !PasswordMode && ( Text != null ) )
        {
            _clipboard.Contents = Text.Substring( Math.Min( Cursor, SelectionStart ),
                                                  Math.Max( Cursor, SelectionStart ) );
        }
    }

    /// <summary>
    /// Copies the selected contents of this TextField to the <see cref="IClipboard"/>
    /// implementation set on this TextField, then removes it.
    /// </summary>
    public void Cut()
    {
        Cut( ProgrammaticChangeEvents );
    }

    public void Cut( bool fireChangeEvent )
    {
        if ( HasSelection && !PasswordMode )
        {
            Copy();

            Cursor = Delete( fireChangeEvent );

            UpdateDisplayText();
        }
    }

    public void Paste( string? content, bool fireChangeEvent )
    {
        if ( ( content == null ) || ( Text == null ) )
        {
            return;
        }

        var buffer     = new StringBuilder();
        var textLength = Text.Length;

        if ( HasSelection )
        {
            textLength -= Math.Abs( Cursor - SelectionStart );
        }

        var data = Style!.Font!.Data;

        for ( int i = 0, n = content.Length; i < n; i++ )
        {
            if ( !WithinMaxLength( textLength + buffer.Length ) )
            {
                break;
            }

            var c = content[ i ];

            if ( !( WriteEnters && c is NEWLINE or CARRIAGE_RETURN ) )
            {
                if ( c is '\r' or '\n' )
                {
                    continue;
                }

                if ( _onlyFontChars && !data.HasGlyph( c ) )
                {
                    continue;
                }

                if ( ( Filter != null ) && !Filter.AcceptChar( this, c ) )
                {
                    continue;
                }
            }

            buffer.Append( c );
        }

        content = buffer.ToString();

        if ( HasSelection )
        {
            Cursor = Delete( fireChangeEvent );
        }

        if ( fireChangeEvent )
        {
            ChangeText( Text, Insert( Cursor, content, Text ) );
        }
        else
        {
            Text = Insert( Cursor, content, Text );
        }

        UpdateDisplayText();
        Cursor += content.Length;
    }

    public string? Insert( int position, string? text, string? to )
    {
        if ( to?.Length == 0 )
        {
            return text;
        }

        return to?.Substring( 0, position ) + text + to?.Substring( position, to.Length );
    }

    public int Delete( bool fireChangeEvent )
    {
        if ( Text == null )
        {
            return 0;
        }

        var from     = SelectionStart;
        var to       = Cursor;
        var minIndex = Math.Min( from, to );
        var maxIndex = Math.Max( from, to );

        var newText = ( minIndex > 0 ? Text.Substring( 0, minIndex ) : "" )
                    + ( maxIndex < Text.Length ? Text.Substring( maxIndex, Text.Length ) : "" );

        if ( fireChangeEvent )
        {
            ChangeText( Text, newText );
        }
        else
        {
            Text = newText;
        }

        ClearSelection();

        return minIndex;
    }

    /// <summary>
    /// Sets the <see cref="Stage.KeyboardFocus"/>" to the next TextField. If no
    /// next text field is found, the onscreen keyboard is hidden. Does nothing
    /// if the text field is not in a stage.
    /// </summary>
    /// <param name="up">
    /// If true, the text field with the same or next smallest y coordinate is
    /// found, else the next highest.
    /// </param>
    public void Next( bool up )
    {
        if ( Stage == null )
        {
            return;
        }

        var current       = this;
        var currentCoords = current.Parent!.LocalToStageCoordinates( _tmp2.Set( current.X, current.Y ) );

        while ( true )
        {
            var textField = current.FindNextTextField( Stage.Actors, null, _tmp1, currentCoords, up );

            if ( textField == null )
            {
                // Try to wrap around.
                if ( up )
                {
                    currentCoords.Set( -float.MaxValue, -float.MaxValue );
                }
                else
                {
                    currentCoords.Set( float.MaxValue, float.MaxValue );
                }

                textField = current.FindNextTextField( Stage.Actors, null, _tmp1, currentCoords, up );
            }

            if ( textField == null )
            {
                Gdx.Input.SetOnscreenKeyboardVisible( false );

                break;
            }

            if ( Stage.KeyboardFocus == textField )
            {
                textField.SelectAll();

                break;
            }

            current = textField;
            currentCoords.Set( _tmp1 );
        }
    }

    private TextField? FindNextTextField( SnapshotArray< Actor > actors,
                                          TextField? best,
                                          Vector2 bestCoords,
                                          Vector2 currentCoords,
                                          bool up )
    {
        for ( int i = 0, n = actors.Size; i < n; i++ )
        {
            var actor = actors.GetAt( i );

            if ( actor is TextField textField )
            {
                if ( textField == this )
                {
                    continue;
                }

                if ( textField.Disabled || !textField.FocusTraversal || !textField.AscendantsVisible() )
                {
                    continue;
                }

                var actorCoords = textField.Parent?.LocalToStageCoordinates( _tmp3.Set( textField.X, textField.Y ) );

                if ( actorCoords == null )
                {
                    continue;
                }

                var below = !actorCoords.Y.Equals( currentCoords.Y ) && ( ( actorCoords.Y < currentCoords.Y ) ^ up );
                var right = actorCoords.Y.Equals( currentCoords.Y ) && ( ( actorCoords.X > currentCoords.X ) ^ up );

                if ( !below && !right )
                {
                    continue;
                }

                var better = ( best == null )
                          || ( !actorCoords.Y.Equals( bestCoords.Y ) && ( ( actorCoords.Y > bestCoords.Y ) ^ up ) );

                if ( !better )
                {
                    better = actorCoords.Y.Equals( bestCoords.Y ) && ( ( actorCoords.X < bestCoords.X ) ^ up );
                }

                if ( better )
                {
                    best = textField;
                    bestCoords.Set( actorCoords );
                }
            }
            else if ( actor is Group group )
            {
                //TODO: Refactor to remove recursiveness 
                best = FindNextTextField( group.Children, best, bestCoords, currentCoords, up );
            }
        }

        return best;
    }

    /// <summary>
    /// returns True if the text was changed.
    /// </summary>
    private bool ChangeText( string? oldText, string? newText )
    {
        if ( ( oldText == null ) || ( newText == null ) )
        {
            return false;
        }

        if ( newText.Equals( oldText ) )
        {
            return false;
        }

        Text = newText;

        var changeEvent = Pools< ChangeListener.ChangeEvent >.Obtain();

        var cancelled = Fire( changeEvent );

        if ( cancelled )
        {
            Text = oldText;
        }

        Pools< ChangeListener.ChangeEvent >.Free( changeEvent );

        return !cancelled;
    }

    protected virtual bool ContinueCursor( int index, int offset )
    {
        return ( Text != null ) && IsWordCharacter( Text[ index + offset ] );
    }

    protected virtual void MoveCursor( bool forward, bool jump )
    {
        var limit      = forward ? Text?.Length ?? 0 : 0;
        var charOffset = forward ? 0 : -1;

        while ( ( forward ? ++Cursor < limit : --Cursor > limit ) && jump )
        {
            if ( !ContinueCursor( Cursor, charOffset ) )
            {
                break;
            }
        }
    }

    /// <summary>
    /// Sets the selected text.
    /// </summary>
    public virtual void SetSelection( int selectionStart, int selectionEnd )
    {
        if ( selectionStart < 0 )
        {
            throw new ArgumentException( "SelectionStart must be >= 0" );
        }

        if ( selectionEnd < 0 )
        {
            throw new ArgumentException( "selectionEnd must be >= 0" );
        }

        if ( Text != null )
        {
            selectionStart = Math.Min( Text.Length, selectionStart );
            selectionEnd   = Math.Min( Text.Length, selectionEnd );

            if ( selectionEnd == selectionStart )
            {
                ClearSelection();

                return;
            }

            if ( selectionEnd < selectionStart )
            {
                ( selectionEnd, selectionStart ) = ( selectionStart, selectionEnd );
            }

            HasSelection   = true;
            SelectionStart = selectionStart;
            Cursor         = selectionEnd;
        }
    }

    public void SelectAll()
    {
        if ( Text != null )
        {
            SetSelection( 0, Text.Length );
        }
    }

    public void ClearSelection()
    {
        HasSelection = false;
    }

    /// <summary>
    /// Sets the cursor position and clears any selection.
    /// </summary>
    public void SetCursorPosition( int cursorPosition )
    {
        if ( cursorPosition < 0 )
        {
            throw new ArgumentException( "cursorPosition must be >= 0" );
        }

        ClearSelection();

        Cursor = Math.Min( cursorPosition, Text!.Length );
    }

    // ========================================================================
    // ========================================================================

    private sealed class BlinkTaskManager
    {
        private readonly TextField _tf;

        public BlinkTaskManager( TextField tf )
        {
            _tf = tf;
        }

        public void Create()
        {
            _tf._blinkTokenSource       = new CancellationTokenSource();
            _tf._blinkCancellationToken = _tf._blinkTokenSource.Token;

            CreateBlinkTask();
        }

        private void CreateBlinkTask()
        {
            //@formatter:off
            _tf._blinkTask = new Task( () =>
               {
                   _tf._cursorOn = !_tf._cursorOn;
                   Gdx.Graphics.RequestRendering();
               },
               _tf._blinkCancellationToken );
            //@formatter:on
        }

        public void Start()
        {
            if ( _tf is not { _blinkTask: not null } )
            {
                throw new GdxRuntimeException( "Unable to start BlinkTask" );
            }

            _tf._blinkTask.Start();
        }

        public void Cancel()
        {
            if ( _tf._blinkTask is { Status: TaskStatus.Running } )
            {
                _tf._blinkTokenSource?.Cancel();
            }
        }
    }

    // ========================================================================
    // ========================================================================

    [PublicAPI]
    public sealed class KeyRepeatTaskManager
    {
        private readonly TextField _tf;

        public KeyRepeatTaskManager( TextField tf )
        {
            _tf = tf;
        }

        public int KeyCode { get; set; }

        public void Create()
        {
            _tf._keyRepeatTokenSource       = new CancellationTokenSource();
            _tf._keyRepeatCancellationToken = _tf._keyRepeatTokenSource.Token;

            //@formatter:off
            _tf._keyRepeatTask = new Task( () =>
            {
                _tf._inputListener?.KeyDown( null, KeyCode );
                
                if ( _tf._keyRepeatTokenSource.IsCancellationRequested )
                {
                    _tf._keyRepeatCancellationToken.ThrowIfCancellationRequested();
                }
            },
            _tf._keyRepeatCancellationToken );
            //@formatter:on
        }

        public void Start()
        {
            if ( _tf is not { _keyRepeatTask: not null } )
            {
                throw new GdxRuntimeException( "Unable to start KeyRepeatTask" );
            }

            _tf._keyRepeatTask.Start();
        }

        public void Cancel()
        {
            if ( _tf._keyRepeatTask is { Status: TaskStatus.Running } )
            {
                _tf._keyRepeatTokenSource?.Cancel();
            }
        }
    }

    // ========================================================================
    // ========================================================================

    /// <summary>
    /// The style for a <see cref="TextField"/>.
    /// </summary>
    [PublicAPI]
    public class TextFieldStyle
    {
        public TextFieldStyle()
        {
        }

        public TextFieldStyle( BitmapFont font,
                               Color fontColor,
                               IDrawable? cursor,
                               IDrawable? selection,
                               IDrawable? background )
        {
            Font       = font;
            FontColor  = fontColor;
            Cursor     = cursor;
            Selection  = selection;
            Background = background;
        }

        public TextFieldStyle( TextFieldStyle style )
        {
            Font = style.Font;

            if ( style.FontColor != null )
            {
                FontColor = new Color( style.FontColor );
            }

            if ( style.FocusedFontColor != null )
            {
                FocusedFontColor = new Color( style.FocusedFontColor );
            }

            if ( style.DisabledFontColor != null )
            {
                DisabledFontColor = new Color( style.DisabledFontColor );
            }

            Background         = style.Background;
            FocusedBackground  = style.FocusedBackground;
            DisabledBackground = style.DisabledBackground;
            Cursor             = style.Cursor;
            Selection          = style.Selection;

            MessageFont = style.MessageFont;

            if ( style.MessageFontColor != null )
            {
                MessageFontColor = new Color( style.MessageFontColor );
            }
        }

        public BitmapFont? Font               { get; set; }
        public Color?      FontColor          { get; set; }
        public Color?      FocusedFontColor   { get; set; }
        public Color?      DisabledFontColor  { get; set; }
        public IDrawable?  Background         { get; set; }
        public IDrawable?  FocusedBackground  { get; set; }
        public IDrawable?  DisabledBackground { get; set; }
        public IDrawable?  Cursor             { get; set; }
        public IDrawable?  Selection          { get; set; }
        public BitmapFont? MessageFont        { get; set; }
        public Color?      MessageFontColor   { get; set; }
    }

    // ========================================================================
    // ========================================================================

    [PublicAPI]
    public class TextFieldClickListener : ClickListener
    {
        private readonly TextField _tf;

        protected TextFieldClickListener()
        {
            _tf = new TextField( "", new Skin() );
        }

        protected internal TextFieldClickListener( TextField tf )
        {
            _tf = tf;
        }

        /// <inheritdoc />
        public override void OnClicked( InputEvent ev, float x, float y )
        {
            var count = TapCount % 4;

            if ( count == 0 )
            {
                _tf.ClearSelection();
            }

            if ( count == 2 )
            {
                var array = _tf.WordUnderCursor( x );
                _tf.SetSelection( array[ 0 ], array[ 1 ] );
            }

            if ( count == 3 )
            {
                _tf.SelectAll();
            }
        }

        /// <inheritdoc />
        public override bool TouchDown( InputEvent? ev, float x, float y, int pointer, int button )
        {
            if ( !base.TouchDown( ev, x, y, pointer, button ) )
            {
                return false;
            }

            if ( ( pointer == 0 ) && ( button != 0 ) )
            {
                return false;
            }

            if ( _tf.Disabled )
            {
                return true;
            }

            SetCursorPosition( x, y );
            _tf.SelectionStart = _tf.Cursor;

            if ( _tf.Stage != null )
            {
                _tf.Stage.KeyboardFocus = _tf;
            }

            _tf._keyboard.Show( true );
            _tf.HasSelection = true;

            return true;
        }

        /// <inheritdoc />
        public override void TouchDragged( InputEvent? ev, float x, float y, int pointer )
        {
            base.TouchDragged( ev, x, y, pointer );
            SetCursorPosition( x, y );
        }

        /// <inheritdoc />
        public override void TouchUp( InputEvent? ev, float x, float y, int pointer, int button )
        {
            if ( _tf.SelectionStart == _tf.Cursor )
            {
                _tf.HasSelection = false;
            }

            base.TouchUp( ev, x, y, pointer, button );
        }

        protected virtual void GoHome( bool jump )
        {
            _tf.Cursor = 0;
        }

        protected virtual void GoEnd( bool jump )
        {
            _tf.Cursor = _tf.Text?.Length ?? 1;
        }

        /// <inheritdoc />
        public override bool KeyDown( InputEvent? ev, int keycode )
        {
            if ( _tf.Disabled )
            {
                return false;
            }

            _tf._cursorOn = _tf._focused;
            _tf._blink.Cancel();

            if ( _tf._focused )
            {
//                Timer.schedule( _tf._blinkTask, _tf._blinkTime, _tf._blinkTime );
            }

            if ( !_tf.HasKeyboardFocus() )
            {
                return false;
            }

            var repeat  = false;
            var ctrl    = InputUtils.CtrlKey();
            var jump    = ctrl && !_tf._passwordMode;
            var handled = true;

            if ( ctrl )
            {
                switch ( keycode )
                {
                    case IInput.Keys.V:
                        _tf.Paste( _tf._clipboard.Contents, true );
                        repeat = true;

                        break;

                    case IInput.Keys.C:
                    case IInput.Keys.INSERT:
                        _tf.Copy();

                        return true;

                    case IInput.Keys.X:
                        _tf.Cut( true );

                        return true;

                    case IInput.Keys.A:
                        _tf.SelectAll();

                        return true;

                    case IInput.Keys.Z:
                        var oldText = _tf.Text;

                        _tf.SetText( _tf._undoText );
                        _tf._undoText = oldText;
                        _tf.UpdateDisplayText();

                        return true;

                    default:
                        handled = false;

                        break;
                }
            }

            if ( InputUtils.ShiftKey() )
            {
                switch ( keycode )
                {
                    case IInput.Keys.INSERT:
                        _tf.Paste( _tf._clipboard.Contents, true );

                        break;

                    case IInput.Keys.FORWARD_DEL:
                        _tf.Cut( true );

                        break;
                }

                var temp = _tf.Cursor;

                switch ( keycode )
                {
                    case IInput.Keys.LEFT:
                        _tf.MoveCursor( false, jump );
                        repeat  = true;
                        handled = true;

                        break;

                    case IInput.Keys.RIGHT:
                        _tf.MoveCursor( true, jump );
                        repeat  = true;
                        handled = true;

                        break;

                    case IInput.Keys.HOME:
                        GoHome( jump );
                        handled = true;

                        break;

                    case IInput.Keys.END:
                        GoEnd( jump );
                        handled = true;

                        break;
                }

                if ( !_tf.HasSelection )
                {
                    _tf.SelectionStart = temp;
                    _tf.HasSelection   = true;
                }
            }
            else
            {
                // Cursor movement or other keys (kills selection).
                switch ( keycode )
                {
                    case IInput.Keys.LEFT:
                        _tf.MoveCursor( false, jump );
                        _tf.ClearSelection();
                        repeat  = true;
                        handled = true;

                        break;

                    case IInput.Keys.RIGHT:
                        _tf.MoveCursor( true, jump );
                        _tf.ClearSelection();
                        repeat  = true;
                        handled = true;

                        break;

                    case IInput.Keys.HOME:
                        GoHome( jump );
                        _tf.ClearSelection();
                        handled = true;

                        break;

                    case IInput.Keys.END:
                        GoEnd( jump );
                        _tf.ClearSelection();
                        handled = true;

                        break;
                }
            }

            _tf.Cursor = MathUtils.Clamp( _tf.Cursor, 0, _tf.Text!.Length );

            if ( repeat )
            {
                ScheduleKeyRepeatTask( keycode );
            }

            return handled;
        }

        public override bool KeyUp( InputEvent? ev, int keycode )
        {
            if ( _tf.Disabled )
            {
                return false;
            }

            _tf._keyRepeat.Cancel();

            return true;
        }

        /// <summary>
        /// Checks if focus traversal should be triggered. The default implementation
        /// uses <see cref="TextField.FocusTraversal"/> and the typed character,
        /// depending on the OS.
        /// </summary>
        /// <param name="character"> The character that triggered a possible focus traversal. </param>
        /// <returns>
        /// true if the focus should change to the <see cref="TextField.Next(bool)"/> input field.
        /// </returns>
        protected virtual bool CheckFocusTraversal( char character )
        {
            return _tf.FocusTraversal
                && ( ( character == TAB )
                  || ( character is CARRIAGE_RETURN or NEWLINE && ( Platform.IsAndroid || Platform.IsIos ) ) );
        }

        public override bool KeyTyped( InputEvent? ev, char character )
        {
            if ( _tf.Disabled )
            {
                return false;
            }

            // Disallow "typing" most ASCII control characters, which would
            // show up as a space when onlyFontChars is true.
            switch ( character )
            {
                case BACKSPACE:
                case TAB:
                case NEWLINE:
                case CARRIAGE_RETURN:
                    break;

                default:
                    if ( character < 32 )
                    {
                        return false;
                    }

                    break;
            }

            if ( !_tf.HasKeyboardFocus() )
            {
                return false;
            }

            if ( Platform.IsMac && Gdx.Input.IsKeyPressed( IInput.Keys.SYM ) )
            {
                return true;
            }

            if ( CheckFocusTraversal( character ) )
            {
                _tf.Next( InputUtils.ShiftKey() );
            }
            else
            {
                var enter     = character is CARRIAGE_RETURN or NEWLINE;
                var delete    = character == DELETE;
                var backspace = character == BACKSPACE;

                var add = enter
                              ? _tf.WriteEnters
                              : !_tf._onlyFontChars || _tf.Style!.Font!.Data.HasGlyph( character );

                var remove = backspace || delete;

                if ( add || remove )
                {
                    var oldText   = _tf.Text;
                    var oldCursor = _tf.Cursor;

                    if ( remove )
                    {
                        if ( _tf.HasSelection )
                        {
                            _tf.Cursor = _tf.Delete( false );
                        }
                        else
                        {
                            if ( backspace && ( _tf.Cursor > 0 ) )
                            {
                                _tf.Text = _tf.Text?.Substring( 0, _tf.Cursor - 1 )
                                         + _tf.Text?.Substring( _tf.Cursor-- );

                                _tf._renderOffset = 0;
                            }

                            if ( delete && ( _tf.Cursor < _tf.Text?.Length ) )
                            {
                                _tf.Text = _tf.Text?.Substring( 0, _tf.Cursor ) + _tf.Text?.Substring( _tf.Cursor + 1 );
                            }
                        }
                    }

                    if ( add && !remove )
                    {
                        // Character may be added to the text.
                        if ( !enter && ( _tf.Filter != null ) && !_tf.Filter.AcceptChar( _tf, character ) )
                        {
                            return true;
                        }

                        if ( !_tf.WithinMaxLength( _tf.Text!.Length
                                                 - ( _tf.HasSelection
                                                         ? Math.Abs( _tf.Cursor - _tf.SelectionStart )
                                                         : 0 ) ) )
                        {
                            return true;
                        }

                        if ( _tf.HasSelection )
                        {
                            _tf.Cursor = _tf.Delete( false );
                        }

                        var insertion = enter ? "\n" : character.ToString();

                        _tf.Text = _tf.Insert( _tf.Cursor++, insertion, _tf.Text );
                    }

                    if ( _tf.ChangeText( oldText, _tf.Text ) )
                    {
                        var time = TimeUtils.Millis();

                        if ( ( time - 750 ) > _tf._lastChangeTime )
                        {
                            _tf._undoText = oldText;
                        }

                        _tf._lastChangeTime = time;
                        _tf.UpdateDisplayText();
                    }
                    else
                    {
                        _tf.Cursor = oldCursor;
                    }
                }
            }

            _tf.Listener?.KeyTyped( _tf, character );

            return true;
        }

        protected virtual void SetCursorPosition( float x, float y )
        {
            _tf.Cursor    = _tf.LetterUnderCursor( x );
            _tf._cursorOn = _tf._focused;

            _tf._blink.Cancel();

            if ( _tf._focused )
            {
//TODO:
//                Timer.Schedule( _tf._blinkTask, _tf._blinkTime, _tf._blinkTime );
            }
        }

        protected virtual void ScheduleKeyRepeatTask( int keycode )
        {
            if ( _tf._keyRepeat.KeyCode != keycode )
            {
                _tf._keyRepeat.KeyCode = keycode;
            }
        }
    }

    // ========================================================================
    // ========================================================================

    /// <summary>
    /// Interface for listening to typed characters.
    /// </summary>
    [PublicAPI]
    public interface ITextFieldListener
    {
        void KeyTyped( TextField textField, char c );
    }

    // ========================================================================
    // ========================================================================

    /// <summary>
    /// Interface for filtering characters entered into the text field.
    /// </summary>
    [PublicAPI]
    public interface ITextFieldFilter
    {
        bool AcceptChar( TextField textField, char c );

        class DigitsOnlyFilter : ITextFieldFilter
        {
            public bool AcceptChar( TextField textField, char c )
            {
                return char.IsDigit( c );
            }
        }
    }

    // ========================================================================
    // ========================================================================

    /// <summary>
    /// An interface for onscreen keyboards.
    /// Can invoke the default keyboard or render your own keyboard!
    /// </summary>
    [PublicAPI]
    public interface IOnscreenKeyboard
    {
        void Show( bool visible );
    }

    // ========================================================================
    // ========================================================================

    /// <summary>
    /// The default <see cref="IOnscreenKeyboard"/> used by all {@link TextField} instances.
    /// Just uses <see cref="IInput.SetOnscreenKeyboardVisible(bool)"/> as appropriate. Might
    /// overlap your actual rendering, so use with care!
    /// </summary>
    [PublicAPI]
    public class DefaultOnscreenKeyboard : IOnscreenKeyboard
    {
        public void Show( bool visible )
        {
            Gdx.Input.SetOnscreenKeyboardVisible( visible );
        }
    }
}
