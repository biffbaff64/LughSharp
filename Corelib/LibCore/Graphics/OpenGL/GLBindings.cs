// ///////////////////////////////////////////////////////////////////////////////
// MIT License
// 
// Copyright (c) 2023 dcronqvist (Daniel Cronqvist <daniel@dcronqvist.se>)
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// ///////////////////////////////////////////////////////////////////////////////

#pragma warning disable IDE0079 // Remove unnecessary suppression
#pragma warning disable CS8618  // Non-nullable field is uninitialized. Consider declaring as nullable.
#pragma warning disable CS8603  // Possible null reference return.
#pragma warning disable IDE0060 // Remove unused parameter.
#pragma warning disable IDE1006 // Naming Styles.
#pragma warning disable IDE0090 // Use 'new(...)'.
#pragma warning disable CS8500  // This takes the address of, gets the size of, or declares a pointer to a managed type

//@formatter:off

// ----------------------------------------------------------------------------

#if !OGL_WRAPPER_API_BOTH && !OGL_WRAPPER_API_UNSAFE && !OGL_WRAPPER_API_SAFE
#error You must define one of OGL_WRAPPER_API_BOTH, OGL_WRAPPER_API_UNSAFE, or OGL_WRAPPER_API_SAFE
#endif



// ----------------------------------------------------------------------------

#if OGL_P_CORE

    // ----------------------------------------------------------------------------

    using System.Numerics;

    using Corelib.LibCore.Utils;
#if OGL_V_1_0 || OGL_V_1_1 || OGL_V_1_2 || OGL_V_1_3 || OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    using GLenum = System.Int32;
        using GLfloat = System.Single;
        using GLint = System.Int32;
        using GLsizei = System.Int32;
        using GLbitfield = System.UInt32;
        using GLdouble = System.Double;
        using GLuint = System.UInt32;
        using GLboolean = System.Boolean;
        using GLubyte = System.Byte;

    #endif

    // ----------------------------------------------------------------------------

    #if OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        
        using GLsizeiptr = System.Int32;
        using GLintptr = System.Int32;

    #endif

    // ----------------------------------------------------------------------------

    #if OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6

        using GLshort = System.Int16;
        using GLbyte = System.SByte;
        using GLushort = System.UInt16;
        using GLchar = System.Byte;

    #endif

    // ----------------------------------------------------------------------------

    #if OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6

        using GLuint64 = System.UInt64;
        using GLint64 = System.Int64;

    #endif

    // ----------------------------------------------------------------------------

#endif

// ----------------------------------------------------------------------------

//@formatter:on

namespace Corelib.LibCore.Graphics.OpenGL;

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

/// <summary>
/// Bindings for OpenGL, both core and compatibility profiles. Blazing fast, low level,
/// direct access to the OpenGL API for all versions of OpenGL, using the unmanaged
/// delegates feature in C# 9.0,
/// <para>
///     <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers"/>
/// </para>
/// <para>
/// Also includes a few overloads of many functions to make them a bit more C# friendly
/// (e.g. passing arrays of bytes or floats instead of passing pointers to fixed memory
/// locations). Significant effort has been made to make sure that the overloads are as
/// efficient as possible, in terms of both performance and memory usage.
/// </para>
/// </summary>
public unsafe class GLBindings : IGLBindings
{
    /// <summary>
    /// The null pointer, just like in C/C++.
    /// </summary>
    public readonly void* NULL = ( void* )0;

    // ------------------------------------------------------------------------

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    public (int major, int minor) GetOpenGLVersion()
    {
        var version = glGetString( IGL.GL_VERSION );

        if ( version == null )
        {
            Logger.Debug( "NULL GL Version returned!" );
        }

        return version == null
            ? ( GraphicsData.DEFAULT_GL_MAJOR, GraphicsData.DEFAULT_GL_MINOR )
            : ( version[ 0 ], version[ 2 ] );
    }

#if OGL_P_CORE
    /// <summary>
    /// Is used as the loading function for OpenGL functions. Typically comes from something like GLFW.
    /// </summary>
    /// <param name="funcName">The name of the function to load.</param>
    /// <returns>A pointer to the function.</returns>
    public delegate IntPtr GetProcAddressHandler( string funcName );

    // OpenGL 1.0

#if OGL_V_1_0 || OGL_V_1_1 || OGL_V_1_2 || OGL_V_1_3 || OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCULLFACEPROC( GLenum mode );

    private PFNGLCULLFACEPROC _glCullFace;

    /// <summary>
    /// Specify whether front- or back-facing facets can be culled
    /// </summary>
    /// <param name="mode">
    /// Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants
    /// <see cref="IGL.GL_FRONT"/>, <see cref="IGL.GL_BACK"/>, and <see cref="IGL.GL_FRONT_AND_BACK"/> are accepted.
    /// The initial value is <see cref="IGL.GL_BACK"/>.
    /// </param>
    public void glCullFace( GLenum mode )
    {
        _glCullFace( mode );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLFRONTFACEPROC( GLenum mode );

    private PFNGLFRONTFACEPROC _glFrontFace;

    /// <summary>
    /// Define front- and back-facing polygons
    /// </summary>
    /// <param name="mode">
    /// Specifies the orientation of front-facing polygons. Symbolic constants <see cref="IGL.GL_CW"/> and
    /// <see cref="IGL.GL_CCW"/> are accepted. The initial value is <see cref="IGL.GL_CCW"/>.
    /// </param>
    public void glFrontFace( GLenum mode )
    {
        _glFrontFace( mode );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLHINTPROC( GLenum target, GLenum mode );

    private PFNGLHINTPROC _glHint;

    /// <summary>
    /// Specify implementation-specific hints
    /// </summary>
    /// <param name="target">
    /// Specifies a symbolic constant indicating the behavior to be controlled.
    /// <see cref="IGL.GL_LINE_SMOOTH_HINT"/>, <see cref="IGL.GL_POLYGON_SMOOTH_HINT"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPRESSION_HINT"/>, and <see cref="IGL.GL_FRAGMENT_SHADER_DERIVATIVE_HINT"/> are accepted.
    /// </param>
    /// <param name="mode">
    /// Specifies a symbolic constant indicating the desired behavior. <see cref="IGL.GL_FASTEST"/>,
    /// <see cref="IGL.GL_NICEST"/>, and <see cref="IGL.GL_DONT_CARE"/> are accepted.
    /// </param>
    public void glHint( GLenum target, GLenum mode )
    {
        _glHint( target, mode );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLLINEWIDTHPROC( GLfloat width );

    private PFNGLLINEWIDTHPROC _glLineWidth;

    /// <summary>
    /// Specify the width of rasterized lines
    /// </summary>
    /// <param name="width">Specifies the width of rasterized lines. The initial value is 1.0.</param>
    public void glLineWidth( GLfloat width )
    {
        _glLineWidth( width );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPOINTSIZEPROC( GLfloat size );

    private PFNGLPOINTSIZEPROC _glPointSize;

    /// <summary>
    /// Specify the diameter of rasterized points
    /// </summary>
    /// <param name="size">Specifies the diameter of rasterized points. The initial value is 1.0.</param>
    public void glPointSize( GLfloat size )
    {
        _glPointSize( size );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPOLYGONMODEPROC( GLenum face, GLenum mode );

    private PFNGLPOLYGONMODEPROC _glPolygonMode;

    /// <summary>
    /// Select a polygon rasterization mode
    /// </summary>
    /// <param name="face">
    /// Specifies the polygons that mode applies to. Must be <see cref="IGL.GL_FRONT_AND_BACK"/> for both
    /// front- and back-facing polygons.
    /// </param>
    /// <param name="mode">
    /// Specifies how polygons will be rasterized. Accepted values are <see cref="IGL.GL_POINT"/>,
    /// <see cref="IGL.GL_LINE"/>, and <see cref="IGL.GL_FILL"/>. The initial value is <see cref="IGL.GL_FILL"/> for both front- and
    /// back-facing polygons.
    /// </param>
    public void glPolygonMode( GLenum face, GLenum mode )
    {
        _glPolygonMode( face, mode );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSCISSORPROC( GLint x, GLint y, GLsizei width, GLsizei height );

    private PFNGLSCISSORPROC _glScissor;

    /// <summary>
    /// Define the scissor box
    /// </summary>
    /// <param name="x">Specify the lower left corner of the scissor box. Initially (0, 0).</param>
    /// <param name="y">Specify the lower left corner of the scissor box. Initially (0, 0).</param>
    /// <param name="width">Specify the width of the scissor box.</param>
    /// <param name="height">Specify the height of the scissor box.</param>
    public void glScissor( GLint x, GLint y, GLsizei width, GLsizei height )
    {
        _glScissor( x, y, width, height );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXPARAMETERFPROC( GLenum target, GLenum pname, GLfloat param );

    private PFNGLTEXPARAMETERFPROC _glTexParameterf;

    /// <summary>
    /// Set texture parameters
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture is bound for glTexParameter functions. Must be one of
    /// <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>, or <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter.
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, and <see cref="IGL.GL_TEXTURE_WRAP_R"/> are
    /// accepted. For the vector commands (those that end in v), <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/> or
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_RGBA"/> is also acceptable.
    /// </param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTexParameterf( GLenum target, GLenum pname, GLfloat param )
    {
        _glTexParameterf( target, pname, param );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXPARAMETERFVPROC( GLenum target, GLenum pname, GLfloat* @params );

    private PFNGLTEXPARAMETERFVPROC _glTexParameterfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set texture parameters
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture is bound for glTexParameter functions. Must be one of
    /// <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>, or <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter.
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, and <see cref="IGL.GL_TEXTURE_WRAP_R"/> are
    /// accepted. For the vector commands (those that end in v), <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/> or
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_RGBA"/> is also acceptable.
    /// </param>
    /// <param name="params">Specifies the values of pname.</param>
    public void glTexParameterfv( GLenum target, GLenum pname, GLfloat* @params )
    {
        _glTexParameterfv( target, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set texture parameters
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture is bound for glTexParameter functions. Must be one of
    /// <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>, or <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter.
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, and <see cref="IGL.GL_TEXTURE_WRAP_R"/> are
    /// accepted. For the vector commands (those that end in v), <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/> or
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_RGBA"/> is also acceptable.
    /// </param>
    /// <param name="params">Specifies the values of pname.</param>
    public void glTexParameterfv( GLenum target, GLenum pname, GLfloat[] @params )
    {
        fixed ( GLfloat* p =
                   &@params[ 0 ] )
        {
            _glTexParameterfv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXPARAMETERIPROC( GLenum target, GLenum pname, GLint param );

    private PFNGLTEXPARAMETERIPROC _glTexParameteri;

    /// <summary>
    /// Set texture parameters
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture is bound for glTexParameter functions. Must be one of
    /// <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>, or <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter.
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, and <see cref="IGL.GL_TEXTURE_WRAP_R"/> are
    /// accepted. For the vector commands (those that end in v), <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/> or
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_RGBA"/> is also acceptable.
    /// </param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTexParameteri( GLenum target, GLenum pname, GLint param )
    {
        _glTexParameteri( target, pname, param );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXPARAMETERIVPROC( GLenum target, GLenum pname, GLint* @params );

    private PFNGLTEXPARAMETERIVPROC _glTexParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set texture parameters
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture is bound for glTexParameter functions. Must be one of
    /// <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>, or <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter.
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, and <see cref="IGL.GL_TEXTURE_WRAP_R"/> are
    /// accepted. For the vector commands (those that end in v), <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/> or
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_RGBA"/> is also acceptable.
    /// </param>
    /// <param name="params">Specifies the values of pname.</param>
    public void glTexParameteriv( GLenum target, GLenum pname, GLint* @params )
    {
        _glTexParameteriv( target, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set texture parameters
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture is bound for glTexParameter functions. Must be one of
    /// <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>, or <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter.
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, and <see cref="IGL.GL_TEXTURE_WRAP_R"/> are
    /// accepted. For the vector commands (those that end in v), <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/> or
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_RGBA"/> is also acceptable.
    /// </param>
    /// <param name="params">Specifies the values of pname.</param>
    public void glTexParameteriv( GLenum target, GLenum pname, GLint[] @params )
    {
        fixed ( GLint* p = &@params[ 0 ] )
        {
            _glTexParameteriv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXIMAGE1DPROC( GLenum target,
                                               GLint level,
                                               GLenum internalformat,
                                               GLsizei width,
                                               GLint border,
                                               GLenum format,
                                               GLenum type,
                                               void* pixels );

    private PFNGLTEXIMAGE1DPROC _glTexImage1D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a one-dimensional texture image
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/> or
    /// <see cref="IGL.GL_PROXY_TEXTURE_1D"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the number of color components in the texture. Refer to
    /// <see href="https://docs.gl/gl4/glTexImage1D"/> for a list of possible values.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support texture images that are at
    /// least 1024 texels wide. The height of the 1D texture image is 1.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_BGRA"/>, <see cref="IGL.GL_RED_INTEGER"/>, <see cref="IGL.GL_RG_INTEGER"/>, <see cref="IGL.GL_RGB_INTEGER"/>,
    /// <see cref="IGL.GL_BGR_INTEGER"/>, <see cref="IGL.GL_RGBA_INTEGER"/>, <see cref="IGL.GL_BGRA_INTEGER"/>,
    /// <see cref="IGL.GL_STENCIL_INDEX"/>, <see cref="IGL.GL_DEPTH_COMPONENT"/>, <see cref="IGL.GL_DEPTH_STENCIL"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
    public void glTexImage1D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, void* pixels )
    {
        _glTexImage1D( target, level, internalformat, width, border, format, type, pixels );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a one-dimensional texture image
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/> or
    /// <see cref="IGL.GL_PROXY_TEXTURE_1D"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the number of color components in the texture. Refer to
    /// <see href="https://docs.gl/gl4/glTexImage1D"/> for a list of possible values.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support texture images that are at
    /// least 1024 texels wide. The height of the 1D texture image is 1.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_BGRA"/>, <see cref="IGL.GL_RED_INTEGER"/>, <see cref="IGL.GL_RG_INTEGER"/>, <see cref="IGL.GL_RGB_INTEGER"/>,
    /// <see cref="IGL.GL_BGR_INTEGER"/>, <see cref="IGL.GL_RGBA_INTEGER"/>, <see cref="IGL.GL_BGRA_INTEGER"/>,
    /// <see cref="IGL.GL_STENCIL_INDEX"/>, <see cref="IGL.GL_DEPTH_COMPONENT"/>, <see cref="IGL.GL_DEPTH_STENCIL"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">
    /// Specifies the pixel data as an array of values. Make sure to match the generic type with the
    /// <paramref name="type"/> parameter.
    /// </param>
    public void glTexImage1D< T >( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, T[] pixels )
        where T : unmanaged
    {
        fixed ( void* p = &pixels[ 0 ] )
        {
            _glTexImage1D( target, level, internalformat, width, border, format, type, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXIMAGE2DPROC( GLenum target,
                                               GLint level,
                                               GLenum internalformat,
                                               GLsizei width,
                                               GLsizei height,
                                               GLint border,
                                               GLenum format,
                                               GLenum type,
                                               void* pixels );

    private PFNGLTEXIMAGE2DPROC _glTexImage2D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a two-dimensional texture image
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>, <see cref="IGL.GL_PROXY_TEXTURE_RECTANGLE"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP_ARRAY"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, or
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image. If <paramref name="target"/> is <see cref="IGL.GL_TEXTURE_RECTANGLE"/> or
    /// <see cref="IGL.GL_PROXY_TEXTURE_RECTANGLE"/>, <paramref name="level"/> must be 0.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the number of color components in the texture. Refer to
    /// <see href="https://docs.gl/gl4/glTexImage2D"/> for the list of possible values.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support texture images that are at
    /// least 1024 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture image, or the number of layers in a texture array, in the case
    /// of the <see cref="IGL.GL_TEXTURE_1D_ARRAY"/> and <see cref="IGL.GL_PROXY_TEXTURE_1D_ARRAY"/> targets. ALl implementations
    /// support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_BGRA"/>, <see cref="IGL.GL_RED_INTEGER"/>, <see cref="IGL.GL_RG_INTEGER"/>, <see cref="IGL.GL_RGB_INTEGER"/>,
    /// <see cref="IGL.GL_BGR_INTEGER"/>, <see cref="IGL.GL_RGBA_INTEGER"/>, <see cref="IGL.GL_BGRA_INTEGER"/>,
    /// <see cref="IGL.GL_STENCIL_INDEX"/>, <see cref="IGL.GL_DEPTH_COMPONENT"/>, <see cref="IGL.GL_DEPTH_STENCIL"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
    public void glTexImage2D( GLenum target,
                              GLint level,
                              GLenum internalformat,
                              GLsizei width,
                              GLsizei height,
                              GLint border,
                              GLenum format,
                              GLenum type,
                              void* pixels )
    {
        _glTexImage2D( target, level, internalformat, width, height, border, format, type, pixels );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a two-dimensional texture image
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>, <see cref="IGL.GL_PROXY_TEXTURE_RECTANGLE"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP_ARRAY"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, or
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image. If <paramref name="target"/> is <see cref="IGL.GL_TEXTURE_RECTANGLE"/> or
    /// <see cref="IGL.GL_PROXY_TEXTURE_RECTANGLE"/>, <paramref name="level"/> must be 0.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the number of color components in the texture. Refer to
    /// <see href="https://docs.gl/gl4/glTexImage2D"/> for the list of possible values.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support texture images that are at
    /// least 1024 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture image, or the number of layers in a texture array, in the case
    /// of the <see cref="IGL.GL_TEXTURE_1D_ARRAY"/> and <see cref="IGL.GL_PROXY_TEXTURE_1D_ARRAY"/> targets. ALl implementations
    /// support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_BGRA"/>, <see cref="IGL.GL_RED_INTEGER"/>, <see cref="IGL.GL_RG_INTEGER"/>, <see cref="IGL.GL_RGB_INTEGER"/>,
    /// <see cref="IGL.GL_BGR_INTEGER"/>, <see cref="IGL.GL_RGBA_INTEGER"/>, <see cref="IGL.GL_BGRA_INTEGER"/>,
    /// <see cref="IGL.GL_STENCIL_INDEX"/>, <see cref="IGL.GL_DEPTH_COMPONENT"/>, <see cref="IGL.GL_DEPTH_STENCIL"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">
    /// Specifies the pixel data as an array of values. Make sure to match the <paramref name="format"/>
    /// and <paramref name="type"/> parameters.
    /// </param>
    public void glTexImage2D< T >( GLenum target,
                                   GLint level,
                                   GLenum internalformat,
                                   GLsizei width,
                                   GLsizei height,
                                   GLint border,
                                   GLenum format,
                                   GLenum type,
                                   T[] pixels ) where T : unmanaged
    {
        fixed ( void* p
                   = &pixels[ 0 ] )
        {
            _glTexImage2D( target, level, internalformat, width, height, border, format, type, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDRAWBUFFERPROC( GLenum buf );

    private PFNGLDRAWBUFFERPROC _glDrawBuffer;

    /// <summary>
    /// Specify which color buffers are to be drawn into.
    /// </summary>
    /// <param name="buf">
    /// Specifies up to four color buffers to be drawn into. Must be one of <see cref="IGL.GL_NONE"/>,
    /// <see cref="IGL.GL_FRONT_LEFT"/>, <see cref="IGL.GL_FRONT_RIGHT"/>, <see cref="IGL.GL_BACK_LEFT"/>,
    /// <see cref="IGL.GL_BACK_RIGHT"/>, <see cref="IGL.GL_FRONT"/>, <see cref="IGL.GL_BACK"/>, <see cref="IGL.GL_LEFT"/>,
    /// <see cref="IGL.GL_RIGHT"/>, <see cref="IGL.GL_FRONT_AND_BACK"/>. The initial value is <see cref="IGL.GL_FRONT"/> for single
    /// buffered contexts, and <see cref="IGL.GL_BACK"/> for double buffered contexts.
    /// </param>
    public void glDrawBuffer( GLenum buf )
    {
        _glDrawBuffer( buf );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCLEARPROC( GLbitfield mask );

    private PFNGLCLEARPROC? _glClear;

    /// <summary>
    /// Clear buffers to preset values.
    /// </summary>
    /// <param name="mask">
    /// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are
    /// <see cref="IGL.GL_COLOR_BUFFER_BIT"/>, <see cref="IGL.GL_DEPTH_BUFFER_BIT"/>, and <see cref="IGL.GL_STENCIL_BUFFER_BIT"/>.
    /// </param>
    public void glClear( GLbitfield mask )
    {
        _glClear( mask );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCLEARCOLORPROC( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );

    private PFNGLCLEARCOLORPROC _glClearColor;

    /// <summary>
    /// Specify clear values for the color buffers.
    /// </summary>
    /// <param name="red">Specifies the red value used when the color buffers are cleared. The initial value is 0.</param>
    /// <param name="green">Specifies the green value used when the color buffers are cleared. The initial value is 0.</param>
    /// <param name="blue">Specifies the blue value used when the color buffers are cleared. The initial value is 0.</param>
    /// <param name="alpha">Specifies the alpha value used when the color buffers are cleared. The initial value is 0.</param>
    public void glClearColor( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha )
    {
        _glClearColor( red, green, blue, alpha );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCLEARSTENCILPROC( GLint s );

    private PFNGLCLEARSTENCILPROC _glClearStencil;

    /// <summary>
    /// Specify the clear value for the stencil buffer.
    /// </summary>
    /// <param name="s">Specifies the index used when the stencil buffer is cleared. The initial value is 0.</param>
    public void glClearStencil( GLint s )
    {
        _glClearStencil( s );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCLEARDEPTHPROC( GLdouble depth );

    private PFNGLCLEARDEPTHPROC _glClearDepth;

    /// <summary>
    /// Specify the clear value for the depth buffer.
    /// </summary>
    /// <param name="depth">Specifies the depth value used when the depth buffer is cleared. The initial value is 1.</param>
    public void glClearDepth( GLdouble depth )
    {
        _glClearDepth( depth );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSTENCILMASKPROC( GLuint mask );

    private PFNGLSTENCILMASKPROC _glStencilMask;

    /// <summary>
    /// Control the front and back writing of individual bits in the stencil planes.
    /// </summary>
    /// <param name="mask">
    /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes.
    /// Initially, the mask is all 1's.
    /// </param>
    public void glStencilMask( GLuint mask )
    {
        _glStencilMask( mask );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOLORMASKPROC( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha );

    private PFNGLCOLORMASKPROC _glColorMask;

    /// <summary>
    /// Enable and disable writing of frame buffer color components.
    /// </summary>
    /// <param name="red">Specifies whether red can or cannot be written into the frame buffer.</param>
    /// <param name="green">Specifies whether green can or cannot be written into the frame buffer.</param>
    /// <param name="blue">Specifies whether blue can or cannot be written into the frame buffer.</param>
    /// <param name="alpha">Specifies whether alpha can or cannot be written into the frame buffer.</param>
    public void glColorMask( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha )
    {
        _glColorMask( red, green, blue, alpha );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDEPTHMASKPROC( GLboolean flag );

    private PFNGLDEPTHMASKPROC _glDepthMask;

    /// <summary>
    /// Enable or disable writing into the depth buffer.
    /// </summary>
    /// <param name="flag">
    /// Specifies whether depth buffer writing is enabled or disabled. If flag is <see langword="false"/>,
    /// depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
    /// </param>
    public void glDepthMask( GLboolean flag )
    {
        _glDepthMask( flag );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDISABLEPROC( GLenum cap );

    private PFNGLDISABLEPROC _glDisable;

    /// <summary>
    /// Disable GL capabilities.
    /// </summary>
    /// <param name="cap">
    /// Specifies a symbolic constant indicating a GL capability to be disabled. Refer to
    /// <see href="https://docs.gl/gl4/glEnable"/> for a list of possible values.
    /// </param>
    public void glDisable( GLenum cap )
    {
        _glDisable( cap );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLENABLEPROC( GLenum cap );

    private PFNGLENABLEPROC _glEnable;

    /// <summary>
    /// Enable GL capabilities.
    /// </summary>
    /// <param name="cap">
    /// Specifies a symbolic constant indicating a GL capability to be enabled. Refer to
    /// <see href="https://docs.gl/gl4/glEnable"/> for a list of possible values.
    /// </param>
    public void glEnable( GLenum cap )
    {
        _glEnable( cap );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLFINISHPROC();

    private PFNGLFINISHPROC _glFinish;

    /// <summary>
    /// Block until all GL execution is complete.
    /// </summary>
    public void glFinish()
    {
        _glFinish();
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLFLUSHPROC();

    private PFNGLFLUSHPROC _glFlush;

    /// <summary>
    /// Force execution of GL commands in finite time.
    /// </summary>
    public void glFlush()
    {
        _glFlush();
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBLENDFUNCPROC( GLenum sfactor, GLenum dfactor );

    private PFNGLBLENDFUNCPROC _glBlendFunc;

    /// <summary>
    /// Specify pixel arithmetic.
    /// </summary>
    /// <param name="sfactor">
    /// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial
    /// value is <see cref="IGL.GL_ONE"/>. Allowed values are <see cref="IGL.GL_ZERO"/>, <see cref="IGL.GL_ONE"/>,
    /// <see cref="IGL.GL_SRC_COLOR"/>, <see cref="IGL.GL_ONE_MINUS_SRC_COLOR"/>, <see cref="IGL.GL_DST_COLOR"/>,
    /// <see cref="IGL.GL_ONE_MINUS_DST_COLOR"/>, <see cref="IGL.GL_SRC_ALPHA"/>, <see cref="IGL.GL_ONE_MINUS_SRC_ALPHA"/>,
    /// <see cref="IGL.GL_DST_ALPHA"/>, <see cref="IGL.GL_ONE_MINUS_DST_ALPHA"/>, <see cref="IGL.GL_CONSTANT_COLOR"/>,
    /// <see cref="IGL.GL_ONE_MINUS_CONSTANT_COLOR"/>, <see cref="IGL.GL_CONSTANT_ALPHA"/>, and
    /// <see cref="IGL.GL_ONE_MINUS_CONSTANT_ALPHA"/>
    /// </param>
    /// <param name="dfactor">
    /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The
    /// initial value is <see cref="IGL.GL_ZERO"/>. Allowed values are <see cref="IGL.GL_ZERO"/>, <see cref="IGL.GL_ONE"/>,
    /// <see cref="IGL.GL_SRC_COLOR"/>, <see cref="IGL.GL_ONE_MINUS_SRC_COLOR"/>, <see cref="IGL.GL_DST_COLOR"/>,
    /// <see cref="IGL.GL_ONE_MINUS_DST_COLOR"/>, <see cref="IGL.GL_SRC_ALPHA"/>, <see cref="IGL.GL_ONE_MINUS_SRC_ALPHA"/>,
    /// <see cref="IGL.GL_DST_ALPHA"/>, <see cref="IGL.GL_ONE_MINUS_DST_ALPHA"/>, <see cref="IGL.GL_CONSTANT_COLOR"/>,
    /// <see cref="IGL.GL_ONE_MINUS_CONSTANT_COLOR"/>, <see cref="IGL.GL_CONSTANT_ALPHA"/>, and
    /// <see cref="IGL.GL_ONE_MINUS_CONSTANT_ALPHA"/>.
    /// </param>
    public void glBlendFunc( GLenum sfactor, GLenum dfactor )
    {
        _glBlendFunc( sfactor, dfactor );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLLOGICOPPROC( GLenum opcode );

    private PFNGLLOGICOPPROC _glLogicOp;

    /// <summary>
    /// Specify a logical pixel operation for rendering.
    /// </summary>
    /// <param name="opcode">
    /// Specifies a symbolic constant that selects a logical operation. The following symbols are
    /// accepted: <see cref="IGL.GL_CLEAR"/>, <see cref="IGL.GL_SET"/>, <see cref="IGL.GL_COPY"/>, <see cref="IGL.GL_COPY_INVERTED"/>,
    /// <see cref="IGL.GL_NOOP"/>, <see cref="IGL.GL_INVERT"/>, <see cref="IGL.GL_AND"/>, <see cref="IGL.GL_NAND"/>,
    /// <see cref="IGL.GL_OR"/>, <see cref="IGL.GL_NOR"/>, <see cref="IGL.GL_XOR"/>, <see cref="IGL.GL_EQUIV"/>,
    /// <see cref="IGL.GL_AND_REVERSE"/>, <see cref="IGL.GL_AND_INVERTED"/>, <see cref="IGL.GL_OR_REVERSE"/>, and
    /// <see cref="IGL.GL_OR_INVERTED"/>. The initial value is <see cref="IGL.GL_COPY"/>.
    /// </param>
    public void glLogicOp( GLenum opcode )
    {
        _glLogicOp( opcode );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSTENCILFUNCPROC( GLenum func, GLint @ref, GLuint mask );

    private PFNGLSTENCILFUNCPROC _glStencilFunc;

    /// <summary>
    /// Set front and back function and reference value for stencil testing.
    /// </summary>
    /// <param name="func">
    /// Specifies the test function. Eight symbolic constants are accepted: <see cref="IGL.GL_NEVER"/>,
    /// <see cref="IGL.GL_LESS"/>, <see cref="IGL.GL_LEQUAL"/>, <see cref="IGL.GL_GREATER"/>, <see cref="IGL.GL_GEQUAL"/>,
    /// <see cref="IGL.GL_EQUAL"/>, <see cref="IGL.GL_NOTEQUAL"/>, and <see cref="IGL.GL_ALWAYS"/>. The initial value is
    /// <see cref="IGL.GL_ALWAYS"/>.
    /// </param>
    /// <param name="ref">
    /// Specifies the reference value for the stencil test. <paramref name="ref"/> is clamped to the range
    /// [0,(2^n) - 1], where n is the number of bitplanes in the stencil buffer. The initial value is 0.
    /// </param>
    /// <param name="mask">
    /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the
    /// test is done. The initial value is all 1's.
    /// </param>
    public void glStencilFunc( GLenum func, GLint @ref, GLuint mask )
    {
        _glStencilFunc( func, @ref, mask );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSTENCILOPPROC( GLenum fail, GLenum zfail, GLenum zpass );

    private PFNGLSTENCILOPPROC _glStencilOp;

    /// <summary>
    /// Set front and back stencil test actions.
    /// </summary>
    /// <param name="fail">
    /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted:
    /// <see cref="IGL.GL_KEEP"/>, <see cref="IGL.GL_ZERO"/>, <see cref="IGL.GL_REPLACE"/>, <see cref="IGL.GL_INCR"/>,
    /// <see cref="IGL.GL_INCR_WRAP"/>, <see cref="IGL.GL_DECR"/>, <see cref="IGL.GL_DECR_WRAP"/>, and <see cref="IGL.GL_INVERT"/>. The
    /// initial value is <see cref="IGL.GL_KEEP"/>.
    /// </param>
    /// <param name="zfail">
    /// Specifies the stencil action when the stencil test passes, but the depth test fails.
    /// <paramref name="zfail"/> accepts the same symbolic constants as <paramref name="fail"/>. The initial value is
    /// <see cref="IGL.GL_KEEP"/>.
    /// </param>
    /// <param name="zpass">
    /// Specifies the stencil action when both the stencil test and the depth test pass, or when the
    /// stencil test passes and either there is no depth buffer or depth testing is not enabled. <paramref name="zpass"/>
    /// accepts the same symbolic constants as <paramref name="fail"/>. The initial value is <see cref="IGL.GL_KEEP"/>.
    /// </param>
    public void glStencilOp( GLenum fail, GLenum zfail, GLenum zpass )
    {
        _glStencilOp( fail, zfail, zpass );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDEPTHFUNCPROC( GLenum func );

    private PFNGLDEPTHFUNCPROC _glDepthFunc;

    /// <summary>
    /// Specify the value used for depth buffer comparisons.
    /// </summary>
    /// <param name="func">
    /// Specifies the depth comparison function. Symbolic constants <see cref="IGL.GL_NEVER"/>,
    /// <see cref="IGL.GL_LESS"/>, <see cref="IGL.GL_EQUAL"/>, <see cref="IGL.GL_LEQUAL"/>, <see cref="IGL.GL_GREATER"/>,
    /// <see cref="IGL.GL_NOTEQUAL"/>, <see cref="IGL.GL_GEQUAL"/>, and <see cref="IGL.GL_ALWAYS"/> are accepted. The initial value
    /// is <see cref="IGL.GL_LESS"/>.
    /// </param>
    public void glDepthFunc( GLenum func )
    {
        _glDepthFunc( func );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPIXELSTOREFPROC( GLenum pname, GLfloat param );

    private PFNGLPIXELSTOREFPROC _glPixelStoref;

    /// <summary>
    /// Set pixel storage modes.
    /// </summary>
    /// <param name="pname">
    /// Specifies the symbolic name of the parameter to be set. The following values affect the packing of
    /// pixel data into memory: <see cref="IGL.GL_PACK_SWAP_BYTES"/>, <see cref="IGL.GL_PACK_LSB_FIRST"/>,
    /// <see cref="IGL.GL_PACK_ROW_LENGTH"/>, <see cref="IGL.GL_PACK_IMAGE_HEIGHT"/>, <see cref="IGL.GL_PACK_SKIP_PIXELS"/>,
    /// <see cref="IGL.GL_PACK_SKIP_ROWS"/>, <see cref="IGL.GL_PACK_SKIP_IMAGES"/>, and <see cref="IGL.GL_PACK_ALIGNMENT"/>. The
    /// following values affect the unpacking of pixel data from memory: <see cref="IGL.GL_UNPACK_SWAP_BYTES"/>,
    /// <see cref="IGL.GL_UNPACK_LSB_FIRST"/>, <see cref="IGL.GL_UNPACK_ROW_LENGTH"/>, <see cref="IGL.GL_UNPACK_IMAGE_HEIGHT"/>,
    /// <see cref="IGL.GL_UNPACK_SKIP_PIXELS"/>, <see cref="IGL.GL_UNPACK_SKIP_ROWS"/>, <see cref="IGL.GL_UNPACK_SKIP_IMAGES"/>, and
    /// <see cref="IGL.GL_UNPACK_ALIGNMENT"/>.
    /// </param>
    /// <param name="param">Specifies the value that <paramref name="pname"/> is set to.</param>
    public void glPixelStoref( GLenum pname, GLfloat param )
    {
        _glPixelStoref( pname, param );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPIXELSTOREIPROC( GLenum pname, GLint param );

    private PFNGLPIXELSTOREIPROC _glPixelStorei;

    /// <summary>
    /// Set pixel storage modes.
    /// </summary>
    /// <param name="pname">
    /// Specifies the symbolic name of the parameter to be set. The following values affect the packing of
    /// pixel data into memory: <see cref="IGL.GL_PACK_SWAP_BYTES"/>, <see cref="IGL.GL_PACK_LSB_FIRST"/>,
    /// <see cref="IGL.GL_PACK_ROW_LENGTH"/>, <see cref="IGL.GL_PACK_IMAGE_HEIGHT"/>, <see cref="IGL.GL_PACK_SKIP_PIXELS"/>,
    /// <see cref="IGL.GL_PACK_SKIP_ROWS"/>, <see cref="IGL.GL_PACK_SKIP_IMAGES"/>, and <see cref="IGL.GL_PACK_ALIGNMENT"/>. The
    /// following values affect the unpacking of pixel data from memory: <see cref="IGL.GL_UNPACK_SWAP_BYTES"/>,
    /// <see cref="IGL.GL_UNPACK_LSB_FIRST"/>, <see cref="IGL.GL_UNPACK_ROW_LENGTH"/>, <see cref="IGL.GL_UNPACK_IMAGE_HEIGHT"/>,
    /// <see cref="IGL.GL_UNPACK_SKIP_PIXELS"/>, <see cref="IGL.GL_UNPACK_SKIP_ROWS"/>, <see cref="IGL.GL_UNPACK_SKIP_IMAGES"/>, and
    /// <see cref="IGL.GL_UNPACK_ALIGNMENT"/>.
    /// </param>
    /// <param name="param">Specifies the value that <paramref name="pname"/> is set to.</param>
    public void glPixelStorei( GLenum pname, GLint param )
    {
        _glPixelStorei( pname, param );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLREADBUFFERPROC( GLenum src );

    private PFNGLREADBUFFERPROC _glReadBuffer;

    /// <summary>
    /// Select a color buffer source for pixels.
    /// </summary>
    /// <param name="src">
    /// Specifies a color buffer. Accepted values are <see cref="IGL.GL_FRONT_LEFT"/>,
    /// <see cref="IGL.GL_FRONT_RIGHT"/>, <see cref="IGL.GL_BACK_LEFT"/>, <see cref="IGL.GL_BACK_RIGHT"/>, <see cref="IGL.GL_FRONT"/>,
    /// <see cref="IGL.GL_BACK"/>, <see cref="IGL.GL_LEFT"/>, <see cref="IGL.GL_RIGHT"/>, and the constants
    /// <see cref="IGL.GL_COLOR_ATTACHMENT0"/> through <see cref="IGL.GL_COLOR_ATTACHMENT31"/>.
    /// </param>
    public void glReadBuffer( GLenum src )
    {
        _glReadBuffer( src );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLREADPIXELSPROC( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels );

    private PFNGLREADPIXELSPROC _glReadPixels;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Read a block of pixels from the frame buffer.
    /// </summary>
    /// <param name="x">
    /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is
    /// the lower left corner of a rectangular block of pixels.
    /// </param>
    /// <param name="y">
    /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is
    /// the lower left corner of a rectangular block of pixels.
    /// </param>
    /// <param name="width">
    /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single
    /// pixel.
    /// </param>
    /// <param name="height">
    /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single
    /// pixel.
    /// </param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_STENCIL_INDEX"/>, <see cref="IGL.GL_DEPTH_COMPONENT"/>, <see cref="IGL.GL_DEPTH_STENCIL"/>,
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_GREEN"/>, <see cref="IGL.GL_BLUE"/>, <see cref="IGL.GL_RGB"/>,
    /// <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>, and <see cref="IGL.GL_BGRA"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_24_8"/>, <see cref="IGL.GL_UNSIGNED_INT_10F_11F_11F_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_5_9_9_9_REV"/>, and <see cref="IGL.GL_FLOAT_32_UNSIGNED_INT_24_8_REV"/>.
    /// </param>
    /// <param name="pixels">A pointer to somewhere in memory where the pixel data will be returned.</param>
    public void glReadPixels( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels )
    {
        _glReadPixels( x, y, width, height, format, type, pixels );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Read a block of pixels from the frame buffer.
    /// </summary>
    /// <param name="x">
    /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is
    /// the lower left corner of a rectangular block of pixels.
    /// </param>
    /// <param name="y">
    /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is
    /// the lower left corner of a rectangular block of pixels.
    /// </param>
    /// <param name="width">
    /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single
    /// pixel.
    /// </param>
    /// <param name="height">
    /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single
    /// pixel.
    /// </param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_STENCIL_INDEX"/>, <see cref="IGL.GL_DEPTH_COMPONENT"/>, <see cref="IGL.GL_DEPTH_STENCIL"/>,
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_GREEN"/>, <see cref="IGL.GL_BLUE"/>, <see cref="IGL.GL_RGB"/>,
    /// <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>, and <see cref="IGL.GL_BGRA"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_24_8"/>, <see cref="IGL.GL_UNSIGNED_INT_10F_11F_11F_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_5_9_9_9_REV"/>, and <see cref="IGL.GL_FLOAT_32_UNSIGNED_INT_24_8_REV"/>.
    /// </param>
    /// <param name="pixels">
    /// A <see langword="ref"/> to an array of <typeparamref name="T"/>s where the pixel data will be
    /// returned. Make sure to match the type of the data with the type in <paramref name="type"/>.
    /// </param>
    public void glReadPixels< T >( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, ref T[] pixels ) where T : unmanaged
    {
        fixed ( void* p
                   = &pixels[ 0 ] )
        {
            _glReadPixels( x, y, width, height, format, type, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETBOOLEANVPROC( GLenum pname, GLboolean* data );

    private PFNGLGETBOOLEANVPROC _glGetBooleanv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the boolean value or values of a selected parameter.
    /// </summary>
    /// <param name="pname">
    /// Specifies the parameter value to be returned. Refer to <see href="https://docs.gl/gl4/glGet"/> for
    /// a list of possible values.
    /// </param>
    /// <param name="data">A pointer to where the boolean value or values will be returned.</param>
    public void glGetBooleanv( GLenum pname, GLboolean* data )
    {
        _glGetBooleanv( pname, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the boolean value or values of a selected parameter.
    /// </summary>
    /// <param name="pname">
    /// Specifies the parameter value to be returned. Refer to <see href="https://docs.gl/gl4/glGet"/> for
    /// a list of possible values.
    /// </param>
    /// <param name="data">
    /// A <see langword="ref"/> to an array of <see langword="bool"/>s where the boolean value or values
    /// will be returned.
    /// </param>
    public void glGetBooleanv( GLenum pname, ref GLboolean[] data )
    {
        fixed ( GLboolean* p = &data[ 0 ] )
        {
            _glGetBooleanv( pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETDOUBLEVPROC( GLenum pname, GLdouble* data );

    private PFNGLGETDOUBLEVPROC _glGetDoublev;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the double value or values of a selected parameter.
    /// </summary>
    /// <param name="pname">
    /// Specifies the parameter value to be returned. Refer to <see href="https://docs.gl/gl4/glGet"/> for
    /// a list of possible values.
    /// </param>
    /// <param name="data">A pointer to where the double value or values will be returned.</param>
    public void glGetDoublev( GLenum pname, GLdouble* data )
    {
        _glGetDoublev( pname, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the double value or values of a selected parameter.
    /// </summary>
    /// <param name="pname">
    /// Specifies the parameter value to be returned. Refer to <see href="https://docs.gl/gl4/glGet"/> for
    /// a list of possible values.
    /// </param>
    /// <param name="data">
    /// A <see langword="ref"/> to an array of <see langword="double"/>s where the double value or values
    /// will be returned.
    /// </param>
    public void glGetDoublev( GLenum pname, ref GLdouble[] data )
    {
        fixed ( GLdouble* p = &data[ 0 ] )
        {
            _glGetDoublev( pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLenum PFNGLGETERRORPROC();

    private PFNGLGETERRORPROC _glGetError;

    /// <summary>
    /// Return error information.
    /// </summary>
    /// <returns>
    /// One of <see cref="IGL.GL_NO_ERROR"/>, <see cref="IGL.GL_INVALID_ENUM"/>, <see cref="IGL.GL_INVALID_VALUE"/>,
    /// <see cref="IGL.GL_INVALID_OPERATION"/>, <see cref="IGL.GL_INVALID_FRAMEBUFFER_OPERATION"/>,
    /// <see cref="IGL.GL_OUT_OF_MEMORY"/>, <see cref="IGL.GL_STACK_UNDERFLOW"/>, or <see cref="IGL.GL_STACK_OVERFLOW"/>.
    /// </returns>
    public GLenum glGetError()
    {
        return _glGetError();
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETFLOATVPROC( GLenum pname, GLfloat* data );

    private PFNGLGETFLOATVPROC _glGetFloatv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the float value or values of a selected parameter.
    /// </summary>
    /// <param name="pname">
    /// Specifies the parameter value to be returned. Refer to <see href="https://docs.gl/gl4/glGet"/> for
    /// a list of possible values.
    /// </param>
    /// <param name="data">A pointer to where the float value or values will be returned.</param>
    public void glGetFloatv( GLenum pname, float* data )
    {
        _glGetFloatv( pname, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the float value or values of a selected parameter.
    /// </summary>
    /// <param name="pname">
    /// Specifies the parameter value to be returned. Refer to <see href="https://docs.gl/gl4/glGet"/> for
    /// a list of possible values.
    /// </param>
    public void glGetFloatv( GLenum pname, ref GLfloat[] data )
    {
        fixed ( GLfloat* p = &data[ 0 ] )
        {
            _glGetFloatv( pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETINTEGERVPROC( GLenum pname, GLint* data );

    private PFNGLGETINTEGERVPROC _glGetIntegerv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the integer value or values of a selected parameter.
    /// </summary>
    /// <param name="pname">
    /// Specifies the parameter value to be returned. Refer to <see href="https://docs.gl/gl4/glGet"/> for
    /// a list of possible values.
    /// </param>
    /// <param name="data">A pointer to where the integer value or values will be returned.</param>
    public void glGetIntegerv( GLenum pname, GLint* data )
    {
        _glGetIntegerv( pname, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the integer value or values of a selected parameter.
    /// </summary>
    /// <param name="pname">
    /// Specifies the parameter value to be returned. Refer to <see href="https://docs.gl/gl4/glGet"/> for
    /// a list of possible values.
    /// </param>
    /// <param name="data">
    /// A <see langword="ref"/> to an array of <see langword="int"/>s where the integer value or values
    /// will be returned.
    /// </param>
    public void glGetIntegerv( GLenum pname, ref GLint[] data )
    {
        fixed ( GLint* p = &data[ 0 ] )
        {
            _glGetIntegerv( pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLubyte* PFNGLGETSTRINGPROC( GLenum name );

    private PFNGLGETSTRINGPROC _glGetString;
#if OGL_WRAPPER_API_UNSAFE || OGL_WRAPPER_API_BOTH
    /// <summary>
    /// Return a string describing the current GL connection.
    /// </summary>
    /// <param name="name">
    /// Specifies a symbolic constant, one of <see cref="IGL.GL_VENDOR"/>, <see cref="IGL.GL_RENDERER"/>,
    /// <see cref="IGL.GL_VERSION"/>, or <see cref="IGL.GL_SHADING_LANGUAGE_VERSION"/>. Additionally, <see cref="glGetStringi"/>
    /// accepts <see cref="IGL.GL_EXTENSIONS"/>.
    /// </param>
    /// <returns>The requested string as a <see cref="GLubyte"/> pointer.</returns>
    public GLubyte* glGetString( GLenum name )
    {
        return _glGetString( name );
    }
#endif
#if OGL_WRAPPER_API_SAFE || OGL_WRAPPER_API_BOTH
    /// <summary>
    /// Return a string describing the current GL connection.
    /// </summary>
    /// <param name="name">
    /// Specifies a symbolic constant, one of <see cref="IGL.GL_VENDOR"/>, <see cref="IGL.GL_RENDERER"/>,
    /// <see cref="IGL.GL_VERSION"/>, or <see cref="IGL.GL_SHADING_LANGUAGE_VERSION"/>. Additionally, <see cref="glGetStringi"/>
    /// accepts <see cref="IGL.GL_EXTENSIONS"/>.
    /// </param>
    /// <returns>The requested string as a managed string.</returns>
    public string glGetStringSafe( GLenum name )
    {
        var p = _glGetString( name );

        if ( p == null )
        {
            return null;
        }

        var i = 0;

        while ( p[ i ] != 0 )
        {
            i++;
        }

        return new string( ( sbyte* )p, 0, i, Encoding.UTF8 );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETTEXIMAGEPROC( GLenum target, GLint level, GLenum format, GLenum type, void* pixels );

    private PFNGLGETTEXIMAGEPROC _glGetTexImage;
#if OGL_WRAPPER_API_UNSAFE || OGL_WRAPPER_API_BOTH
    /// <summary>
    /// Return a texture image.
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture is bound for. <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_RECTANGLE"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/> and
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP"/> are accepted.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n
    /// is the nth mipmap reduction image.
    /// </param>
    /// <param name="format">
    /// Specifies a pixel format for the returned data. The supported formats are
    /// <see cref="IGL.GL_STENCIL"/>, <see cref="IGL.GL_DEPTH_COMPONENT"/>, <see cref="IGL.GL_DEPTH_STENCIL"/>,
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_GREEN"/>, <see cref="IGL.GL_BLUE"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>
    /// , <see cref="IGL.GL_RGBA"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_BGRA"/>, <see cref="IGL.GL_RED_INTEGER"/>,
    /// <see cref="IGL.GL_GREEN_INTEGER"/>, <see cref="IGL.GL_BLUE_INTEGER"/>, <see cref="IGL.GL_RG_INTEGER"/>,
    /// <see cref="IGL.GL_RGB_INTEGER"/>, <see cref="IGL.GL_RGBA_INTEGER"/>, <see cref="IGL.GL_BGR_INTEGER"/> and
    /// <see cref="IGL.GL_BGRA_INTEGER"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_24_8"/>, <see cref="IGL.GL_UNSIGNED_INT_10F_11F_11F_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_5_9_9_9_REV"/>, and <see cref="IGL.GL_FLOAT_32_UNSIGNED_INT_24_8_REV"/>.
    /// </param>
    /// <param name="pixels">A pointer to a memory location where the pixel data will be returned.</param>
    public void glGetTexImage( GLenum target, GLint level, GLenum format, GLenum type, void* pixels )
    {
        _glGetTexImage( target, level, format, type, pixels );
    }
#endif
#if OGL_WRAPPER_API_SAFE || OGL_WRAPPER_API_BOTH
    /// <summary>
    /// Return a texture image.
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture is bound for. <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_RECTANGLE"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/> and
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP"/> are accepted.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n
    /// is the nth mipmap reduction image.
    /// </param>
    /// <param name="format">
    /// Specifies a pixel format for the returned data. The supported formats are
    /// <see cref="IGL.GL_STENCIL"/>, <see cref="IGL.GL_DEPTH_COMPONENT"/>, <see cref="IGL.GL_DEPTH_STENCIL"/>,
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_GREEN"/>, <see cref="IGL.GL_BLUE"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>
    /// , <see cref="IGL.GL_RGBA"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_BGRA"/>, <see cref="IGL.GL_RED_INTEGER"/>,
    /// <see cref="IGL.GL_GREEN_INTEGER"/>, <see cref="IGL.GL_BLUE_INTEGER"/>, <see cref="IGL.GL_RG_INTEGER"/>,
    /// <see cref="IGL.GL_RGB_INTEGER"/>, <see cref="IGL.GL_RGBA_INTEGER"/>, <see cref="IGL.GL_BGR_INTEGER"/> and
    /// <see cref="IGL.GL_BGRA_INTEGER"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_24_8"/>, <see cref="IGL.GL_UNSIGNED_INT_10F_11F_11F_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_5_9_9_9_REV"/>, and <see cref="IGL.GL_FLOAT_32_UNSIGNED_INT_24_8_REV"/>.
    /// </param>
    /// <param name="pixels">
    /// A <see langword="ref"/> to an array of <typeparamref name="T"/>s where the pixel data will be
    /// returned.
    /// </param>
    public void glGetTexImage< T >( GLenum target, GLint level, GLenum format, GLenum type, ref T[] pixels ) where T : unmanaged
    {
        fixed ( void* p =
                   &pixels[ 0 ] )
        {
            _glGetTexImage( target, level, format, type, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETTEXPARAMETERFVPROC( GLenum target, GLenum pname, GLfloat* @params );

    private PFNGLGETTEXPARAMETERFVPROC _glGetTexParameterfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture parameter (float) values.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> and <see cref="IGL.GL_TEXTURE_RECTANGLE"/> are accepted.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a texture parameter. <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>,
    /// <see cref="IGL.GL_IMAGE_FORMAT_COMPATIBILITY_TYPE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_IMMUTABLE_FORMAT"/>,
    /// <see cref="IGL.GL_TEXTURE_IMMUTABLE_LEVELS"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_RGBA"/>, <see cref="IGL.GL_TEXTURE_TARGET"/>, <see cref="IGL.GL_TEXTURE_VIEW_MIN_LAYER"/>,
    /// <see cref="IGL.GL_TEXTURE_VIEW_MIN_LEVEL"/>, <see cref="IGL.GL_TEXTURE_VIEW_NUM_LAYERS"/>,
    /// <see cref="IGL.GL_TEXTURE_VIEW_NUM_LEVELS"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>, <see cref="IGL.GL_TEXTURE_WRAP_S"/>, and
    /// <see cref="IGL.GL_TEXTURE_WRAP_T"/> are accepted.
    /// </param>
    /// <param name="params">A pointer to a float array where the values will be returned.</param>
    public void glGetTexParameterfv( GLenum target, GLenum pname, GLfloat* @params )
    {
        _glGetTexParameterfv( target, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture parameter (float) values.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> and <see cref="IGL.GL_TEXTURE_RECTANGLE"/> are accepted.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a texture parameter. <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>,
    /// <see cref="IGL.GL_IMAGE_FORMAT_COMPATIBILITY_TYPE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_IMMUTABLE_FORMAT"/>,
    /// <see cref="IGL.GL_TEXTURE_IMMUTABLE_LEVELS"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_RGBA"/>, <see cref="IGL.GL_TEXTURE_TARGET"/>, <see cref="IGL.GL_TEXTURE_VIEW_MIN_LAYER"/>,
    /// <see cref="IGL.GL_TEXTURE_VIEW_MIN_LEVEL"/>, <see cref="IGL.GL_TEXTURE_VIEW_NUM_LAYERS"/>,
    /// <see cref="IGL.GL_TEXTURE_VIEW_NUM_LEVELS"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>, <see cref="IGL.GL_TEXTURE_WRAP_S"/>, and
    /// <see cref="IGL.GL_TEXTURE_WRAP_T"/> are accepted.
    /// </param>
    /// <param name="params">A <see langword="ref"/> to a float array where the values will be returned.</param>
    public void glGetTexParameterfv( GLenum target, GLenum pname, ref GLfloat[] @params )
    {
        fixed ( GLfloat* p =
                   &@params[ 0 ] )
        {
            _glGetTexParameterfv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETTEXPARAMETERIVPROC( GLenum target, GLenum pname, GLint* @params );

    private PFNGLGETTEXPARAMETERIVPROC _glGetTexParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture parameter (integer) values.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> and <see cref="IGL.GL_TEXTURE_RECTANGLE"/> are accepted.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a texture parameter. <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>,
    /// <see cref="IGL.GL_IMAGE_FORMAT_COMPATIBILITY_TYPE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_IMMUTABLE_FORMAT"/>,
    /// <see cref="IGL.GL_TEXTURE_IMMUTABLE_LEVELS"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_RGBA"/>, <see cref="IGL.GL_TEXTURE_TARGET"/>, <see cref="IGL.GL_TEXTURE_VIEW_MIN_LAYER"/>,
    /// <see cref="IGL.GL_TEXTURE_VIEW_MIN_LEVEL"/>, <see cref="IGL.GL_TEXTURE_VIEW_NUM_LAYERS"/>,
    /// <see cref="IGL.GL_TEXTURE_VIEW_NUM_LEVELS"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>, <see cref="IGL.GL_TEXTURE_WRAP_S"/>, and
    /// <see cref="IGL.GL_TEXTURE_WRAP_T"/> are accepted.
    /// </param>
    /// <param name="params">A pointer to an integer array where the values will be returned.</param>
    public void glGetTexParameteriv( GLenum target, GLenum pname, GLint* @params )
    {
        _glGetTexParameteriv( target, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture parameter (integer) values.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> and <see cref="IGL.GL_TEXTURE_RECTANGLE"/> are accepted.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a texture parameter. <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>,
    /// <see cref="IGL.GL_IMAGE_FORMAT_COMPATIBILITY_TYPE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_IMMUTABLE_FORMAT"/>,
    /// <see cref="IGL.GL_TEXTURE_IMMUTABLE_LEVELS"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_RGBA"/>, <see cref="IGL.GL_TEXTURE_TARGET"/>, <see cref="IGL.GL_TEXTURE_VIEW_MIN_LAYER"/>,
    /// <see cref="IGL.GL_TEXTURE_VIEW_MIN_LEVEL"/>, <see cref="IGL.GL_TEXTURE_VIEW_NUM_LAYERS"/>,
    /// <see cref="IGL.GL_TEXTURE_VIEW_NUM_LEVELS"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>, <see cref="IGL.GL_TEXTURE_WRAP_S"/>, and
    /// <see cref="IGL.GL_TEXTURE_WRAP_T"/> are accepted.
    /// </param>
    /// <param name="params">A <see langword="ref"/> to an integer array where the values will be returned.</param>
    public void glGetTexParameteriv( GLenum target, GLenum pname, ref GLint[] @params )
    {
        fixed ( GLint* p =
                   &@params[ 0 ] )
        {
            _glGetTexParameteriv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETTEXLEVELPARAMETERFVPROC( GLenum target, GLint level, GLenum pname, GLfloat* @params );

    private PFNGLGETTEXLEVELPARAMETERFVPROC _glGetTexLevelParameterfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture parameter (float) values for a specific level of detail.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D"/>, <see cref="IGL.GL_PROXY_TEXTURE_3D"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_PROXY_TEXTURE_RECTANGLE"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP"/> or <see cref="IGL.GL_TEXTURE_BUFFER"/> are accepted.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="params">A pointer to a float array in which to place the returned parameter value(s).</param>
    public void glGetTexLevelParameterfv( GLenum target, GLint level, GLenum pname, GLfloat* @params )
    {
        _glGetTexLevelParameterfv( target, level, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture parameter (float) values for a specific level of detail.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D"/>, <see cref="IGL.GL_PROXY_TEXTURE_3D"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_PROXY_TEXTURE_RECTANGLE"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP"/> or <see cref="IGL.GL_TEXTURE_BUFFER"/> are accepted.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="params">A <see langword="ref"/> to a float array where the values will be returned.</param>
    public void glGetTexLevelParameterfv( GLenum target, GLint level, GLenum pname, ref GLfloat[] @params )
    {
        fixed ( GLfloat* p =
                   &@params[ 0 ] )
        {
            _glGetTexLevelParameterfv( target, level, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETTEXLEVELPARAMETERIVPROC( GLenum target, GLint level, GLenum pname, GLint* @params );

    private PFNGLGETTEXLEVELPARAMETERIVPROC _glGetTexLevelParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture parameter (integer) values for a specific level of detail.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D"/>, <see cref="IGL.GL_PROXY_TEXTURE_3D"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_PROXY_TEXTURE_RECTANGLE"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP"/> or <see cref="IGL.GL_TEXTURE_BUFFER"/> are accepted.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="params">A pointer to an integer array in which to place the returned parameter value(s).</param>
    public void glGetTexLevelParameteriv( GLenum target, GLint level, GLenum pname, GLint* @params )
    {
        _glGetTexLevelParameteriv( target, level, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture parameter (integer) values for a specific level of detail.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D"/>, <see cref="IGL.GL_PROXY_TEXTURE_3D"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_PROXY_TEXTURE_RECTANGLE"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP"/> or <see cref="IGL.GL_TEXTURE_BUFFER"/> are accepted.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="params">A <see langword="ref"/> to an integer array where the values will be returned.</param>
    public void glGetTexLevelParameteriv( GLenum target, GLint level, GLenum pname, ref GLint[] @params )
    {
        fixed ( GLint* p =
                   &@params[ 0 ] )
        {
            _glGetTexLevelParameteriv( target, level, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISENABLEDPROC( GLenum cap );

    private PFNGLISENABLEDPROC _glIsEnabled;

    /// <summary>
    /// Test whether a capability is enabled.
    /// </summary>
    /// <param name="cap">
    /// Specifies a symbolic constant indicating a GL capability. Refer to
    /// <see href="https://docs.gl/gl4/glIsEnabled"/> for a list of possible capabilities.
    /// </param>
    public GLboolean glIsEnabled( GLenum cap )
    {
        return _glIsEnabled( cap );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDEPTHRANGEPROC( GLdouble near, GLdouble far );

    private PFNGLDEPTHRANGEPROC _glDepthRange;

    /// <summary>
    /// Specify mapping of depth values from normalized device coordinates to window coordinates.
    /// </summary>
    /// <param name="near">Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.</param>
    /// <param name="far">Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.</param>
    public void glDepthRange( GLdouble near, GLdouble far )
    {
        _glDepthRange( near, far );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVIEWPORTPROC( GLint x, GLint y, GLsizei width, GLsizei height );

    private PFNGLVIEWPORTPROC _glViewport;

    /// <summary>
    /// Set the viewport.
    /// </summary>
    /// <param name="x">Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).</param>
    /// <param name="y">Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).</param>
    /// <param name="width">
    /// Specify the width and height of the viewport. When a GL context is first attached to a window,
    /// width and height are set to the dimensions of that window.
    /// </param>
    /// <param name="height">
    /// Specify the width and height of the viewport. When a GL context is first attached to a window,
    /// width and height are set to the dimensions of that window.
    /// </param>
    public void glViewport( GLint x, GLint y, GLsizei width, GLsizei height )
    {
        _glViewport( x, y, width, height );
    }

#endif

    // OpenGL 1.1

#if OGL_V_1_1 || OGL_V_1_2 || OGL_V_1_3 || OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDRAWARRAYSPROC( GLenum mode, GLint first, GLsizei count );

    private PFNGLDRAWARRAYSPROC _glDrawArrays;

    /// <summary>
    /// Render primitives from array data.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, <see cref="IGL.GL_PATCHES"/> are
    /// accepted.
    /// </param>
    /// <param name="first">Specifies the starting index in the enabled arrays.</param>
    /// <param name="count">Specifies the number of indices to be rendered.</param>
    public void glDrawArrays( GLenum mode, GLint first, GLsizei count )
    {
        _glDrawArrays( mode, first, count );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDRAWELEMENTSPROC( GLenum mode, GLsizei count, GLenum type, void* indices );

    private PFNGLDRAWELEMENTSPROC _glDrawElements;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render primitives from array data.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, <see cref="IGL.GL_PATCHES"/> are
    /// accepted.
    /// </param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">
    /// Specifies the type of the values in indices. Must be one of <see cref="IGL.GL_UNSIGNED_BYTE"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
    public void glDrawElements( GLenum mode, GLsizei count, GLenum type, void* indices )
    {
        _glDrawElements( mode, count, type, indices );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render primitives from array data.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, <see cref="IGL.GL_PATCHES"/> are
    /// accepted.
    /// </param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">
    /// Specifies the type of the values in indices. Must be one of <see cref="IGL.GL_UNSIGNED_BYTE"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">
    /// Specifies an array of indices to be rendererd. Make sure to match the type
    /// <typeparamref name="T"/> with the type specified by <paramref name="type"/>.
    /// </param>
    public void glDrawElements< T >( GLenum mode, GLsizei count, GLenum type, T[] indices ) where T : unmanaged, IUnsignedNumber< T >
    {
        fixed ( T* p =
                   &indices[ 0 ] )
        {
            _glDrawElements( mode, count, type, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPOLYGONOFFSETPROC( GLfloat factor, GLfloat units );

    private PFNGLPOLYGONOFFSETPROC _glPolygonOffset;

    /// <summary>
    /// Set the scale and units used to calculate depth values.
    /// </summary>
    /// <param name="factor">
    /// Specifies a scale factor that is used to create a variable depth offset for each polygon. The
    /// initial value is 0.
    /// </param>
    /// <param name="units">
    /// Is multiplied by an implementation-specific value to create a constant depth offset. The initial
    /// value is 0.
    /// </param>
    public void glPolygonOffset( GLfloat factor, GLfloat units )
    {
        _glPolygonOffset( factor, units );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOPYTEXIMAGE1DPROC( GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border );

    private PFNGLCOPYTEXIMAGE1DPROC _glCopyTexImage1D;

    /// <summary>
    /// Copy pixels into a 1D texture image.
    /// </summary>
    /// <param name="target">Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/>.</param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the internal format of the texture. Refer to
    /// <see href="https://docs.gl/gl4/glCopyTexImage1D"/> for a list of supported formats.
    /// </param>
    /// <param name="x">
    /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
    /// copied.
    /// </param>
    /// <param name="y">
    /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
    /// copied.
    /// </param>
    /// <param name="width">Specifies the width of the texture image.</param>
    /// <param name="border">This value must be 0.</param>
    public void glCopyTexImage1D( GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border )
    {
        _glCopyTexImage1D( target, level, internalformat, x, y, width, border );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOPYTEXIMAGE2DPROC( GLenum target,
                                                   GLint level,
                                                   GLenum internalformat,
                                                   GLint x,
                                                   GLint y,
                                                   GLsizei width,
                                                   GLsizei height,
                                                   GLint border );

    private PFNGLCOPYTEXIMAGE2DPROC _glCopyTexImage2D;

    /// <summary>
    /// Copy pixels into a 2D texture image.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/> or <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the internal format of the texture. Refer to
    /// <see href="https://docs.gl/gl4/glCopyTexImage2D"/> for a list of supported formats.
    /// </param>
    /// <param name="x">
    /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
    /// copied.
    /// </param>
    /// <param name="y">
    /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
    /// copied.
    /// </param>
    /// <param name="width">Specifies the width of the texture image.</param>
    /// <param name="height">Specifies the height of the texture image.</param>
    /// <param name="border">This value must be 0.</param>
    public void glCopyTexImage2D( GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
    {
        _glCopyTexImage2D( target, level, internalformat, x, y, width, height, border );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOPYTEXSUBIMAGE1DPROC( GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width );

    private PFNGLCOPYTEXSUBIMAGE1DPROC _glCopyTexSubImage1D;

    /// <summary>
    /// Copy a one-dimensional texture subimage.
    /// </summary>
    /// <param name="target">Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/>.</param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="x">
    /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
    /// copied.
    /// </param>
    /// <param name="y">
    /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
    /// copied.
    /// </param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    public void glCopyTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width )
    {
        _glCopyTexSubImage1D( target, level, xoffset, x, y, width );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOPYTEXSUBIMAGE2DPROC( GLenum target,
                                                      GLint level,
                                                      GLint xoffset,
                                                      GLint yoffset,
                                                      GLint x,
                                                      GLint y,
                                                      GLsizei width,
                                                      GLsizei height );

    private PFNGLCOPYTEXSUBIMAGE2DPROC _glCopyTexSubImage2D;

    /// <summary>
    /// Copy a two-dimensional texture subimage.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/> or <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="x">
    /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
    /// copied.
    /// </param>
    /// <param name="y">
    /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
    /// copied.
    /// </param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    public void glCopyTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height )
    {
        _glCopyTexSubImage2D( target, level, xoffset, yoffset, x, y, width, height );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXSUBIMAGE1DPROC( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, void* pixels );

    private PFNGLTEXSUBIMAGE1DPROC _glTexSubImage1D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a one-dimensional texture subimage.
    /// </summary>
    /// <param name="target">Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/>.</param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_DEPTH_COMPONENT"/> and <see cref="IGL.GL_STENCIL_INDEX"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/> and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
    public void glTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, void* pixels )
    {
        _glTexSubImage1D( target, level, xoffset, width, format, type, pixels );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a one-dimensional texture subimage.
    /// </summary>
    /// <param name="target">Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/>.</param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_DEPTH_COMPONENT"/> and <see cref="IGL.GL_STENCIL_INDEX"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/> and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">
    /// Specifies an array of <typeparamref name="T"/>s containing the image data. Make sure to match
    /// this with the type specified in <paramref name="type"/>.
    /// </param>
    public void glTexSubImage1D< T >( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, T[] pixels )
        where T : unmanaged
    {
        fixed ( void* p
                   = &pixels[ 0 ] )
        {
            _glTexSubImage1D( target, level, xoffset, width, format, type, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXSUBIMAGE2DPROC( GLenum target,
                                                  GLint level,
                                                  GLint xoffset,
                                                  GLint yoffset,
                                                  GLsizei width,
                                                  GLsizei height,
                                                  GLenum format,
                                                  GLenum type,
                                                  void* pixels );

    private PFNGLTEXSUBIMAGE2DPROC _glTexSubImage2D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a two-dimensional texture subimage.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be one of <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/> or
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_DEPTH_COMPONENT"/> and <see cref="IGL.GL_STENCIL_INDEX"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/> and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
    public void glTexSubImage2D( GLenum target,
                                 GLint level,
                                 GLint xoffset,
                                 GLint yoffset,
                                 GLsizei width,
                                 GLsizei height,
                                 GLenum format,
                                 GLenum type,
                                 void* pixels )
    {
        _glTexSubImage2D( target, level, xoffset, yoffset, width, height, format, type, pixels );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a two-dimensional texture subimage.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be one of <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/> or
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_DEPTH_COMPONENT"/> and <see cref="IGL.GL_STENCIL_INDEX"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/> and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">
    /// Specifies an array of <typeparamref name="T"/>s containing the image data. Make sure to match
    /// this with the type specified in <paramref name="type"/>.
    /// </param>
    public void glTexSubImage2D< T >( GLenum target,
                                      GLint level,
                                      GLint xoffset,
                                      GLint yoffset,
                                      GLsizei width,
                                      GLsizei height,
                                      GLenum format,
                                      GLenum type,
                                      T[] pixels ) where T : unmanaged
    {
        fixed ( void* p
                   = &pixels[ 0 ] )
        {
            _glTexSubImage2D( target, level, xoffset, yoffset, width, height, format, type, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDTEXTUREPROC( GLenum target, GLuint texture );

    private PFNGLBINDTEXTUREPROC _glBindTexture;

    /// <summary>
    /// Bind a named texture to a texturing target.
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture is bound. Must be one of <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_RECTANGLE"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/> or <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>.
    /// </param>
    /// <param name="texture">Specifies the name of a texture.</param>
    public void glBindTexture( GLenum target, GLuint texture )
    {
        _glBindTexture( target, texture );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDELETETEXTURESPROC( GLsizei n, GLuint* textures );

    private PFNGLDELETETEXTURESPROC _glDeleteTextures;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Delete named textures.
    /// </summary>
    /// <param name="n">Specifies the number of textures to be deleted.</param>
    /// <param name="textures">Specifies a pointer to an array of textures to be deleted.</param>
    public void glDeleteTextures( GLsizei n, GLuint* textures )
    {
        _glDeleteTextures( n, textures );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Delete named textures.
    /// </summary>
    /// <param name="textures">Specifies an array of textures to be deleted.</param>
    public void glDeleteTextures( params GLuint[] textures )
    {
        fixed ( void* p = &textures[ 0 ] )
        {
            _glDeleteTextures( textures.Length, ( GLuint* )p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGENTEXTURESPROC( GLsizei n, GLuint* textures );

    private PFNGLGENTEXTURESPROC _glGenTextures;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate texture names.
    /// </summary>
    /// <param name="n">Specifies the number of texture names to be generated.</param>
    /// <param name="textures">Specifies an array in which the generated texture names are stored.</param>
    public void glGenTextures( GLsizei n, GLuint* textures )
    {
        _glGenTextures( n, textures );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate texture names.
    /// </summary>
    /// <param name="n">Specifies the number of texture names to be generated.</param>
    /// <returns>An array containing the generated texture names.</returns>
    public GLuint[] glGenTextures( GLsizei n )
    {
        var textures = new GLuint[ n ];

        fixed ( void* p =
                   &textures[ 0 ] )
        {
            _glGenTextures( n, ( GLuint* )p );
        }

        return textures;
    }

    /// <summary>
    /// Generate a single texture name.
    /// </summary>
    /// <returns>The generated texture name.</returns>
    public GLuint glGenTexture()
    {
        return glGenTextures( 1 )[ 0 ];
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISTEXTUREPROC( GLuint texture );

    private PFNGLISTEXTUREPROC _glIsTexture;

    /// <summary>
    /// Determine if a name corresponds to a texture.
    /// </summary>
    /// <param name="texture">Specifies a value that may be the name of a texture.</param>
    /// <returns>
    /// <see langword="true"/> if <paramref name="texture"/> is currently the name of a texture. Otherwise,
    /// <see langword="false"/> is returned.
    /// </returns>
    public GLboolean glIsTexture( GLuint texture )
    {
        return _glIsTexture( texture );
    }

#endif

    // OpenGL 1.2

#if OGL_V_1_2 || OGL_V_1_3 || OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDRAWRANGEELEMENTSPROC( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void* indices );

    private PFNGLDRAWRANGEELEMENTSPROC _glDrawRangeElements;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render primitives from array data.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLE_STRIP"/>,
    /// <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="start">Specifies the minimum array index contained in <paramref name="indices"/>.</param>
    /// <param name="end">Specifies the maximum array index contained in <paramref name="indices"/>.</param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">Specifies the type of the values in <paramref name="indices"/>.</param>
    /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
    public void glDrawRangeElements( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void* indices )
    {
        _glDrawRangeElements( mode, start, end, count, type, indices );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render primitives from array data.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLE_STRIP"/>,
    /// <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="start">Specifies the minimum array index contained in <paramref name="indices"/>.</param>
    /// <param name="end">Specifies the maximum array index contained in <paramref name="indices"/>.</param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">Specifies the type of the values in <paramref name="indices"/>.</param>
    /// <param name="indices">
    /// An array of indices to render. Make sure to match the type <typeparamref name="T"/> with the
    /// type specified for <paramref name="type"/>.
    /// </param>
    public void glDrawRangeElements< T >( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, T[] indices )
        where T : unmanaged, IUnsignedNumber< T >
    {
        fixed ( T* p_indices
                   = &indices[ 0 ] )
        {
            _glDrawRangeElements( mode, start, end, count, type, p_indices );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXIMAGE3DPROC( GLenum target,
                                               GLint level,
                                               GLint internalformat,
                                               GLsizei width,
                                               GLsizei height,
                                               GLsizei depth,
                                               GLint border,
                                               GLenum format,
                                               GLenum type,
                                               void* pixels );

    private PFNGLTEXIMAGE3DPROC _glTexImage3D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a three-dimensional texture image.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_3D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/> or <see cref="IGL.GL_PROXY_TEXTURE_2D_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the number of color components in the texture. Refer to
    /// <see href="https://docs.gl/gl4/glTexImage3D"/> for the list of possible values.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support 3D texture images that are at
    /// least 16 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture image. All implementations support 3D texture images that are
    /// at least 256 texels high.
    /// </param>
    /// <param name="depth">
    /// Specifies the depth of the texture image, or the number of layers in a texture array. All
    /// implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least
    /// 256 layers deep.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_BGRA"/>, <see cref="IGL.GL_RED_INTEGER"/>, <see cref="IGL.GL_RG_INTEGER"/>, <see cref="IGL.GL_RGB_INTEGER"/>,
    /// <see cref="IGL.GL_BGR_INTEGER"/>, <see cref="IGL.GL_RGBA_INTEGER"/>, <see cref="IGL.GL_BGRA_INTEGER"/>,
    /// <see cref="IGL.GL_STENCIL_INDEX"/>, <see cref="IGL.GL_DEPTH_COMPONENT"/> or <see cref="IGL.GL_DEPTH_STENCIL"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
    public void glTexImage3D( GLenum target,
                              GLint level,
                              GLint internalformat,
                              GLsizei width,
                              GLsizei height,
                              GLsizei depth,
                              GLint border,
                              GLenum format,
                              GLenum type,
                              void* pixels )
    {
        _glTexImage3D( target, level, internalformat, width, height, depth, border, format, type, pixels );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a three-dimensional texture image.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_3D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/> or <see cref="IGL.GL_PROXY_TEXTURE_2D_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the number of color components in the texture. Refer to
    /// <see href="https://docs.gl/gl4/glTexImage3D"/> for the list of possible values.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support 3D texture images that are at
    /// least 16 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture image. All implementations support 3D texture images that are
    /// at least 256 texels high.
    /// </param>
    /// <param name="depth">
    /// Specifies the depth of the texture image, or the number of layers in a texture array. All
    /// implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least
    /// 256 layers deep.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_BGRA"/>, <see cref="IGL.GL_RED_INTEGER"/>, <see cref="IGL.GL_RG_INTEGER"/>, <see cref="IGL.GL_RGB_INTEGER"/>,
    /// <see cref="IGL.GL_BGR_INTEGER"/>, <see cref="IGL.GL_RGBA_INTEGER"/>, <see cref="IGL.GL_BGRA_INTEGER"/>,
    /// <see cref="IGL.GL_STENCIL_INDEX"/>, <see cref="IGL.GL_DEPTH_COMPONENT"/> or <see cref="IGL.GL_DEPTH_STENCIL"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">
    /// Specifies an array of <typeparamref name="T"/> containing the image data. Make sure to match the
    /// <paramref name="type"/> parameter with <typeparamref name="T"/>.
    /// </param>
    public void glTexImage3D< T >( GLenum target,
                                   GLint level,
                                   GLint internalformat,
                                   GLsizei width,
                                   GLsizei height,
                                   GLsizei depth,
                                   GLint border,
                                   GLenum format,
                                   GLenum type,
                                   T[] pixels ) where T : unmanaged
    {
        fixed ( T* p_pixels
                   = &pixels[ 0 ] )
        {
            _glTexImage3D( target, level, internalformat, width, height, depth, border, format, type, p_pixels );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXSUBIMAGE3DPROC( GLenum target,
                                                  GLint level,
                                                  GLint xoffset,
                                                  GLint yoffset,
                                                  GLint zoffset,
                                                  GLsizei width,
                                                  GLsizei height,
                                                  GLsizei depth,
                                                  GLenum format,
                                                  GLenum type,
                                                  void* pixels );

    private PFNGLTEXSUBIMAGE3DPROC _glTexSubImage3D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a three-dimensional texture subimage.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_3D"/> or
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_DEPTH_COMPONENT"/> and <see cref="IGL.GL_STENCIL_INDEX"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
    public void glTexSubImage3D( GLenum target,
                                 GLint level,
                                 GLint xoffset,
                                 GLint yoffset,
                                 GLint zoffset,
                                 GLsizei width,
                                 GLsizei height,
                                 GLsizei depth,
                                 GLenum format,
                                 GLenum type,
                                 void* pixels )
    {
        _glTexSubImage3D( target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a three-dimensional texture subimage.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_3D"/> or
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="format">
    /// Specifies the format of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_RED"/>, <see cref="IGL.GL_RG"/>, <see cref="IGL.GL_RGB"/>, <see cref="IGL.GL_BGR"/>, <see cref="IGL.GL_RGBA"/>,
    /// <see cref="IGL.GL_DEPTH_COMPONENT"/> and <see cref="IGL.GL_STENCIL_INDEX"/>.
    /// </param>
    /// <param name="type">
    /// Specifies the data type of the pixel data. The following symbolic values are accepted:
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_SHORT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE_3_3_2"/>, <see cref="IGL.GL_UNSIGNED_BYTE_2_3_3_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5"/>, <see cref="IGL.GL_UNSIGNED_SHORT_5_6_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4"/>, <see cref="IGL.GL_UNSIGNED_SHORT_4_4_4_4_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT_5_5_5_1"/>, <see cref="IGL.GL_UNSIGNED_SHORT_1_5_5_5_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8"/>, <see cref="IGL.GL_UNSIGNED_INT_8_8_8_8_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_10_10_10_2"/>, and <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>.
    /// </param>
    /// <param name="pixels">
    /// Specifies an array of <typeparamref name="T"/> containing the image data. Make sure to match the
    /// <paramref name="type"/> parameter with <typeparamref name="T"/>.
    /// </param>
    public void glTexSubImage3D< T >( GLenum target,
                                      GLint level,
                                      GLint xoffset,
                                      GLint yoffset,
                                      GLint zoffset,
                                      GLsizei width,
                                      GLsizei height,
                                      GLsizei depth,
                                      GLenum format,
                                      GLenum type,
                                      T[] pixels ) where T : unmanaged
    {
        fixed ( T* p_pixels
                   = &pixels[ 0 ] )
        {
            _glTexSubImage3D( target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, p_pixels );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOPYTEXSUBIMAGE3DPROC( GLenum target,
                                                      GLint level,
                                                      GLint xoffset,
                                                      GLint yoffset,
                                                      GLint zoffset,
                                                      GLint x,
                                                      GLint y,
                                                      GLsizei width,
                                                      GLsizei height );

    private PFNGLCOPYTEXSUBIMAGE3DPROC _glCopyTexSubImage3D;

    /// <summary>
    /// Copy a three-dimensional texture subimage.
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_3D"/> or
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="x">
    /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
    /// copied.
    /// </param>
    /// <param name="y">
    /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
    /// copied.
    /// </param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    public void glCopyTexSubImage3D( GLenum target,
                                     GLint level,
                                     GLint xoffset,
                                     GLint yoffset,
                                     GLint zoffset,
                                     GLint x,
                                     GLint y,
                                     GLsizei width,
                                     GLsizei height )
    {
        _glCopyTexSubImage3D( target, level, xoffset, yoffset, zoffset, x, y, width, height );
    }

#endif

    // OpenGL 1.3

#if OGL_V_1_3 || OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLACTIVETEXTUREPROC( GLenum texture );

    private PFNGLACTIVETEXTUREPROC _glActiveTexture;

    /// <summary>
    /// Select active texture unit
    /// </summary>
    /// <param name="texture">
    /// Specifies which texture unit to make active. The number of texture units is implementation
    /// dependent, but must be at least 80. <paramref name="texture"/> must be one of <see cref="IGL.GL_TEXTURE0"/>+i, where
    /// i ranges from 0 to the value of <see cref="IGL.GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS"/> minus one. The initial value is
    /// <see cref="IGL.GL_TEXTURE0"/>.
    /// </param>
    public void glActiveTexture( GLenum texture )
    {
        _glActiveTexture( texture );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSAMPLECOVERAGEPROC( GLfloat value, GLboolean invert );

    private PFNGLSAMPLECOVERAGEPROC _glSampleCoverage;

    /// <summary>
    /// Specify multisample coverage parameters
    /// </summary>
    /// <param name="value">
    /// Specify a single floating-point sample coverage value. The value is clamped to the range [0,1]. The
    /// initial value is 1.
    /// </param>
    /// <param name="invert">
    /// Specify a single boolean value representing if the coverage masks should be inverted. The intial
    /// value is <see langword="false"/>.
    /// </param>
    public void glSampleCoverage( GLfloat value, GLboolean invert )
    {
        _glSampleCoverage( value, invert );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOMPRESSEDTEXIMAGE3DPROC( GLenum target,
                                                         GLint level,
                                                         GLenum internalformat,
                                                         GLsizei width,
                                                         GLsizei height,
                                                         GLsizei depth,
                                                         GLint border,
                                                         GLsizei imageSize,
                                                         void* data );

    private PFNGLCOMPRESSEDTEXIMAGE3DPROC _glCompressedTexImage3D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a three-dimensional texture image in a compressed format
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_3D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/> or <see cref="IGL.GL_PROXY_TEXTURE_2D_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the color components in the texture. Must be one of
    /// <see cref="IGL.GL_COMPRESSED_RED"/>, <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>,
    /// <see cref="IGL.GL_COMPRESSED_RGBA"/>, <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support 3D texture images that are at
    /// least 16 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture image. All implementations support 3D texture images that are
    /// at least 16 texels high.
    /// </param>
    /// <param name="depth">
    /// Specifies the depth of the texture image. All implementations support 3D texture images that are at
    /// least 16 texels deep.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="imageSize">
    /// Specifies the number of unsigned bytes of image data starting at the address specified by
    /// <paramref name="data"/>.
    /// </param>
    /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
    public void glCompressedTexImage3D( GLenum target,
                                        GLint level,
                                        GLenum internalformat,
                                        GLsizei width,
                                        GLsizei height,
                                        GLsizei depth,
                                        GLint border,
                                        GLsizei imageSize,
                                        void* data )
    {
        _glCompressedTexImage3D( target, level, internalformat, width, height, depth, border, imageSize, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a three-dimensional texture image in a compressed format
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_3D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/> or <see cref="IGL.GL_PROXY_TEXTURE_2D_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the color components in the texture. Must be one of
    /// <see cref="IGL.GL_COMPRESSED_RED"/>, <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>,
    /// <see cref="IGL.GL_COMPRESSED_RGBA"/>, <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support 3D texture images that are at
    /// least 16 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture image. All implementations support 3D texture images that are
    /// at least 16 texels high.
    /// </param>
    /// <param name="depth">
    /// Specifies the depth of the texture image. All implementations support 3D texture images that are at
    /// least 16 texels deep.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="data">Specifies an array of bytes containing the compressed image data.</param>
    public void glCompressedTexImage3D( GLenum target,
                                        GLint level,
                                        GLenum internalformat,
                                        GLsizei width,
                                        GLsizei height,
                                        GLsizei depth,
                                        GLint border,
                                        byte[] data )
    {
        fixed ( byte* p
                   = &data[ 0 ] )
        {
            _glCompressedTexImage3D( target, level, internalformat, width, height, depth, border, data.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOMPRESSEDTEXIMAGE2DPROC( GLenum target,
                                                         GLint level,
                                                         GLenum internalformat,
                                                         GLsizei width,
                                                         GLsizei height,
                                                         GLint border,
                                                         GLsizei imageSize,
                                                         void* data );

    private PFNGLCOMPRESSEDTEXIMAGE2DPROC _glCompressedTexImage2D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a two-dimensional texture image in a compressed format
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/> or
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the color components in the texture. Must be one of
    /// <see cref="IGL.GL_COMPRESSED_RED"/>, <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>,
    /// <see cref="IGL.GL_COMPRESSED_RGBA"/>, <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support 2D texture images that are at
    /// least 16 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture image. All implementations support 2D texture images that are
    /// at least 16 texels high.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="imageSize">
    /// Specifies the number of unsigned bytes of image data starting at the address specified by
    /// <paramref name="data"/>.
    /// </param>
    /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
    public void glCompressedTexImage2D( GLenum target,
                                        GLint level,
                                        GLenum internalformat,
                                        GLsizei width,
                                        GLsizei height,
                                        GLint border,
                                        GLsizei imageSize,
                                        void* data )
    {
        _glCompressedTexImage2D( target, level, internalformat, width, height, border, imageSize, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a two-dimensional texture image in a compressed format
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_PROXY_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/> or
    /// <see cref="IGL.GL_PROXY_TEXTURE_CUBE_MAP"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the color components in the texture. Must be one of
    /// <see cref="IGL.GL_COMPRESSED_RED"/>, <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>,
    /// <see cref="IGL.GL_COMPRESSED_RGBA"/>, <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support 2D texture images that are at
    /// least 16 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture image. All implementations support 2D texture images that are
    /// at least 16 texels high.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="data">Specifies an array of bytes containing the compressed image data.</param>
    public void glCompressedTexImage2D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, byte[] data )
    {
        fixed ( byte* p
                   = &data[ 0 ] )
        {
            _glCompressedTexImage2D( target, level, internalformat, width, height, border, data.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOMPRESSEDTEXIMAGE1DPROC( GLenum target,
                                                         GLint level,
                                                         GLenum internalformat,
                                                         GLsizei width,
                                                         GLint border,
                                                         GLsizei imageSize,
                                                         void* data );

    private PFNGLCOMPRESSEDTEXIMAGE1DPROC _glCompressedTexImage1D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a one-dimensional texture image in a compressed format
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/> or
    /// <see cref="IGL.GL_PROXY_TEXTURE_1D"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the color components in the texture. Must be one of
    /// <see cref="IGL.GL_COMPRESSED_RED"/>, <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>,
    /// <see cref="IGL.GL_COMPRESSED_RGBA"/>, <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support 2D texture images that are at
    /// least 64 texels wide.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="imageSize">
    /// Specifies the number of unsigned bytes of image data starting at the address specified by
    /// <paramref name="data"/>.
    /// </param>
    /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
    public void glCompressedTexImage1D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, void* data )
    {
        _glCompressedTexImage1D( target, level, internalformat, width, border, imageSize, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a one-dimensional texture image in a compressed format
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/> or
    /// <see cref="IGL.GL_PROXY_TEXTURE_1D"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="internalformat">
    /// Specifies the color components in the texture. Must be one of
    /// <see cref="IGL.GL_COMPRESSED_RED"/>, <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>,
    /// <see cref="IGL.GL_COMPRESSED_RGBA"/>, <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="width">
    /// Specifies the width of the texture image. All implementations support 2D texture images that are at
    /// least 64 texels wide.
    /// </param>
    /// <param name="border">This value must be 0.</param>
    /// <param name="data">Specifies an array of bytes containing the compressed image data.</param>
    public void glCompressedTexImage1D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, byte[] data )
    {
        fixed ( byte* p =
                   &data[ 0 ] )
        {
            _glCompressedTexImage1D( target, level, internalformat, width, border, data.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC( GLenum target,
                                                            GLint level,
                                                            GLint xoffset,
                                                            GLint yoffset,
                                                            GLint zoffset,
                                                            GLsizei width,
                                                            GLsizei height,
                                                            GLsizei depth,
                                                            GLenum format,
                                                            GLsizei imageSize,
                                                            void* data );

    private PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC _glCompressedTexSubImage3D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a three-dimensional texture subimage in a compressed format
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_3D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/> or <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">
    /// Specifies the width of the texture subimage. All implementations support 3D texture subimages that
    /// are at least 16 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture subimage. All implementations support 3D texture subimages
    /// that are at least 16 texels high.
    /// </param>
    /// <param name="depth">
    /// Specifies the depth of the texture subimage. All implementations support 3D texture subimages that
    /// are at least 16 texels deep.
    /// </param>
    /// <param name="format">
    /// Specifies the color components in the texture. Must be one of <see cref="IGL.GL_COMPRESSED_RED"/>,
    /// <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>, <see cref="IGL.GL_COMPRESSED_RGBA"/>,
    /// <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="imageSize">
    /// Specifies the number of unsigned bytes of image data starting at the address specified by
    /// <paramref name="data"/>.
    /// </param>
    /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
    public void glCompressedTexSubImage3D( GLenum target,
                                           GLint level,
                                           GLint xoffset,
                                           GLint yoffset,
                                           GLint zoffset,
                                           GLsizei width,
                                           GLsizei height,
                                           GLsizei depth,
                                           GLenum format,
                                           GLsizei imageSize,
                                           void* data )
    {
        _glCompressedTexSubImage3D( target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a three-dimensional texture subimage in a compressed format
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_3D"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_ARRAY"/> or <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">
    /// Specifies the width of the texture subimage. All implementations support 3D texture subimages that
    /// are at least 16 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture subimage. All implementations support 3D texture subimages
    /// that are at least 16 texels high.
    /// </param>
    /// <param name="depth">
    /// Specifies the depth of the texture subimage. All implementations support 3D texture subimages that
    /// are at least 16 texels deep.
    /// </param>
    /// <param name="format">
    /// Specifies the color components in the texture. Must be one of <see cref="IGL.GL_COMPRESSED_RED"/>,
    /// <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>, <see cref="IGL.GL_COMPRESSED_RGBA"/>,
    /// <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="data">Specifies an array of bytes containing the compressed image data.</param>
    public void glCompressedTexSubImage3D( GLenum target,
                                           GLint level,
                                           GLint xoffset,
                                           GLint yoffset,
                                           GLint zoffset,
                                           GLsizei width,
                                           GLsizei height,
                                           GLsizei depth,
                                           GLenum format,
                                           byte[] data )
    {
        fixed ( byte* p
                   = &data[ 0 ] )
        {
            _glCompressedTexSubImage3D( target, level, xoffset, yoffset, zoffset, width, height, depth, format, data.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC( GLenum target,
                                                            GLint level,
                                                            GLint xoffset,
                                                            GLint yoffset,
                                                            GLsizei width,
                                                            GLsizei height,
                                                            GLenum format,
                                                            GLsizei imageSize,
                                                            void* data );

    private PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC _glCompressedTexSubImage2D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a two-dimensional texture subimage in a compressed format
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/> or
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="width">
    /// Specifies the width of the texture subimage. All implementations support 2D texture subimages that
    /// are at least 16 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture subimage. All implementations support 2D texture subimages
    /// that are at least 16 texels high.
    /// </param>
    /// <param name="format">
    /// Specifies the color components in the texture. Must be one of <see cref="IGL.GL_COMPRESSED_RED"/>,
    /// <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>, <see cref="IGL.GL_COMPRESSED_RGBA"/>,
    /// <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="imageSize">
    /// Specifies the number of unsigned bytes of image data starting at the address specified by
    /// <paramref name="data"/>.
    /// </param>
    /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
    public void glCompressedTexSubImage2D( GLenum target,
                                           GLint level,
                                           GLint xoffset,
                                           GLint yoffset,
                                           GLsizei width,
                                           GLsizei height,
                                           GLenum format,
                                           GLsizei imageSize,
                                           void* data )
    {
        _glCompressedTexSubImage2D( target, level, xoffset, yoffset, width, height, format, imageSize, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a two-dimensional texture subimage in a compressed format
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/> or
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="width">
    /// Specifies the width of the texture subimage. All implementations support 2D texture subimages that
    /// are at least 16 texels wide.
    /// </param>
    /// <param name="height">
    /// Specifies the height of the texture subimage. All implementations support 2D texture subimages
    /// that are at least 16 texels high.
    /// </param>
    /// <param name="format">
    /// Specifies the color components in the texture. Must be one of <see cref="IGL.GL_COMPRESSED_RED"/>,
    /// <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>, <see cref="IGL.GL_COMPRESSED_RGBA"/>,
    /// <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="data">Specifies an array of bytes containing the compressed image data.</param>
    public void glCompressedTexSubImage2D( GLenum target,
                                           GLint level,
                                           GLint xoffset,
                                           GLint yoffset,
                                           GLsizei width,
                                           GLsizei height,
                                           GLenum format,
                                           byte[] data )
    {
        fixed ( byte* p
                   = &data[ 0 ] )
        {
            _glCompressedTexSubImage2D( target, level, xoffset, yoffset, width, height, format, data.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC( GLenum target,
                                                            GLint level,
                                                            GLint xoffset,
                                                            GLsizei width,
                                                            GLenum format,
                                                            GLsizei imageSize,
                                                            void* data );

    private PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC _glCompressedTexSubImage1D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a one-dimensional texture subimage in a compressed format
    /// </summary>
    /// <param name="target">Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/>.</param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="width">
    /// Specifies the width of the texture subimage. All implementations support 1D texture subimages that
    /// are at least 16 texels wide.
    /// </param>
    /// <param name="format">
    /// Specifies the color components in the texture. Must be one of <see cref="IGL.GL_COMPRESSED_RED"/>,
    /// <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>, <see cref="IGL.GL_COMPRESSED_RGBA"/>,
    /// <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="imageSize">
    /// Specifies the number of unsigned bytes of image data starting at the address specified by
    /// <paramref name="data"/>.
    /// </param>
    /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
    public void glCompressedTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, void* data )
    {
        _glCompressedTexSubImage1D( target, level, xoffset, width, format, imageSize, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a one-dimensional texture subimage in a compressed format
    /// </summary>
    /// <param name="target">Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/>.</param>
    /// <param name="level">
    /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
    /// reduction image.
    /// </param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="width">
    /// Specifies the width of the texture subimage. All implementations support 1D texture subimages that
    /// are at least 16 texels wide.
    /// </param>
    /// <param name="format">
    /// Specifies the color components in the texture. Must be one of <see cref="IGL.GL_COMPRESSED_RED"/>,
    /// <see cref="IGL.GL_COMPRESSED_RG"/>, <see cref="IGL.GL_COMPRESSED_RGB"/>, <see cref="IGL.GL_COMPRESSED_RGBA"/>,
    /// <see cref="IGL.GL_COMPRESSED_SRGB"/>, <see cref="IGL.GL_COMPRESSED_SRGB_ALPHA"/>.
    /// </param>
    /// <param name="data">Specifies an array of bytes containing the compressed image data.</param>
    public void glCompressedTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, byte[] data )
    {
        fixed ( byte* p =
                   &data[ 0 ] )
        {
            _glCompressedTexSubImage1D( target, level, xoffset, width, format, data.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETCOMPRESSEDTEXIMAGEPROC( GLenum target, GLint level, void* img );

    private PFNGLGETCOMPRESSEDTEXIMAGEPROC _glGetCompressedTexImage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return a compressed texture image
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/> or
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n
    /// is the nth mipmap reduction image.
    /// </param>
    /// <param name="img">Specifies a pointer to a buffer into which the compressed image data will be placed.</param>
    public void glGetCompressedTexImage( GLenum target, GLint level, void* img )
    {
        _glGetCompressedTexImage( target, level, img );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return a compressed texture image
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture. Must be <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_X"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_X"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Y"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP_POSITIVE_Z"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"/> or
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="level">
    /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n
    /// is the nth mipmap reduction image.
    /// </param>
    /// <param name="img">Specifies a <see langword="ref"/> byte array into which the compressed image data will be placed.</param>
    public void glGetCompressedTexImage( GLenum target, GLint level, ref byte[] img )
    {
        fixed ( byte* p =
                   &img[ 0 ] )
        {
            _glGetCompressedTexImage( target, level, p );
        }
    }
#endif

#endif

    // OpenGL 1.4

#if OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBLENDFUNCSEPARATEPROC( GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha );

    private PFNGLBLENDFUNCSEPARATEPROC _glBlendFuncSeparate;

    /// <summary>
    /// Specify pixel arithmetic for RGB and alpha components separately. Refer to
    /// <see href="https://docs.gl/gl4/glBlendFuncSeparate"/> for all possible values for the functions.
    /// </summary>
    /// <param name="sfactorRGB">
    /// Specifies how the red, green, and blue blending factors are computed. The initial value is
    /// <see cref="IGL.GL_ONE"/>.
    /// </param>
    /// <param name="dfactorRGB">
    /// Specifies how the red, green, and blue destination blending factors are computed. The initial
    /// value is <see cref="IGL.GL_ZERO"/>.
    /// </param>
    /// <param name="sfactorAlpha">
    /// Specifies how the alpha source blending factor is computed. The initial value is
    /// <see cref="IGL.GL_ONE"/>.
    /// </param>
    /// <param name="dfactorAlpha">
    /// Specifies how the alpha destination blending factor is computed. The initial value is
    /// <see cref="IGL.GL_ZERO"/>.
    /// </param>
    public void glBlendFuncSeparate( GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha )
    {
        _glBlendFuncSeparate( sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLMULTIDRAWARRAYSPROC( GLenum mode, GLint* first, GLsizei* count, GLsizei drawcount );

    private PFNGLMULTIDRAWARRAYSPROC _glMultiDrawArrays;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render multiple sets of primitives from array data.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLE_STRIP"/>,
    /// <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="first">Specifies an array of starting indices in the enabled arrays.</param>
    /// <param name="count">Specifies an array of the number of indices to be rendered.</param>
    /// <param name="drawcount">Specifies the size of the <paramref name="first"/> and <paramref name="count"/> arrays.</param>
    public void glMultiDrawArrays( GLenum mode, GLint* first, GLsizei* count, GLsizei drawcount )
    {
        _glMultiDrawArrays( mode, first, count, drawcount );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render multiple sets of primitives from array data.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLE_STRIP"/>,
    /// <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="first">Specifies an array of starting indices in the enabled arrays.</param>
    /// <param name="count">Specifies an array of the number of indices to be rendered.</param>
    public void glMultiDrawArrays( GLenum mode, GLint[] first, GLsizei[] count )
    {
        if ( first.Length != count.Length )
        {
            throw new ArgumentException( "first and count arrays must be of the same length" );
        }

        fixed ( GLint* p1 = &first[ 0 ] )
        {
            fixed ( GLsizei* p2 = &count[ 0 ] )
            {
                _glMultiDrawArrays( mode, p1, p2, count.Length );
            }
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLMULTIDRAWELEMENTSPROC( GLenum mode, GLsizei* count, GLenum type, void** indices, GLsizei drawcount );

    private PFNGLMULTIDRAWELEMENTSPROC _glMultiDrawElements;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render multiple sets of primitives by specifying indices of array data elements.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLE_STRIP"/>,
    /// <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="count">Specifies an array of the elements counts.</param>
    /// <param name="type">
    /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
    /// <param name="drawcount">Specifies the size of the <paramref name="count"/> and <paramref name="indices"/> arrays.</param>
    public void glMultiDrawElements( GLenum mode, GLsizei* count, GLenum type, void** indices, GLsizei drawcount )
    {
        _glMultiDrawElements( mode, count, type, indices, drawcount );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render multiple sets of primitives by specifying indices of array data elements.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLE_STRIP"/>,
    /// <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="count">Specifies an array of the elements counts.</param>
    /// <param name="type">
    /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">Specifies a two-dimensional array of indices of the vertices that are to be rendered.</param>
    public void glMultiDrawElements< T >( GLenum mode, GLsizei[] count, GLenum type, T[][] indices ) where T : unmanaged, IUnsignedNumber< T >
    {
        var indexPtrs = new void*[ indices.Length ];

        for ( var i = 0; i < indices.Length; i++ )
        {
            fixed ( void* p = &indices[ i ][ 0 ] )
            {
                indexPtrs[ i ] = p;
            }
        }

        fixed ( GLsizei* c = &count[ 0 ] )
        {
            fixed ( void** p = &indexPtrs[ 0 ] )
            {
                _glMultiDrawElements( mode, c, type, p, count.Length );
            }
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPOINTPARAMETERFPROC( GLenum pname, GLfloat param );

    private PFNGLPOINTPARAMETERFPROC _glPointParameterf;

    /// <summary>
    /// Specify point parameters.
    /// </summary>
    /// <param name="pname">
    /// Specifies the symbolic name of the parameter to be set. <see cref="IGL.GL_POINT_FADE_THRESHOLD_SIZE"/>
    /// and <see cref="IGL.GL_POINT_SPRITE_COORD_ORIGIN"/> are accepted.
    /// </param>
    /// <param name="param">Specifies the value that parameter <paramref name="pname"/> will be set to.</param>
    public void glPointParameterf( GLenum pname, GLfloat param )
    {
        _glPointParameterf( pname, param );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPOINTPARAMETERFVPROC( GLenum pname, GLfloat* @params );

    private PFNGLPOINTPARAMETERFVPROC _glPointParameterfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify point parameters.
    /// </summary>
    /// <param name="pname">
    /// Specifies the symbolic name of the parameter to be set. <see cref="IGL.GL_POINT_FADE_THRESHOLD_SIZE"/>
    /// and <see cref="IGL.GL_POINT_SPRITE_COORD_ORIGIN"/> are accepted.
    /// </param>
    /// <param name="params">
    /// Specifies a pointer to an array where the value or values to be assigned to
    /// <paramref name="pname"/> are currently stored.
    /// </param>
    public void glPointParameterfv( GLenum pname, GLfloat* @params )
    {
        _glPointParameterfv( pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify point parameters.
    /// </summary>
    /// <param name="pname">
    /// Specifies the symbolic name of the parameter to be set. <see cref="IGL.GL_POINT_FADE_THRESHOLD_SIZE"/>
    /// and <see cref="IGL.GL_POINT_SPRITE_COORD_ORIGIN"/> are accepted.
    /// </param>
    /// <param name="params">Specifies an array of values that will be used to update the current point parameters.</param>
    public void glPointParameterfv( GLenum pname, GLfloat[] @params )
    {
        fixed ( GLfloat* p = &@params[ 0 ] )
        {
            _glPointParameterfv( pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPOINTPARAMETERIPROC( GLenum pname, GLint param );

    private PFNGLPOINTPARAMETERIPROC _glPointParameteri;

    /// <summary>
    /// Specify point parameters.
    /// </summary>
    /// <param name="pname">
    /// Specifies the symbolic name of the parameter to be set. <see cref="IGL.GL_POINT_FADE_THRESHOLD_SIZE"/>
    /// and <see cref="IGL.GL_POINT_SPRITE_COORD_ORIGIN"/> are accepted.
    /// </param>
    /// <param name="param">Specifies the value that parameter <paramref name="pname"/> will be set to.</param>
    public void glPointParameteri( GLenum pname, GLint param )
    {
        _glPointParameteri( pname, param );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPOINTPARAMETERIVPROC( GLenum pname, GLint* @params );

    private PFNGLPOINTPARAMETERIVPROC _glPointParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify point parameters.
    /// </summary>
    /// <param name="pname">
    /// Specifies the symbolic name of the parameter to be set. <see cref="IGL.GL_POINT_FADE_THRESHOLD_SIZE"/>
    /// and <see cref="IGL.GL_POINT_SPRITE_COORD_ORIGIN"/> are accepted.
    /// </param>
    /// <param name="params">
    /// Specifies a pointer to an array where the value or values to be assigned to
    /// <paramref name="pname"/> are currently stored.
    /// </param>
    public void glPointParameteriv( GLenum pname, GLint* @params )
    {
        _glPointParameteriv( pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify point parameters.
    /// </summary>
    /// <param name="pname">
    /// Specifies the symbolic name of the parameter to be set. <see cref="IGL.GL_POINT_FADE_THRESHOLD_SIZE"/>
    /// and <see cref="IGL.GL_POINT_SPRITE_COORD_ORIGIN"/> are accepted.
    /// </param>
    /// <param name="params">Specifies an array of values that will be used to update the current point parameters.</param>
    public void glPointParameteriv( GLenum pname, GLint[] @params )
    {
        fixed ( GLint* p = &@params[ 0 ] )
        {
            _glPointParameteriv( pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBLENDCOLORPROC( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );

    private PFNGLBLENDCOLORPROC _glBlendColor;

    /// <summary>
    /// Set the blend color.
    /// </summary>
    /// <param name="red">Specify the red value to use as the blend color.</param>
    /// <param name="green">Specify the green value to use as the blend color.</param>
    /// <param name="blue">Specify the blue value to use as the blend color.</param>
    /// <param name="alpha">Specify the alpha value to use as the blend color.</param>
    public void glBlendColor( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha )
    {
        _glBlendColor( red, green, blue, alpha );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBLENDEQUATIONPROC( GLenum mode );

    private PFNGLBLENDEQUATIONPROC _glBlendEquation;

    /// <summary>
    /// Specify the equation used for both the RGB blend equation and the Alpha blend equation.
    /// </summary>
    /// <param name="mode">
    /// Specifies how source and destination colors are combined. Must be <see cref="IGL.GL_FUNC_ADD"/>,
    /// <see cref="IGL.GL_FUNC_SUBTRACT"/>, <see cref="IGL.GL_FUNC_REVERSE_SUBTRACT"/>, <see cref="IGL.GL_MIN"/>,
    /// <see cref="IGL.GL_MAX"/>.
    /// </param>
    public void glBlendEquation( GLenum mode )
    {
        _glBlendEquation( mode );
    }

#endif

    // OpenGL 1.5

#if OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGENQUERIESPROC( GLsizei n, GLuint* ids );

    private PFNGLGENQUERIESPROC _glGenQueries;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate query object names.
    /// </summary>
    /// <param name="n">Specifies the number of query object names to generate.</param>
    /// <param name="ids">Specifies an array in which the generated query object names are to be stored.</param>
    public void glGenQueries( GLsizei n, GLuint* ids )
    {
        _glGenQueries( n, ids );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate query object names.
    /// </summary>
    /// <param name="n">Specifies the number of query object names to generate.</param>
    /// <returns>Array of generated query object names.</returns>
    public GLuint[] glGenQueries( GLsizei n )
    {
        var ret = new GLuint[ n ];

        fixed ( GLuint* p = &ret[ 0 ] )
        {
            _glGenQueries( n, p );
        }

        return ret;
    }

    /// <summary>
    /// Generate a single query object name.
    /// </summary>
    /// <returns>Generated query object name.</returns>
    public GLuint glGenQuery()
    {
        return glGenQueries( 1 )[ 0 ];
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDELETEQUERIESPROC( GLsizei n, GLuint* ids );

    private PFNGLDELETEQUERIESPROC _glDeleteQueries;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Delete named query objects.
    /// </summary>
    /// <param name="n">Specifies the number of query objects to be deleted.</param>
    /// <param name="ids">Specifies an array of query objects to be deleted.</param>
    public void glDeleteQueries( GLsizei n, GLuint* ids )
    {
        _glDeleteQueries( n, ids );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Delete named query objects.
    /// </summary>
    /// <param name="ids">Specifies an array of query objects to be deleted.</param>
    public void glDeleteQueries( params GLuint[] ids )
    {
        fixed ( GLuint* p = &ids[ 0 ] )
        {
            _glDeleteQueries( ids.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISQUERYPROC( GLuint id );

    private PFNGLISQUERYPROC _glIsQuery;

    /// <summary>
    /// Determine if a name corresponds to a query object.
    /// </summary>
    /// <param name="id">Specifies a value that may be the name of a query object.</param>
    /// <returns><see langword="true"/> if <paramref name="id"/> is query object name, otherwise <see langword="false"/>.</returns>
    public GLboolean glIsQuery( GLuint id )
    {
        return _glIsQuery( id );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBEGINQUERYPROC( GLenum target, GLuint id );

    private PFNGLBEGINQUERYPROC _glBeginQuery;

    /// <summary>
    /// Delimit the boundaries of a query object.
    /// </summary>
    /// <param name="target">
    /// Specifies the target type of query object established between <see cref="glBeginQuery"/> and the
    /// subsequent <see cref="glEndQuery"/>. The symbol constant must be one of <see cref="IGL.GL_SAMPLES_PASSED"/>,
    /// <see cref="IGL.GL_ANY_SAMPLES_PASSED"/>, <see cref="IGL.GL_ANY_SAMPLES_PASSED_CONSERVATIVE"/>,
    /// <see cref="IGL.GL_PRIMITIVES_GENERATED"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"/> or
    /// <see cref="IGL.GL_TIME_ELAPSED"/>.
    /// </param>
    /// <param name="id">Specifies the name of a query object.</param>
    public void glBeginQuery( GLenum target, GLuint id )
    {
        _glBeginQuery( target, id );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLENDQUERYPROC( GLenum target );

    private PFNGLENDQUERYPROC _glEndQuery;

    /// <summary>
    /// Delimit the boundaries of a query object.
    /// </summary>
    /// <param name="target">
    /// Specifies the target type of query object established between <see cref="glBeginQuery"/> and the
    /// subsequent <see cref="glEndQuery"/>. The symbol constant must be one of <see cref="IGL.GL_SAMPLES_PASSED"/>,
    /// <see cref="IGL.GL_ANY_SAMPLES_PASSED"/>, <see cref="IGL.GL_ANY_SAMPLES_PASSED_CONSERVATIVE"/>,
    /// <see cref="IGL.GL_PRIMITIVES_GENERATED"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"/> or
    /// <see cref="IGL.GL_TIME_ELAPSED"/>.
    /// </param>
    public void glEndQuery( GLenum target )
    {
        _glEndQuery( target );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETQUERYIVPROC( GLenum target, GLenum pname, GLint* @params );

    private PFNGLGETQUERYIVPROC _glGetQueryiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a query object target.
    /// </summary>
    /// <param name="target">
    /// Specifies the target parameter of the query object being queried. The symbolic constant must be
    /// one of <see cref="IGL.GL_SAMPLES_PASSED"/>, <see cref="IGL.GL_ANY_SAMPLES_PASSED"/>,
    /// <see cref="IGL.GL_ANY_SAMPLES_PASSED_CONSERVATIVE"/>, <see cref="IGL.GL_PRIMITIVES_GENERATED"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"/>, <see cref="IGL.GL_TIME_ELAPSED"/> or
    /// <see cref="IGL.GL_TIMESTAMP"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a query object target parameter. <see cref="IGL.GL_CURRENT_QUERY"/> and
    /// <see cref="IGL.GL_QUERY_COUNTER_BITS"/> are accepted.
    /// </param>
    /// <param name="params">A pointer to the location where the integer value or values are to be returned.</param>
    public void glGetQueryiv( GLenum target, GLenum pname, GLint* @params )
    {
        _glGetQueryiv( target, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a query object target.
    /// </summary>
    /// <param name="target">
    /// Specifies the target parameter of the query object being queried. The symbolic constant must be
    /// one of <see cref="IGL.GL_SAMPLES_PASSED"/>, <see cref="IGL.GL_ANY_SAMPLES_PASSED"/>,
    /// <see cref="IGL.GL_ANY_SAMPLES_PASSED_CONSERVATIVE"/>, <see cref="IGL.GL_PRIMITIVES_GENERATED"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"/>, <see cref="IGL.GL_TIME_ELAPSED"/> or
    /// <see cref="IGL.GL_TIMESTAMP"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a query object target parameter. <see cref="IGL.GL_CURRENT_QUERY"/> and
    /// <see cref="IGL.GL_QUERY_COUNTER_BITS"/> are accepted.
    /// </param>
    /// <param name="params">A <see langword="ref"/> to an integer array where the integer value or values are to be returned.</param>
    public void glGetQueryiv( GLenum target, GLenum pname, ref GLint[] @params )
    {
        fixed ( GLint* p =
                   &@params[ 0 ] )
        {
            _glGetQueryiv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETQUERYOBJECTIVPROC( GLuint id, GLenum pname, GLint* @params );

    private PFNGLGETQUERYOBJECTIVPROC _glGetQueryObjectiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a query object.
    /// </summary>
    /// <param name="id">Specifies the name of a query object.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a query object parameter. <see cref="IGL.GL_QUERY_RESULT"/>,
    /// <see cref="IGL.GL_QUERY_RESULT_NO_WAIT"/> or <see cref="IGL.GL_QUERY_RESULT_AVAILABLE"/> are accepted.
    /// </param>
    /// <param name="params">A pointer to the location where the integer value or values are to be returned.</param>
    public void glGetQueryObjectiv( GLuint id, GLenum pname, GLint* @params )
    {
        _glGetQueryObjectiv( id, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a query object.
    /// </summary>
    /// <param name="id">Specifies the name of a query object.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a query object parameter. <see cref="IGL.GL_QUERY_RESULT"/>,
    /// <see cref="IGL.GL_QUERY_RESULT_NO_WAIT"/> or <see cref="IGL.GL_QUERY_RESULT_AVAILABLE"/> are accepted.
    /// </param>
    /// <param name="params">A <see langword="ref"/> to an integer array where the integer value or values are to be returned.</param>
    public void glGetQueryObjectiv( GLuint id, GLenum pname, ref GLint[] @params )
    {
        fixed ( GLint* p =
                   &@params[ 0 ] )
        {
            _glGetQueryObjectiv( id, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETQUERYOBJECTUIVPROC( GLuint id, GLenum pname, GLuint* @params );

    private PFNGLGETQUERYOBJECTUIVPROC _glGetQueryObjectuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a query object.
    /// </summary>
    /// <param name="id">Specifies the name of a query object.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a query object parameter. <see cref="IGL.GL_QUERY_RESULT"/>,
    /// <see cref="IGL.GL_QUERY_RESULT_NO_WAIT"/> or <see cref="IGL.GL_QUERY_RESULT_AVAILABLE"/> are accepted.
    /// </param>
    /// <param name="params">A pointer to the location where the unsigned integer value or values are to be returned.</param>
    public void glGetQueryObjectuiv( GLuint id, GLenum pname, GLuint* @params )
    {
        _glGetQueryObjectuiv( id, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a query object.
    /// </summary>
    /// <param name="id">Specifies the name of a query object.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a query object parameter. <see cref="IGL.GL_QUERY_RESULT"/>,
    /// <see cref="IGL.GL_QUERY_RESULT_NO_WAIT"/> or <see cref="IGL.GL_QUERY_RESULT_AVAILABLE"/> are accepted.
    /// </param>
    /// <param name="params">
    /// A <see langword="ref"/> to an unsigned integer array where the integer value or values are to be
    /// returned.
    /// </param>
    public void glGetQueryObjectuiv( GLuint id, GLenum pname, ref GLuint[] @params )
    {
        fixed ( GLuint* p =
                   &@params[ 0 ] )
        {
            _glGetQueryObjectuiv( id, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDBUFFERPROC( GLenum target, GLuint buffer );

    private PFNGLBINDBUFFERPROC _glBindBuffer;

    /// <summary>
    /// Bind a named buffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the buffer object is bound. The symbolic constant must be
    /// <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>
    /// , <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>, <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>,
    /// <see cref="IGL.GL_TEXTURE_BUFFER"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="buffer">Specifies the name of a buffer object.</param>
    public void glBindBuffer( GLenum target, GLuint buffer )
    {
        _glBindBuffer( target, buffer );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDELETEBUFFERSPROC( GLsizei n, GLuint* buffers );

    private PFNGLDELETEBUFFERSPROC _glDeleteBuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Delete named buffer objects.
    /// </summary>
    /// <param name="n">Specifies the number of buffer objects to be deleted.</param>
    /// <param name="buffers">A pointer to an array of buffer objects to be deleted.</param>
    public void glDeleteBuffers( GLsizei n, GLuint* buffers )
    {
        _glDeleteBuffers( n, buffers );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Delete named buffer objects.
    /// </summary>
    /// <param name="buffers">An array of buffer objects to be deleted.</param>
    public void glDeleteBuffers( params GLuint[] buffers )
    {
        fixed ( GLuint* p = &buffers[ 0 ] )
        {
            _glDeleteBuffers( buffers.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGENBUFFERSPROC( GLsizei n, GLuint* buffers );

    private PFNGLGENBUFFERSPROC _glGenBuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate buffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of buffer object names to generate.</param>
    /// <param name="buffers">A pointer to an array in which the generated buffer object names are to be stored.</param>
    public void glGenBuffers( GLsizei n, GLuint* buffers )
    {
        _glGenBuffers( n, buffers );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate buffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of buffer object names to generate.</param>
    /// <returns>An array of generated buffer object names.</returns>
    public GLuint[] glGenBuffers( GLsizei n )
    {
        var ret = new GLuint[ n ];

        fixed ( GLuint* p = &ret[ 0 ] )
        {
            _glGenBuffers( n, p );
        }

        return ret;
    }

    /// <summary>
    /// Generate a single buffer object name.
    /// </summary>
    /// <returns>The generated buffer object name.</returns>
    public GLuint glGenBuffer()
    {
        return glGenBuffers( 1 )[ 0 ];
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISBUFFERPROC( GLuint buffer );

    private PFNGLISBUFFERPROC _glIsBuffer;

    /// <summary>
    /// Determine if a name corresponds to a buffer object.
    /// </summary>
    /// <param name="buffer">A value that may be the name of a buffer object.</param>
    /// <returns>
    /// <see langword="true"/> if <paramref name="buffer"/> is a buffer object name. <see langword="false"/>
    /// otherwise.
    /// </returns>
    public GLboolean glIsBuffer( GLuint buffer )
    {
        return _glIsBuffer( buffer );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBUFFERDATAPROC( GLenum target, GLsizeiptr size, void* data, GLenum usage );

    private PFNGLBUFFERDATAPROC _glBufferData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Create and initialize a buffer object's data store.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>,
    /// <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>, <see cref="IGL.GL_COPY_WRITE_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
    /// <param name="data">
    /// Specifies a pointer to data that will be copied into the data store for initialization, or
    /// <see cref="NULL"/> if no data is to be copied.
    /// </param>
    /// <param name="usage">
    /// Specifies the expected usage pattern of the data store. The symbolic constant must be
    /// <see cref="IGL.GL_STREAM_DRAW"/>, <see cref="IGL.GL_STREAM_READ"/>, <see cref="IGL.GL_STREAM_COPY"/>,
    /// <see cref="IGL.GL_STATIC_DRAW"/>, <see cref="IGL.GL_STATIC_READ"/>, <see cref="IGL.GL_STATIC_COPY"/>,
    /// <see cref="IGL.GL_DYNAMIC_DRAW"/>, <see cref="IGL.GL_DYNAMIC_READ"/> or <see cref="IGL.GL_DYNAMIC_COPY"/>.
    /// </param>
    public void glBufferData( GLenum target, GLsizeiptr size, void* data, GLenum usage )
    {
        _glBufferData( target, size, data, usage );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Create and initialize a buffer object's data store.
    /// </summary>
    /// <typeparam name="T">The type of the data to be copied.</typeparam>
    /// <param name="target">
    /// Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>,
    /// <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>, <see cref="IGL.GL_COPY_WRITE_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="data">An array of <typeparamref name="T"/>s that will be copied into the data store for initialization.</param>
    /// <param name="usage">
    /// Specifies the expected usage pattern of the data store. The symbolic constant must be
    /// <see cref="IGL.GL_STREAM_DRAW"/>, <see cref="IGL.GL_STREAM_READ"/>, <see cref="IGL.GL_STREAM_COPY"/>,
    /// <see cref="IGL.GL_STATIC_DRAW"/>, <see cref="IGL.GL_STATIC_READ"/>, <see cref="IGL.GL_STATIC_COPY"/>,
    /// <see cref="IGL.GL_DYNAMIC_DRAW"/>, <see cref="IGL.GL_DYNAMIC_READ"/> or <see cref="IGL.GL_DYNAMIC_COPY"/>.
    /// </param>
    public void glBufferData< T >( GLenum target, T[] data, GLenum usage ) where T : unmanaged
    {
        fixed ( T* p =
                   &data[ 0 ] )
        {
            _glBufferData( target, sizeof( T ) * data.Length, p, usage );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBUFFERSUBDATAPROC( GLenum target, GLintptr offset, GLsizeiptr size, void* data );

    private PFNGLBUFFERSUBDATAPROC _glBufferSubData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Update a subset of a buffer object's data store.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>,
    /// <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>, <see cref="IGL.GL_COPY_WRITE_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="offset">
    /// Specifies the offset into the buffer object's data store where data replacement will begin,
    /// measured in bytes.
    /// </param>
    /// <param name="size">Specifies the size in bytes of the data store region being replaced.</param>
    /// <param name="data">Specifies a pointer to the new data that will be copied into the data store.</param>
    public void glBufferSubData( GLenum target, GLintptr offset, GLsizeiptr size, void* data )
    {
        _glBufferSubData( target, offset, size, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Update a subset of a buffer object's data store.
    /// </summary>
    /// <typeparam name="T">The type of the data to be copied.</typeparam>
    /// <param name="target">
    /// Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>,
    /// <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>, <see cref="IGL.GL_COPY_WRITE_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="offsetCount">Specifies the offset into the buffer object's data store where data replacement will begin.</param>
    /// <param name="data">An array of <typeparamref name="T"/>s that will be copied into the data store for replacement.</param>
    public void glBufferSubData< T >( GLenum target, GLintptr offsetCount, T[] data ) where T : unmanaged
    {
        fixed ( T* p =
                   &data[ 0 ] )
        {
            _glBufferSubData( target, offsetCount * sizeof( T ), sizeof( T ) * data.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETBUFFERSUBDATAPROC( GLenum target, GLintptr offset, GLsizeiptr size, void* data );

    private PFNGLGETBUFFERSUBDATAPROC _glGetBufferSubData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return a subset of a buffer object's data store.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>,
    /// <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>, <see cref="IGL.GL_COPY_WRITE_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="offset">
    /// Specifies the offset into the buffer object's data store from which data will be returned,
    /// measured in bytes.
    /// </param>
    /// <param name="size">Specifies the size in bytes of the data store region being returned.</param>
    /// <param name="data">Specifies a pointer to the location where buffer object data is returned.</param>
    public void glGetBufferSubData( GLenum target, GLintptr offset, GLsizeiptr size, void* data )
    {
        _glGetBufferSubData( target, offset, size, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return a subset of a buffer object's data store.
    /// </summary>
    /// <typeparam name="T">The type of the data to be returned.</typeparam>
    /// <param name="target">
    /// Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>,
    /// <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>, <see cref="IGL.GL_COPY_WRITE_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="offsetCount">Specifies the offset into the buffer object's data store from which data will be returned.</param>
    /// <param name="count">Specifies the number of <typeparamref name="T"/>s to be returned.</param>
    /// <param name="data">An array of <typeparamref name="T"/>s that will be filled with the data from the buffer object.</param>
    public void glGetBufferSubData< T >( GLenum target, GLintptr offsetCount, GLsizei count, ref T[] data ) where T : unmanaged
    {
        fixed ( T* p =
                   &data[ 0 ] )
        {
            _glGetBufferSubData( target, offsetCount * sizeof( T ), sizeof( T ) * count, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void* PFNGLMAPBUFFERPROC( GLenum target, GLenum access );

    private PFNGLMAPBUFFERPROC _glMapBuffer;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Map a buffer object's data store into the client's address space.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>,
    /// <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>, <see cref="IGL.GL_COPY_WRITE_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="access">
    /// Specifies a combination of access flags indicating the desired access to the range of the buffer
    /// object's data store. One of <see cref="IGL.GL_READ_ONLY"/>, <see cref="IGL.GL_WRITE_ONLY"/> or
    /// <see cref="IGL.GL_READ_WRITE"/>.
    /// </param>
    /// <returns>Returns a pointer to the beginning of the mapped range.</returns>
    public void* glMapBuffer( GLenum target, GLenum access )
    {
        return _glMapBuffer( target, access );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Map a buffer object's data store into the client's address space.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>,
    /// <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>, <see cref="IGL.GL_COPY_WRITE_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="access">
    /// Specifies a combination of access flags indicating the desired access to the range of the buffer
    /// object's data store. One of <see cref="IGL.GL_READ_ONLY"/>, <see cref="IGL.GL_WRITE_ONLY"/> or
    /// <see cref="IGL.GL_READ_WRITE"/>.
    /// </param>
    /// <returns>Returns a type-safe and memory-safe <see cref="System.Span{T}"/> of the buffers data.</returns>
    public Span< T > glMapBuffer< T >( GLenum target, GLenum access ) where T : unmanaged
    {
        GLint size;
        _glGetBufferParameteriv( target, IGL.GL_BUFFER_SIZE, &size );

        void* ret = _glMapBuffer( target, access );

        return new Span< T >( ret, size / sizeof( T ) );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLUNMAPBUFFERPROC( GLenum target );

    private PFNGLUNMAPBUFFERPROC _glUnmapBuffer;

    /// <summary>
    /// Release a mapped buffer object's data store.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object being unmapped. The symbolic constant must be
    /// <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>
    /// , <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>, <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>,
    /// <see cref="IGL.GL_TEXTURE_BUFFER"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <returns>
    /// <see langword="true"/> unless the data store contents have become corrupt during the time the data store was
    /// mapped. This can occur for system-specific reasons that affect the availability of graphics memory, such as screen
    /// mode changes. In such situations, <see cref="glUnmapBuffer"/> may return <see langword="false"/> to indicate that
    /// the contents of the buffer have become corrupt and should be considered undefined. An application must detect this
    /// rare condition and reinitialize the data store.
    /// </returns>
    public GLboolean glUnmapBuffer( GLenum target )
    {
        return _glUnmapBuffer( target );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETBUFFERPARAMETERIVPROC( GLenum target, GLenum pname, GLint* @params );

    private PFNGLGETBUFFERPARAMETERIVPROC _glGetBufferParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a buffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a buffer object parameter. Accepted values are
    /// <see cref="IGL.GL_BUFFER_ACCESS"/>, <see cref="IGL.GL_BUFFER_MAPPED"/>, <see cref="IGL.GL_BUFFER_SIZE"/>,
    /// <see cref="IGL.GL_BUFFER_USAGE"/>.
    /// </param>
    /// <param name="params">A pointer to a memory location where the returned data will be placed.</param>
    public void glGetBufferParameteriv( GLenum target, GLenum pname, GLint* @params )
    {
        _glGetBufferParameteriv( target, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a buffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a buffer object parameter. Accepted values are
    /// <see cref="IGL.GL_BUFFER_ACCESS"/>, <see cref="IGL.GL_BUFFER_MAPPED"/>, <see cref="IGL.GL_BUFFER_SIZE"/>,
    /// <see cref="IGL.GL_BUFFER_USAGE"/>.
    /// </param>
    /// <param name="params">A <see langword="ref"/> to an integer array where the returned data will be placed.</param>
    public void glGetBufferParameteriv( GLenum target, GLenum pname, ref GLint[] @params )
    {
        fixed ( GLint* p =
                   &@params[ 0 ] )
        {
            _glGetBufferParameteriv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETBUFFERPOINTERVPROC( GLenum target, GLenum pname, void** @params );

    private PFNGLGETBUFFERPOINTERVPROC _glGetBufferPointerv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the pointer to a mapped buffer object's data store.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object being mapped. The symbolic constant must be
    /// <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>
    /// , <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>, <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>,
    /// <see cref="IGL.GL_TEXTURE_BUFFER"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="pname">Specifies the pointer to be returned. Accepted values are <see cref="IGL.GL_BUFFER_MAP_POINTER"/>.</param>
    /// <param name="params">A pointer to a memory location where the returned data will be placed.</param>
    public void glGetBufferPointerv( GLenum target, GLenum pname, void** @params )
    {
        _glGetBufferPointerv( target, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the pointer to a mapped buffer object's data store.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object being mapped. The symbolic constant must be
    /// <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>
    /// , <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>, <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>,
    /// <see cref="IGL.GL_TEXTURE_BUFFER"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="pname">Specifies the pointer to be returned. Accepted values are <see cref="IGL.GL_BUFFER_MAP_POINTER"/>.</param>
    /// <param name="params">
    /// A <see langword="ref"/> to an array of <see cref="IntPtr"/>s where the returned pointer(s) will
    /// be placed.
    /// </param>
    public void glGetBufferPointerv( GLenum target, GLenum pname, ref IntPtr[] @params )
    {
        fixed ( IntPtr* p =
                   &@params[ 0 ] )
        {
            _glGetBufferPointerv( target, pname, ( void** )p );
        }
    }
#endif

#endif

    // OpenGL 2.0

#if OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBLENDEQUATIONSEPARATEPROC( GLenum modeRGB, GLenum modeAlpha );

    private PFNGLBLENDEQUATIONSEPARATEPROC _glBlendEquationSeparate;

    /// <summary>
    /// Set the RGB blend equation and alpha blend equation separately
    /// </summary>
    /// <param name="modeRGB">
    /// Specifies the RGB blend equation, how the red, green, and blue components of the source and
    /// destination colors are combined. Must be <see cref="IGL.GL_FUNC_ADD"/>, <see cref="IGL.GL_FUNC_SUBTRACT"/>,
    /// <see cref="IGL.GL_FUNC_REVERSE_SUBTRACT"/>, <see cref="IGL.GL_MIN"/> or <see cref="IGL.GL_MAX"/>.
    /// </param>
    /// <param name="modeAlpha">
    /// Specifies the alpha blend equation, how the alpha component of the source and destination
    /// colors are combined. Must be <see cref="IGL.GL_FUNC_ADD"/>, <see cref="IGL.GL_FUNC_SUBTRACT"/>,
    /// <see cref="IGL.GL_FUNC_REVERSE_SUBTRACT"/>, <see cref="IGL.GL_MIN"/> or <see cref="IGL.GL_MAX"/>.
    /// </param>
    public void glBlendEquationSeparate( GLenum modeRGB, GLenum modeAlpha )
    {
        _glBlendEquationSeparate( modeRGB, modeAlpha );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDRAWBUFFERSPROC( GLsizei n, GLenum* bufs );

    private PFNGLDRAWBUFFERSPROC _glDrawBuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a list of color buffers to be drawn into
    /// </summary>
    /// <param name="n">Specifies the number of buffers in the list that follows.</param>
    /// <param name="bufs">
    /// Specifies a pointer to an array of symbolic constants specifying the buffers into which fragment
    /// colors or data values will be written. The symbolic constants must be <see cref="IGL.GL_NONE"/>,
    /// <see cref="IGL.GL_FRONT_LEFT"/>, <see cref="IGL.GL_FRONT_RIGHT"/>, <see cref="IGL.GL_BACK_LEFT"/>,
    /// <see cref="IGL.GL_BACK_RIGHT"/>, <see cref="IGL.GL_COLOR_ATTACHMENT0"/> through <see cref="IGL.GL_COLOR_ATTACHMENT31"/>.
    /// </param>
    public void glDrawBuffers( GLsizei n, GLenum* bufs )
    {
        _glDrawBuffers( n, bufs );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a list of color buffers to be drawn into
    /// </summary>
    /// <param name="bufs">
    /// Specifies an array of symbol constants specifying the buffers into which the fragment colors or data
    /// values will be written. The symbolic constants must be <see cref="IGL.GL_NONE"/>, <see cref="IGL.GL_FRONT_LEFT"/>,
    /// <see cref="IGL.GL_FRONT_RIGHT"/>, <see cref="IGL.GL_BACK_LEFT"/>, <see cref="IGL.GL_BACK_RIGHT"/>,
    /// <see cref="IGL.GL_COLOR_ATTACHMENT0"/> through <see cref="IGL.GL_COLOR_ATTACHMENT31"/>.
    /// </param>
    public void glDrawBuffers( params GLenum[] bufs )
    {
        fixed ( GLenum* pbufs = &bufs[ 0 ] )
        {
            _glDrawBuffers( bufs.Length, pbufs );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSTENCILOPSEPARATEPROC( GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass );

    private PFNGLSTENCILOPSEPARATEPROC _glStencilOpSeparate;

    /// <summary>
    /// Set front and back stencil test actions
    /// </summary>
    /// <param name="face">
    /// Specifies whether the stencil test applies to front and/or back-facing polygons, or both. Must be
    /// <see cref="IGL.GL_FRONT"/>, <see cref="IGL.GL_BACK"/> or <see cref="IGL.GL_FRONT_AND_BACK"/>.
    /// </param>
    /// <param name="sfail">
    /// Specifies the action to take when the stencil test fails. Must be <see cref="IGL.GL_KEEP"/>,
    /// <see cref="IGL.GL_ZERO"/>, <see cref="IGL.GL_REPLACE"/>, <see cref="IGL.GL_INCR"/>, <see cref="IGL.GL_INCR_WRAP"/>,
    /// <see cref="IGL.GL_DECR"/>, <see cref="IGL.GL_DECR_WRAP"/> or <see cref="IGL.GL_INVERT"/>.
    /// </param>
    /// <param name="dpfail">
    /// Specifies the stencil action when the stencil test passes, but the depth test fails.
    /// <paramref name="dpfail"/> accepts the same symbolic constants as <paramref name="sfail"/>.
    /// </param>
    /// <param name="dppass">
    /// Specifies the stencil action when both the stencil test and the depth test pass, or when the
    /// stencil test passes and either there is no depth buffer or depth testing is not enabled. <paramref name="dppass"/>
    /// accepts the same symbolic constants as <paramref name="sfail"/>.
    /// </param>
    public void glStencilOpSeparate( GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass )
    {
        _glStencilOpSeparate( face, sfail, dpfail, dppass );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSTENCILFUNCSEPARATEPROC( GLenum face, GLenum func, GLint @ref, GLuint mask );

    private PFNGLSTENCILFUNCSEPARATEPROC _glStencilFuncSeparate;

    /// <summary>
    /// Set front and/or back function and reference value for stencil testing
    /// </summary>
    /// <param name="face">
    /// Specifies whether the stencil test applies to front and/or back-facing polygons, or both. Must be
    /// <see cref="IGL.GL_FRONT"/>, <see cref="IGL.GL_BACK"/> or <see cref="IGL.GL_FRONT_AND_BACK"/>.
    /// </param>
    /// <param name="func">
    /// Specifies the test function. Eight symbolic constants are accepted: <see cref="IGL.GL_NEVER"/>,
    /// <see cref="IGL.GL_LESS"/>, <see cref="IGL.GL_LEQUAL"/>, <see cref="IGL.GL_GREATER"/>, <see cref="IGL.GL_GEQUAL"/>,
    /// <see cref="IGL.GL_EQUAL"/>, <see cref="IGL.GL_NOTEQUAL"/> and <see cref="IGL.GL_ALWAYS"/>. The initial value is
    /// <see cref="IGL.GL_ALWAYS"/>.
    /// </param>
    /// <param name="ref">
    /// Specifies the reference value for the stencil test. <paramref name="ref"/> is clamped to the range
    /// [0, 2^n - 1], where n is the number of bitplanes in the stencil buffer. The initial value is 0.
    /// </param>
    /// <param name="mask">
    /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the
    /// test is done. The initial value is all 1's.
    /// </param>
    public void glStencilFuncSeparate( GLenum face, GLenum func, GLint @ref, GLuint mask )
    {
        _glStencilFuncSeparate( face, func, @ref, mask );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSTENCILMASKSEPARATEPROC( GLenum face, GLuint mask );

    private PFNGLSTENCILMASKSEPARATEPROC _glStencilMaskSeparate;

    /// <summary>
    /// Control the front and back writing of individual bits in the stencil planes
    /// </summary>
    /// <param name="face">
    /// Specifies whether the stencil writemask applies to front and/or back-facing polygons, or both. Must
    /// be <see cref="IGL.GL_FRONT"/>, <see cref="IGL.GL_BACK"/> or <see cref="IGL.GL_FRONT_AND_BACK"/>.
    /// </param>
    /// <param name="mask">
    /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes.
    /// Initially, the mask is all 1's.
    /// </param>
    public void glStencilMaskSeparate( GLenum face, GLuint mask )
    {
        _glStencilMaskSeparate( face, mask );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLATTACHSHADERPROC( GLuint program, GLuint shader );

    private PFNGLATTACHSHADERPROC _glAttachShader;

    /// <summary>
    /// Attaches a shader object to a program object
    /// </summary>
    /// <param name="program">Specifies the program object to which a shader object will be attached.</param>
    /// <param name="shader">Specifies the shader object that is to be attached.</param>
    public void glAttachShader( GLuint program, GLuint shader )
    {
        _glAttachShader( program, shader );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDATTRIBLOCATIONPROC( GLuint program, GLuint index, GLchar* name );

    private PFNGLBINDATTRIBLOCATIONPROC _glBindAttribLocation;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Associates a generic vertex attribute index with a named attribute variable. This is typically replaced with the
    /// <c>location</c> layout qualifier in the vertex shader.
    /// </summary>
    /// <param name="program">Specifies the program object in which the association is to be made.</param>
    /// <param name="index">Specifies the index of the generic vertex attribute to be bound.</param>
    /// <param name="name">
    /// Specifies a null terminated string containing the name of the vertex shader attribute variable to
    /// which index is to be bound.
    /// </param>
    public void glBindAttribLocation( GLuint program, GLuint index, GLchar* name )
    {
        _glBindAttribLocation( program, index, name );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Associates a generic vertex attribute index with a named attribute variable. This is typically replaced with the
    /// <c>location</c> layout qualifier in the vertex shader.
    /// </summary>
    /// <param name="program">Specifies the program object in which the association is to be made.</param>
    /// <param name="index">Specifies the index of the generic vertex attribute to be bound.</param>
    /// <param name="name">
    /// Specifies a string containing the name of the vertex shader attribute variable to which index is to
    /// be bound.
    /// </param>
    public void glBindAttribLocation( GLuint program, GLuint index, string name )
    {
        var utf8 = Encoding.UTF8.GetBytes( name );

        fixed ( byte* putf8 = &utf8[ 0 ] )
        {
            _glBindAttribLocation( program, index, putf8 );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOMPILESHADERPROC( GLuint shader );

    private PFNGLCOMPILESHADERPROC _glCompileShader;

    /// <summary>
    /// Compiles a shader object
    /// </summary>
    /// <param name="shader">Specifies the shader object to be compiled.</param>
    public void glCompileShader( GLuint shader )
    {
        _glCompileShader( shader );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLuint PFNGLCREATEPROGRAMPROC();

    private PFNGLCREATEPROGRAMPROC _glCreateProgram;

    /// <summary>
    /// Creates a program object
    /// </summary>
    /// <returns>The name of the program object created.</returns>
    public GLuint glCreateProgram()
    {
        return _glCreateProgram();
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLuint PFNGLCREATESHADERPROC( GLenum type );

    private PFNGLCREATESHADERPROC _glCreateShader;

    /// <summary>
    /// Creates a shader object
    /// </summary>
    /// <param name="type">
    /// Specifies the type of shader to be created. Must be <see cref="IGL.GL_COMPUTE_SHADER"/>,
    /// <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>,
    /// <see cref="IGL.GL_GEOMETRY_SHADER"/> or <see cref="IGL.GL_FRAGMENT_SHADER"/>.
    /// </param>
    /// <returns>The name of the shader object created.</returns>
    public GLuint glCreateShader( GLenum type )
    {
        return _glCreateShader( type );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDELETEPROGRAMPROC( GLuint program );

    private PFNGLDELETEPROGRAMPROC _glDeleteProgram;

    /// <summary>
    /// Deletes a program object
    /// </summary>
    /// <param name="program">Specifies the program object to be deleted.</param>
    public void glDeleteProgram( GLuint program )
    {
        _glDeleteProgram( program );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDELETESHADERPROC( GLuint shader );

    private PFNGLDELETESHADERPROC _glDeleteShader;

    /// <summary>
    /// Deletes a shader object
    /// </summary>
    /// <param name="shader">Specifies the shader object to be deleted.</param>
    public void glDeleteShader( GLuint shader )
    {
        _glDeleteShader( shader );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDETACHSHADERPROC( GLuint program, GLuint shader );

    private PFNGLDETACHSHADERPROC _glDetachShader;

    /// <summary>
    /// Detaches a shader object from a program object
    /// </summary>
    /// <param name="program">Specifies the program object from which to detach the shader object.</param>
    /// <param name="shader">Specifies the shader object to be detached.</param>
    public void glDetachShader( GLuint program, GLuint shader )
    {
        _glDetachShader( program, shader );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDISABLEVERTEXATTRIBARRAYPROC( GLuint index );

    private PFNGLDISABLEVERTEXATTRIBARRAYPROC _glDisableVertexAttribArray;

    /// <summary>
    /// Disables a generic vertex attribute array
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be disabled.</param>
    public void glDisableVertexAttribArray( GLuint index )
    {
        _glDisableVertexAttribArray( index );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLENABLEVERTEXATTRIBARRAYPROC( GLuint index );

    private PFNGLENABLEVERTEXATTRIBARRAYPROC _glEnableVertexAttribArray;

    /// <summary>
    /// Enables a generic vertex attribute array
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be enabled.</param>
    public void glEnableVertexAttribArray( GLuint index )
    {
        _glEnableVertexAttribArray( index );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETACTIVEATTRIBPROC( GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name );

    private PFNGLGETACTIVEATTRIBPROC _glGetActiveAttrib;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns information about an active attribute variable for the specified program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="index">Specifies the index of the attribute variable to be queried.</param>
    /// <param name="bufSize">
    /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
    /// indicated by name (excluding the null terminator) when information about the variable name is returned.
    /// </param>
    /// <param name="length">
    /// Returns the number of characters actually written by OpenGL in the string indicated by name
    /// (excluding the null terminator) if a value other than NULL is passed.
    /// </param>
    /// <param name="size">
    /// Returns the size of the attribute variable that is written into size if a value other than NULL is
    /// passed.
    /// </param>
    /// <param name="type">
    /// Returns the data type of the attribute variable that is written into type if a value other than NULL
    /// is passed.
    /// </param>
    /// <param name="name">Returns a null-terminated string containing the name of the attribute variable.</param>
    public void glGetActiveAttrib( GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name )
    {
        _glGetActiveAttrib( program, index, bufSize, length, size, type, name );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns information about an active attribute variable for the specified program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="index">Specifies the index of the attribute variable to be queried.</param>
    /// <param name="bufSize">
    /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
    /// indicated by name (excluding the null terminator) when information about the variable name is returned.
    /// </param>
    /// <param name="size">Returns the size of the attribute variable.</param>
    /// <param name="type">Returns the data type of the attribute variable.</param>
    /// <returns>Returns a managed string containing the name of the attribute variable.</returns>
    public string glGetActiveAttrib( GLuint program, GLuint index, GLsizei bufSize, out GLint size, out GLenum type )
    {
        var     name = stackalloc GLchar[ bufSize ];
        GLsizei len;

        fixed ( GLenum* ptype = &type )
        {
            fixed ( GLint* psize = &size )
            {
                _glGetActiveAttrib( program, index, bufSize, &len, psize, ptype, name );
            }
        }

        return new string( ( sbyte* )name, 0, len, Encoding.UTF8 );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETACTIVEUNIFORMPROC( GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name );

    private PFNGLGETACTIVEUNIFORMPROC _glGetActiveUniform;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns information about an active uniform variable for the specified program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="index">Specifies the index of the uniform variable to be queried.</param>
    /// <param name="bufSize">
    /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
    /// indicated by name (excluding the null terminator) when information about the variable name is returned.
    /// </param>
    /// <param name="length">
    /// Returns the number of characters actually written by OpenGL in the string indicated by name
    /// (excluding the null terminator) if a value other than NULL is passed.
    /// </param>
    /// <param name="size">
    /// Returns the size of the uniform variable that is written into size if a value other than NULL is
    /// passed.
    /// </param>
    /// <param name="type">
    /// Returns the data type of the uniform variable that is written into type if a value other than NULL
    /// is passed.
    /// </param>
    /// <param name="name">Returns a null-terminated string containing the name of the uniform variable.</param>
    public void glGetActiveUniform( GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name )
    {
        _glGetActiveUniform( program, index, bufSize, length, size, type, name );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns information about an active uniform variable for the specified program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="index">Specifies the index of the uniform variable to be queried.</param>
    /// <param name="bufSize">
    /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
    /// indicated by name (excluding the null terminator) when information about the variable name is returned.
    /// </param>
    /// <param name="size">Returns the size of the uniform variable.</param>
    /// <param name="type">Returns the data type of the uniform variable.</param>
    /// <returns>Returns a managed string containing the name of the uniform variable.</returns>
    public string glGetActiveUniform( GLuint program, GLuint index, GLsizei bufSize, out GLint size, out GLenum type )
    {
        var     name = stackalloc GLchar[ bufSize ];
        GLsizei len;

        fixed ( GLenum* ptype = &type )
        {
            fixed ( GLint* psize = &size )
            {
                _glGetActiveUniform( program, index, bufSize, &len, psize, ptype, name );
            }
        }

        return new string( ( sbyte* )name, 0, len, Encoding.UTF8 );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETATTACHEDSHADERSPROC( GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders );

    private PFNGLGETATTACHEDSHADERSPROC _glGetAttachedShaders;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the shader objects attached to program
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="maxCount">Specifies the size of the array for storing object names.</param>
    /// <param name="count">Returns the number of names actually returned in shaders.</param>
    /// <param name="shaders">Returns the names of the shader objects attached to program.</param>
    public void glGetAttachedShaders( GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders )
    {
        _glGetAttachedShaders( program, maxCount, count, shaders );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the shader objects attached to program
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="maxCount">Specifies a maximum amount of shaders to return.</param>
    /// <returns>Returns an array of shader objects attached to program resized to the amount of shaders actually attached.</returns>
    public GLuint[] glGetAttachedShaders( GLuint program, GLsizei maxCount )
    {
        var     shaders = new GLuint[ maxCount ];
        GLsizei count;

        fixed ( GLuint* pshaders = &shaders[ 0 ] )
        {
            _glGetAttachedShaders( program, maxCount, &count, pshaders );
        }

        Array.Resize( ref shaders, count );

        return shaders;
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLint PFNGLGETATTRIBLOCATIONPROC( GLuint program, GLchar* name );

    private PFNGLGETATTRIBLOCATIONPROC _glGetAttribLocation;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the location of an attribute variable
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="name">Specifies the name of the attribute variable whose location is to be queried.</param>
    /// <returns>
    /// Returns the location of the attribute variable name if it is found in program. If name starts with the
    /// reserved prefix "gl_", a location of -1 is returned.
    /// </returns>
    public GLint glGetAttribLocation( GLuint program, GLchar* name )
    {
        return _glGetAttribLocation( program, name );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the location of an attribute variable
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="name">Specifies the name of the attribute variable whose location is to be queried.</param>
    /// <returns>
    /// Returns the location of the attribute variable name if it is found in program. If name starts with the
    /// reserved prefix "gl_", a location of -1 is returned.
    /// </returns>
    public GLint glGetAttribLocation( GLuint program, string name )
    {
        fixed ( GLchar* pname = Encoding.UTF8.GetBytes( name ) )
        {
            return _glGetAttribLocation( program, pname );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETPROGRAMIVPROC( GLuint program, GLenum pname, GLint* @params );

    private PFNGLGETPROGRAMIVPROC _glGetProgramiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns a parameter from a program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="pname">
    /// Specifies the object parameter to query. Refer to <see href="https://docs.gl/gl4/glGetProgram"/>
    /// for a list of possible values.
    /// </param>
    /// <param name="params">Returns the requested object parameter.</param>
    public void glGetProgramiv( GLuint program, GLenum pname, GLint* @params )
    {
        _glGetProgramiv( program, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns a parameter from a program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="pname">
    /// Specifies the object parameter to query. Refer to <see href="https://docs.gl/gl4/glGetProgram"/>
    /// for a list of possible values.
    /// </param>
    /// <param name="params">A <see langword="ref"/> to an integer array where the returned value(s) will be placed.</param>
    public void glGetProgramiv( GLuint program, GLenum pname, ref GLint[] @params )
    {
        fixed ( GLint* pparams =
                   &@params[ 0 ] )
        {
            _glGetProgramiv( program, pname, pparams );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETPROGRAMINFOLOGPROC( GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog );

    private PFNGLGETPROGRAMINFOLOGPROC _glGetProgramInfoLog;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the information log for a program object
    /// </summary>
    /// <param name="program">Specifies the program object whose information log is to be queried.</param>
    /// <param name="bufSize">Specifies the size of the character buffer for storing the returned information log.</param>
    /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
    /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
    public void glGetProgramInfoLog( GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog )
    {
        _glGetProgramInfoLog( program, bufSize, length, infoLog );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the information log for a program object
    /// </summary>
    /// <param name="program">Specifies the program object whose information log is to be queried.</param>
    /// <param name="bufSize">Specifies the size of the character buffer for storing the returned information log.</param>
    /// <returns>Returns the information log for <paramref name="program"/>, resized to the correct length.</returns>
    public string glGetProgramInfoLog( GLuint program, GLsizei bufSize )
    {
        var     infoLog = stackalloc GLchar[ bufSize ];
        GLsizei len;
        _glGetProgramInfoLog( program, bufSize, &len, infoLog );

        return new string( ( sbyte* )infoLog, 0, len, Encoding.UTF8 );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETSHADERIVPROC( GLuint shader, GLenum pname, GLint* @params );

    private PFNGLGETSHADERIVPROC _glGetShaderiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns a parameter from a shader object
    /// </summary>
    /// <param name="shader">Specifies the shader object to be queried.</param>
    /// <param name="pname">
    /// Specifies the object parameter to query. Accepted symbolic names are <see cref="IGL.GL_SHADER_TYPE"/>,
    /// <see cref="IGL.GL_DELETE_STATUS"/>, <see cref="IGL.GL_COMPILE_STATUS"/>, <see cref="IGL.GL_INFO_LOG_LENGTH"/>,
    /// <see cref="IGL.GL_SHADER_SOURCE_LENGTH"/>.
    /// </param>
    /// <param name="params">Returns the requested object parameter.</param>
    public void glGetShaderiv( GLuint shader, GLenum pname, GLint* @params )
    {
        _glGetShaderiv( shader, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns a parameter from a shader object
    /// </summary>
    /// <param name="shader">Specifies the shader object to be queried.</param>
    /// <param name="pname">
    /// Specifies the object parameter to query. Accepted symbolic names are <see cref="IGL.GL_SHADER_TYPE"/>,
    /// <see cref="IGL.GL_DELETE_STATUS"/>, <see cref="IGL.GL_COMPILE_STATUS"/>, <see cref="IGL.GL_INFO_LOG_LENGTH"/>,
    /// <see cref="IGL.GL_SHADER_SOURCE_LENGTH"/>.
    /// </param>
    /// <param name="params">A <see langword="ref"/> to an integer array where the returned value(s) will be placed.</param>
    public void glGetShaderiv( GLuint shader, GLenum pname, ref GLint[] @params )
    {
        fixed ( GLint* pparams =
                   &@params[ 0 ] )
        {
            _glGetShaderiv( shader, pname, pparams );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETSHADERINFOLOGPROC( GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog );

    private PFNGLGETSHADERINFOLOGPROC _glGetShaderInfoLog;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the information log for a shader object
    /// </summary>
    /// <param name="shader">Specifies the shader object whose information log is to be queried.</param>
    /// <param name="bufSize">Specifies the size of the character buffer for storing the returned information log.</param>
    /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
    /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
    public void glGetShaderInfoLog( GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog )
    {
        _glGetShaderInfoLog( shader, bufSize, length, infoLog );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the information log for a shader object
    /// </summary>
    /// <param name="shader">Specifies the shader object whose information log is to be queried.</param>
    /// <param name="bufSize">Specifies the size of the character buffer for storing the returned information log.</param>
    /// <returns>Returns the information log for <paramref name="shader"/>, resized to the correct length.</returns>
    public string glGetShaderInfoLog( GLuint shader, GLsizei bufSize )
    {
        var     infoLog = stackalloc GLchar[ bufSize ];
        GLsizei len;
        _glGetShaderInfoLog( shader, bufSize, &len, infoLog );

        return new string( ( sbyte* )infoLog, 0, len, Encoding.UTF8 );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETSHADERSOURCEPROC( GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source );

    private PFNGLGETSHADERSOURCEPROC _glGetShaderSource;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the source code string from a shader object
    /// </summary>
    /// <param name="shader">Specifies the shader object to be queried.</param>
    /// <param name="bufSize">Specifies the size of the character buffer for storing the returned source code string.</param>
    /// <param name="length">Returns the length of the string returned in source (excluding the null terminator).</param>
    /// <param name="source">Specifies an array of characters that is used to return the source code string.</param>
    public void glGetShaderSource( GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source )
    {
        _glGetShaderSource( shader, bufSize, length, source );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the source code string from a shader object
    /// </summary>
    /// <param name="shader">Specifies the shader object to be queried.</param>
    /// <param name="bufSize">Specifies the size of the character buffer for storing the returned source code string.</param>
    /// <returns>Returns the source code string for <paramref name="shader"/>, resized to the correct length.</returns>
    public string glGetShaderSource( GLuint shader, GLsizei bufSize = 4096 )
    {
        var     source = stackalloc GLchar[ bufSize ];
        GLsizei len;
        _glGetShaderSource( shader, bufSize, &len, source );

        return new string( ( sbyte* )source, 0, len, Encoding.UTF8 );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLint PFNGLGETUNIFORMLOCATIONPROC( GLuint program, GLchar* name );

    private PFNGLGETUNIFORMLOCATIONPROC _glGetUniformLocation;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the location of a uniform variable
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="name">
    /// Points to a null terminated string containing the name of the uniform variable whose location is to
    /// be queried.
    /// </param>
    public GLint glGetUniformLocation( GLuint program, GLchar* name )
    {
        return _glGetUniformLocation( program, name );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the location of a uniform variable
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="name">A string containing the name of the uniform variable whose location is to be queried.</param>
    public GLint glGetUniformLocation( GLuint program, string name )
    {
        fixed ( byte* pname = Encoding.UTF8.GetBytes( name ) )
        {
            return _glGetUniformLocation( program, pname );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETUNIFORMFVPROC( GLuint program, GLint location, GLfloat* @params );

    private PFNGLGETUNIFORMFVPROC _glGetUniformfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the value of a uniform variable
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
    /// <param name="params">Returns the value of the uniform variable at the location specified by location.</param>
    public void glGetUniformfv( GLuint program, GLint location, GLfloat* @params )
    {
        _glGetUniformfv( program, location, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the value of a uniform variable
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
    /// <param name="params">
    /// A <see langword="ref"/> to an array to receive the value of the uniform variable at the location
    /// specified by location.
    /// </param>
    public void glGetUniformfv( GLuint program, GLint location, ref GLfloat[] @params )
    {
        fixed ( GLfloat* pparams =
                   &@params[ 0 ] )
        {
            _glGetUniformfv( program, location, pparams );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETUNIFORMIVPROC( GLuint program, GLint location, GLint* @params );

    private PFNGLGETUNIFORMIVPROC _glGetUniformiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the value of a uniform variable
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
    /// <param name="params">Returns the value of the uniform variable at the location specified by location.</param>
    public void glGetUniformiv( GLuint program, GLint location, GLint* @params )
    {
        _glGetUniformiv( program, location, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the value of a uniform variable
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
    /// <param name="params">
    /// A <see langword="ref"/> to an array to receive the value of the uniform variable at the location
    /// specified by location.
    /// </param>
    public void glGetUniformiv( GLuint program, GLint location, ref GLint[] @params )
    {
        fixed ( GLint* pparams =
                   &@params[ 0 ] )
        {
            _glGetUniformiv( program, location, pparams );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETVERTEXATTRIBDVPROC( GLuint index, GLenum pname, GLdouble* @params );

    private PFNGLGETVERTEXATTRIBDVPROC _glGetVertexAttribdv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the value of a generic vertex attribute parameter
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute parameter to be queried.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are:
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>,
    /// <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>
    /// </param>
    /// <param name="params">
    /// Returns the value of the generic vertex attribute parameter specified by pname for the vertex
    /// attribute specified by index.
    /// </param>
    public void glGetVertexAttribdv( GLuint index, GLenum pname, GLdouble* @params )
    {
        _glGetVertexAttribdv( index, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the value of a generic vertex attribute parameter
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute parameter to be queried.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are:
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>,
    /// <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>
    /// </param>
    /// <param name="params">
    /// A <see langword="ref"/> to an array to receive the value of the generic vertex attribute
    /// parameter specified by pname for the vertex attribute specified by index.
    /// </param>
    public void glGetVertexAttribdv( GLuint index, GLenum pname, ref GLdouble[] @params )
    {
        fixed ( GLdouble* pparams =
                   &@params[ 0 ] )
        {
            _glGetVertexAttribdv( index, pname, pparams );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETVERTEXATTRIBFVPROC( GLuint index, GLenum pname, GLfloat* @params );

    private PFNGLGETVERTEXATTRIBFVPROC _glGetVertexAttribfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the value of a generic vertex attribute parameter
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute parameter to be queried.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are:
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>,
    /// <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>
    /// </param>
    /// <param name="params">
    /// Returns the value of the generic vertex attribute parameter specified by pname for the vertex
    /// attribute specified by index.
    /// </param>
    public void glGetVertexAttribfv( GLuint index, GLenum pname, GLfloat* @params )
    {
        _glGetVertexAttribfv( index, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the value of a generic vertex attribute parameter
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute parameter to be queried.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are:
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>,
    /// <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>
    /// </param>
    /// <param name="params">
    /// A <see langword="ref"/> to an array to receive the value of the generic vertex attribute
    /// parameter specified by pname for the vertex attribute specified by index.
    /// </param>
    public void glGetVertexAttribfv( GLuint index, GLenum pname, ref GLfloat[] @params )
    {
        fixed ( GLfloat* pparams =
                   &@params[ 0 ] )
        {
            _glGetVertexAttribfv( index, pname, pparams );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETVERTEXATTRIBIVPROC( GLuint index, GLenum pname, GLint* @params );

    private PFNGLGETVERTEXATTRIBIVPROC _glGetVertexAttribiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the value of a generic vertex attribute parameter
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute parameter to be queried.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are:
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>,
    /// <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>
    /// </param>
    /// <param name="params">
    /// Returns the value of the generic vertex attribute parameter specified by pname for the vertex
    /// attribute specified by index.
    /// </param>
    public void glGetVertexAttribiv( GLuint index, GLenum pname, GLint* @params )
    {
        _glGetVertexAttribiv( index, pname, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the value of a generic vertex attribute parameter
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute parameter to be queried.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are:
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>,
    /// <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>
    /// </param>
    /// <param name="params">
    /// A <see langword="ref"/> to an array to receive the value of the generic vertex attribute
    /// parameter specified by pname for the vertex attribute specified by index.
    /// </param>
    public void glGetVertexAttribiv( GLuint index, GLenum pname, ref GLint[] @params )
    {
        fixed ( GLint* pparams =
                   &@params[ 0 ] )
        {
            _glGetVertexAttribiv( index, pname, pparams );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETVERTEXATTRIBPOINTERVPROC( GLuint index, GLenum pname, void** pointer );

    private PFNGLGETVERTEXATTRIBPOINTERVPROC _glGetVertexAttribPointerv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the address of the specified generic vertex attribute pointer
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute pointer to be returned.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the generic vertex attribute pointer to be returned. Accepted values
    /// are: <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_POINTER"/>
    /// </param>
    /// <param name="pointer">Returns the address of the specified generic vertex attribute pointer.</param>
    public void glGetVertexAttribPointerv( GLuint index, GLenum pname, void** pointer )
    {
        _glGetVertexAttribPointerv( index, pname, pointer );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the address of the specified generic vertex attribute pointer
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute pointer to be returned.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the generic vertex attribute pointer to be returned. Accepted values
    /// are: <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_POINTER"/>
    /// </param>
    /// <param name="pointer">
    /// A <see langword="ref"/> to an array to receive the address of the specified generic vertex
    /// attribute pointer.
    /// </param>
    public void glGetVertexAttribPointerv( GLuint index, GLenum pname, ref uint[] pointer )
    {
        var ptr = new void*[ pointer.Length ];

        fixed ( void** p = &ptr[ 0 ] )
        {
            _glGetVertexAttribPointerv( index, pname, p );
        }

        for ( var i = 0; i < pointer.Length; i++ )
        {
            pointer[ i ] = ( uint )ptr[ i ];
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISPROGRAMPROC( GLuint program );

    private PFNGLISPROGRAMPROC _glIsProgram;

    /// <summary>
    /// Determines if a name corresponds to a program object
    /// </summary>
    /// <param name="program">Specifies a potential program object.</param>
    /// <returns>
    /// <see langword="true"/> if program is currently the name of a program object. <see langword="false"/>
    /// otherwise.
    /// </returns>
    public GLboolean glIsProgram( GLuint program )
    {
        return _glIsProgram( program );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISSHADERPROC( GLuint shader );

    private PFNGLISSHADERPROC _glIsShader;

    /// <summary>
    /// Determines if a name corresponds to a shader object
    /// </summary>
    /// <param name="shader">Specifies a potential shader object.</param>
    /// <returns>
    /// <see langword="true"/> if shader is currently the name of a shader object. <see langword="false"/>
    /// otherwise.
    /// </returns>
    public GLboolean glIsShader( GLuint shader )
    {
        return _glIsShader( shader );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLLINKPROGRAMPROC( GLuint program );

    private PFNGLLINKPROGRAMPROC _glLinkProgram;

    /// <summary>
    /// Links a program object
    /// </summary>
    /// <param name="program">Specifies the handle of the program object to be linked.</param>
    public void glLinkProgram( GLuint program )
    {
        _glLinkProgram( program );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSHADERSOURCEPROC( GLuint shader, GLsizei count, GLchar** @string, GLint* length );

    private PFNGLSHADERSOURCEPROC _glShaderSource;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Replaces the source code in a shader object
    /// </summary>
    /// <param name="shader">Specifies the handle of the shader object whose source code is to be replaced.</param>
    /// <param name="count">
    /// Specifies the number of elements in the <paramref name="string"/> and <paramref name="length"/>
    /// arrays.
    /// </param>
    /// <param name="string">Specifies an array of pointers to strings containing the source code to be loaded into the shader.</param>
    /// <param name="length">Specifies an array of string lengths.</param>
    public void glShaderSource( GLuint shader, GLsizei count, GLchar** @string, GLint* length )
    {
        _glShaderSource( shader, count, @string, length );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Replaces the source code in a shader object
    /// </summary>
    /// <param name="shader">Specifies the handle of the shader object whose source code is to be replaced.</param>
    /// <param name="string">Specifies an array of strings containing the source code to be loaded into the shader.</param>
    public void glShaderSource( GLuint shader, params string[] @string )
    {
        var count   = @string.Length;
        var strings = new GLchar[ count ][];
        var lengths = new GLint[ count ];

        for ( var i = 0; i < count; i++ )
        {
            strings[ i ] = Encoding.UTF8.GetBytes( @string[ i ] );
            lengths[ i ] = @string[ i ].Length;
        }

        var pstring = stackalloc GLchar*[ count ];
        var length  = stackalloc GLint[ count ];

        for ( var i = 0; i < count; i++ )
        {
            fixed ( GLchar* p = &strings[ i ][ 0 ] )
            {
                pstring[ i ] = p;
            }

            length[ i ] = lengths[ i ];
        }

        _glShaderSource( shader, count, pstring, length );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUSEPROGRAMPROC( GLuint program );

    private PFNGLUSEPROGRAMPROC _glUseProgram;

    /// <summary>
    /// Installs a program object as part of current rendering state
    /// </summary>
    /// <param name="program">
    /// Specifies the handle of the program object whose executables are to be used as part of current
    /// rendering state.
    /// </param>
    public void glUseProgram( GLuint program )
    {
        _glUseProgram( program );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM1FPROC( GLint location, GLfloat v0 );

    private PFNGLUNIFORM1FPROC _glUniform1f;

    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="v0">Specifies the new value to be used for the uniform variable at location <paramref name="location"/>.</param>
    public void glUniform1f( GLint location, GLfloat v0 )
    {
        _glUniform1f( location, v0 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM2FPROC( GLint location, GLfloat v0, GLfloat v1 );

    private PFNGLUNIFORM2FPROC _glUniform2f;

    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="v0">
    /// Specifies the first new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v1">
    /// Specifies the second new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    public void glUniform2f( GLint location, GLfloat v0, GLfloat v1 )
    {
        _glUniform2f( location, v0, v1 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM3FPROC( GLint location, GLfloat v0, GLfloat v1, GLfloat v2 );

    private PFNGLUNIFORM3FPROC _glUniform3f;

    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="v0">
    /// Specifies the first new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v1">
    /// Specifies the second new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v2">
    /// Specifies the third new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    public void glUniform3f( GLint location, GLfloat v0, GLfloat v1, GLfloat v2 )
    {
        _glUniform3f( location, v0, v1, v2 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM4FPROC( GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3 );

    private PFNGLUNIFORM4FPROC _glUniform4f;

    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="v0">
    /// Specifies the first new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v1">
    /// Specifies the second new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v2">
    /// Specifies the third new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v3">
    /// Specifies the fourth new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    public void glUniform4f( GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3 )
    {
        _glUniform4f( location, v0, v1, v2, v3 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM1IPROC( GLint location, GLint v0 );

    private PFNGLUNIFORM1IPROC _glUniform1i;

    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="v0">Specifies the new value to be used for the uniform variable at location <paramref name="location"/>.</param>
    public void glUniform1i( GLint location, GLint v0 )
    {
        _glUniform1i( location, v0 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM2IPROC( GLint location, GLint v0, GLint v1 );

    private PFNGLUNIFORM2IPROC _glUniform2i;

    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="v0">
    /// Specifies the first new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v1">
    /// Specifies the second new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    public void glUniform2i( GLint location, GLint v0, GLint v1 )
    {
        _glUniform2i( location, v0, v1 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM3IPROC( GLint location, GLint v0, GLint v1, GLint v2 );

    private PFNGLUNIFORM3IPROC _glUniform3i;

    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="v0">
    /// Specifies the first new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v1">
    /// Specifies the second new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v2">
    /// Specifies the third new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    public void glUniform3i( GLint location, GLint v0, GLint v1, GLint v2 )
    {
        _glUniform3i( location, v0, v1, v2 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM4IPROC( GLint location, GLint v0, GLint v1, GLint v2, GLint v3 );

    private PFNGLUNIFORM4IPROC _glUniform4i;

    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="v0">
    /// Specifies the first new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v1">
    /// Specifies the second new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v2">
    /// Specifies the third new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    /// <param name="v3">
    /// Specifies the fourth new value to be used for the uniform variable at location
    /// <paramref name="location"/>.
    /// </param>
    public void glUniform4i( GLint location, GLint v0, GLint v1, GLint v2, GLint v3 )
    {
        _glUniform4i( location, v0, v1, v2, v3 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM1FVPROC( GLint location, GLsizei count, GLfloat* value );

    private PFNGLUNIFORM1FVPROC _glUniform1fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform1fv( GLint location, GLsizei count, GLfloat* value )
    {
        _glUniform1fv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    public void glUniform1fv( GLint location, params GLfloat[] value )
    {
        fixed ( GLfloat* p = &value[ 0 ] )
        {
            _glUniform1fv( location, value.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM2FVPROC( GLint location, GLsizei count, GLfloat* value );

    private PFNGLUNIFORM2FVPROC _glUniform2fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform2fv( GLint location, GLsizei count, GLfloat* value )
    {
        _glUniform2fv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform2fv( GLint location, params GLfloat[] value )
    {
        fixed ( GLfloat* p = &value[ 0 ] )
        {
            _glUniform2fv( location, value.Length / 2, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM3FVPROC( GLint location, GLsizei count, GLfloat* value );

    private PFNGLUNIFORM3FVPROC _glUniform3fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform3fv( GLint location, GLsizei count, GLfloat* value )
    {
        _glUniform3fv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform3fv( GLint location, params GLfloat[] value )
    {
        fixed ( GLfloat* p = &value[ 0 ] )
        {
            _glUniform3fv( location, value.Length / 3, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM4FVPROC( GLint location, GLsizei count, GLfloat* value );

    private PFNGLUNIFORM4FVPROC _glUniform4fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform4fv( GLint location, GLsizei count, GLfloat* value )
    {
        _glUniform4fv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform4fv( GLint location, params GLfloat[] value )
    {
        fixed ( GLfloat* p = &value[ 0 ] )
        {
            _glUniform4fv( location, value.Length / 4, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM1IVPROC( GLint location, GLsizei count, GLint* value );

    private PFNGLUNIFORM1IVPROC _glUniform1iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform1iv( GLint location, GLsizei count, GLint* value )
    {
        _glUniform1iv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform1iv( GLint location, params GLint[] value )
    {
        fixed ( GLint* p = &value[ 0 ] )
        {
            _glUniform1iv( location, value.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM2IVPROC( GLint location, GLsizei count, GLint* value );

    private PFNGLUNIFORM2IVPROC _glUniform2iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform2iv( GLint location, GLsizei count, GLint* value )
    {
        _glUniform2iv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform2iv( GLint location, params GLint[] value )
    {
        fixed ( GLint* p = &value[ 0 ] )
        {
            _glUniform2iv( location, value.Length / 2, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM3IVPROC( GLint location, GLsizei count, GLint* value );

    private PFNGLUNIFORM3IVPROC _glUniform3iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform3iv( GLint location, GLsizei count, GLint* value )
    {
        _glUniform3iv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform3iv( GLint location, params GLint[] value )
    {
        fixed ( GLint* p = &value[ 0 ] )
        {
            _glUniform3iv( location, value.Length / 3, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM4IVPROC( GLint location, GLsizei count, GLint* value );

    private PFNGLUNIFORM4IVPROC _glUniform4iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform4iv( GLint location, GLsizei count, GLint* value )
    {
        _glUniform4iv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform4iv( GLint location, params GLint[] value )
    {
        fixed ( GLint* p = &value[ 0 ] )
        {
            _glUniform4iv( location, value.Length / 4, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORMMATRIX2FVPROC( GLint location, GLsizei count, GLboolean transpose, GLfloat* value );

    private PFNGLUNIFORMMATRIX2FVPROC _glUniformMatrix2fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniformMatrix2fv( GLint location, GLsizei count, GLboolean transpose, GLfloat* value )
    {
        _glUniformMatrix2fv( location, count, transpose, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">
    /// Specifies an array of values that will be used to update the specified uniform variable. Needs 4
    /// values per matrix.
    /// </param>
    public void glUniformMatrix2fv( GLint location, GLboolean transpose, params GLfloat[] value )
    {
        fixed ( GLfloat* p =
                   &value[ 0 ] )
        {
            _glUniformMatrix2fv( location, value.Length / 4, transpose, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORMMATRIX3FVPROC( GLint location, GLsizei count, GLboolean transpose, GLfloat* value );

    private PFNGLUNIFORMMATRIX3FVPROC _glUniformMatrix3fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniformMatrix3fv( GLint location, GLsizei count, GLboolean transpose, GLfloat* value )
    {
        _glUniformMatrix3fv( location, count, transpose, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">
    /// Specifies an array of values that will be used to update the specified uniform variable. Needs 9
    /// values per matrix.
    /// </param>
    public void glUniformMatrix3fv( GLint location, GLboolean transpose, params GLfloat[] value )
    {
        fixed ( GLfloat* p =
                   &value[ 0 ] )
        {
            _glUniformMatrix3fv( location, value.Length / 9, transpose, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORMMATRIX4FVPROC( GLint location, GLsizei count, GLboolean transpose, GLfloat* value );

    private PFNGLUNIFORMMATRIX4FVPROC _glUniformMatrix4fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniformMatrix4fv( GLint location, GLsizei count, GLboolean transpose, GLfloat* value )
    {
        _glUniformMatrix4fv( location, count, transpose, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform value to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">
    /// Specifies an array of values that will be used to update the specified uniform variable. Needs 16
    /// values per matrix.
    /// </param>
    public void glUniformMatrix4fv( GLint location, GLboolean transpose, params GLfloat[] value )
    {
        fixed ( GLfloat* p =
                   &value[ 0 ] )
        {
            _glUniformMatrix4fv( location, value.Length / 16, transpose, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLVALIDATEPROGRAMPROC( GLuint program );

    private PFNGLVALIDATEPROGRAMPROC _glValidateProgram;

    /// <summary>
    /// Validates a program object
    /// </summary>
    /// <param name="program">Specifies the handle of the program object to be validated</param>
    /// <returns><c>true</c> if validation is successful, <c>false</c> otherwise</returns>
    public GLboolean glValidateProgram( GLuint program )
    {
        return _glValidateProgram( program );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB1DPROC( GLuint index, GLdouble x );

    private PFNGLVERTEXATTRIB1DPROC _glVertexAttrib1d;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">Specifies the new value for the generic vertex attribute</param>
    public void glVertexAttrib1d( GLuint index, GLdouble x )
    {
        _glVertexAttrib1d( index, x );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB1DVPROC( GLuint index, GLdouble* v );

    private PFNGLVERTEXATTRIB1DVPROC _glVertexAttrib1dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib1dv( GLuint index, GLdouble* v )
    {
        _glVertexAttrib1dv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib1dv( GLuint index, params GLdouble[] v )
    {
        fixed ( GLdouble* p = &v[ 0 ] )
        {
            _glVertexAttrib1dv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB1FPROC( GLuint index, GLfloat x );

    private PFNGLVERTEXATTRIB1FPROC _glVertexAttrib1f;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">Specifies the new value for the generic vertex attribute</param>
    public void glVertexAttrib1f( GLuint index, GLfloat x )
    {
        _glVertexAttrib1f( index, x );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB1FVPROC( GLuint index, GLfloat* v );

    private PFNGLVERTEXATTRIB1FVPROC _glVertexAttrib1fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib1fv( GLuint index, GLfloat* v )
    {
        _glVertexAttrib1fv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib1fv( GLuint index, params GLfloat[] v )
    {
        fixed ( GLfloat* p = &v[ 0 ] )
        {
            _glVertexAttrib1fv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB1SPROC( GLuint index, GLshort x );

    private PFNGLVERTEXATTRIB1SPROC _glVertexAttrib1s;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">Specifies the new value for the generic vertex attribute</param>
    public void glVertexAttrib1s( GLuint index, GLshort x )
    {
        _glVertexAttrib1s( index, x );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB1SVPROC( GLuint index, GLshort* v );

    private PFNGLVERTEXATTRIB1SVPROC _glVertexAttrib1sv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib1sv( GLuint index, GLshort* v )
    {
        _glVertexAttrib1sv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib1sv( GLuint index, params GLshort[] v )
    {
        fixed ( GLshort* p = &v[ 0 ] )
        {
            _glVertexAttrib1sv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB2DPROC( GLuint index, GLdouble x, GLdouble y );

    private PFNGLVERTEXATTRIB2DPROC _glVertexAttrib2d;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">Specifies the first component of the generic vertex attribute</param>
    /// <param name="y">Specifies the second component of the generic vertex attribute</param>
    public void glVertexAttrib2d( GLuint index, GLdouble x, GLdouble y )
    {
        _glVertexAttrib2d( index, x, y );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB2DVPROC( GLuint index, GLdouble* v );

    private PFNGLVERTEXATTRIB2DVPROC _glVertexAttrib2dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib2dv( GLuint index, GLdouble* v )
    {
        _glVertexAttrib2dv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib2dv( GLuint index, params GLdouble[] v )
    {
        fixed ( GLdouble* p = &v[ 0 ] )
        {
            _glVertexAttrib2dv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB2FPROC( GLuint index, GLfloat x, GLfloat y );

    private PFNGLVERTEXATTRIB2FPROC _glVertexAttrib2f;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">Specifies the first component of the generic vertex attribute</param>
    /// <param name="y">Specifies the second component of the generic vertex attribute</param>
    public void glVertexAttrib2f( GLuint index, GLfloat x, GLfloat y )
    {
        _glVertexAttrib2f( index, x, y );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB2FVPROC( GLuint index, GLfloat* v );

    private PFNGLVERTEXATTRIB2FVPROC _glVertexAttrib2fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib2fv( GLuint index, GLfloat* v )
    {
        _glVertexAttrib2fv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib2fv( GLuint index, params GLfloat[] v )
    {
        fixed ( GLfloat* p = &v[ 0 ] )
        {
            _glVertexAttrib2fv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB2SPROC( GLuint index, GLshort x, GLshort y );

    private PFNGLVERTEXATTRIB2SPROC _glVertexAttrib2s;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">Specifies the first component of the generic vertex attribute</param>
    /// <param name="y">Specifies the second component of the generic vertex attribute</param>
    public void glVertexAttrib2s( GLuint index, GLshort x, GLshort y )
    {
        _glVertexAttrib2s( index, x, y );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB2SVPROC( GLuint index, GLshort* v );

    private PFNGLVERTEXATTRIB2SVPROC _glVertexAttrib2sv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib2sv( GLuint index, GLshort* v )
    {
        _glVertexAttrib2sv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib2sv( GLuint index, params GLshort[] v )
    {
        fixed ( GLshort* p = &v[ 0 ] )
        {
            _glVertexAttrib2sv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB3DPROC( GLuint index, GLdouble x, GLdouble y, GLdouble z );

    private PFNGLVERTEXATTRIB3DPROC _glVertexAttrib3d;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">Specifies the first component of the generic vertex attribute</param>
    /// <param name="y">Specifies the second component of the generic vertex attribute</param>
    /// <param name="z">Specifies the third component of the generic vertex attribute</param>
    public void glVertexAttrib3d( GLuint index, GLdouble x, GLdouble y, GLdouble z )
    {
        _glVertexAttrib3d( index, x, y, z );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB3DVPROC( GLuint index, GLdouble* v );

    private PFNGLVERTEXATTRIB3DVPROC _glVertexAttrib3dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib3dv( GLuint index, GLdouble* v )
    {
        _glVertexAttrib3dv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib3dv( GLuint index, params GLdouble[] v )
    {
        fixed ( GLdouble* p = &v[ 0 ] )
        {
            _glVertexAttrib3dv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB3FPROC( GLuint index, GLfloat x, GLfloat y, GLfloat z );

    private PFNGLVERTEXATTRIB3FPROC _glVertexAttrib3f;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">Specifies the first component of the generic vertex attribute</param>
    /// <param name="y">Specifies the second component of the generic vertex attribute</param>
    /// <param name="z">Specifies the third component of the generic vertex attribute</param>
    public void glVertexAttrib3f( GLuint index, GLfloat x, GLfloat y, GLfloat z )
    {
        _glVertexAttrib3f( index, x, y, z );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB3FVPROC( GLuint index, GLfloat* v );

    private PFNGLVERTEXATTRIB3FVPROC _glVertexAttrib3fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib3fv( GLuint index, GLfloat* v )
    {
        _glVertexAttrib3fv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib3fv( GLuint index, params GLfloat[] v )
    {
        fixed ( GLfloat* p = &v[ 0 ] )
        {
            _glVertexAttrib3fv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB3SPROC( GLuint index, GLshort x, GLshort y, GLshort z );

    private PFNGLVERTEXATTRIB3SPROC _glVertexAttrib3s;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">Specifies the first component of the generic vertex attribute</param>
    /// <param name="y">Specifies the second component of the generic vertex attribute</param>
    /// <param name="z">Specifies the third component of the generic vertex attribute</param>
    public void glVertexAttrib3s( GLuint index, GLshort x, GLshort y, GLshort z )
    {
        _glVertexAttrib3s( index, x, y, z );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB3SVPROC( GLuint index, GLshort* v );

    private PFNGLVERTEXATTRIB3SVPROC _glVertexAttrib3sv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib3sv( GLuint index, GLshort* v )
    {
        _glVertexAttrib3sv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib3sv( GLuint index, params GLshort[] v )
    {
        fixed ( GLshort* p = &v[ 0 ] )
        {
            _glVertexAttrib3sv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4NBVPROC( GLuint index, GLbyte* v );

    private PFNGLVERTEXATTRIB4NBVPROC _glVertexAttrib4Nbv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Nbv( GLuint index, GLbyte* v )
    {
        _glVertexAttrib4Nbv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Nbv( GLuint index, params GLbyte[] v )
    {
        fixed ( GLbyte* p = &v[ 0 ] )
        {
            _glVertexAttrib4Nbv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4NIVPROC( GLuint index, GLint* v );

    private PFNGLVERTEXATTRIB4NIVPROC _glVertexAttrib4Niv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Niv( GLuint index, GLint* v )
    {
        _glVertexAttrib4Niv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Niv( GLuint index, params GLint[] v )
    {
        fixed ( GLint* p = &v[ 0 ] )
        {
            _glVertexAttrib4Niv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4NSVPROC( GLuint index, GLshort* v );

    private PFNGLVERTEXATTRIB4NSVPROC _glVertexAttrib4Nsv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Nsv( GLuint index, GLshort* v )
    {
        _glVertexAttrib4Nsv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Nsv( GLuint index, params GLshort[] v )
    {
        fixed ( GLshort* p = &v[ 0 ] )
        {
            _glVertexAttrib4Nsv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4NUBPROC( GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w );

    private PFNGLVERTEXATTRIB4NUBPROC _glVertexAttrib4Nub;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">Specifies the first component of the generic vertex attribute</param>
    /// <param name="y">Specifies the second component of the generic vertex attribute</param>
    /// <param name="z">Specifies the third component of the generic vertex attribute</param>
    /// <param name="w">Specifies the fourth component of the generic vertex attribute</param>
    public void glVertexAttrib4Nub( GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w )
    {
        _glVertexAttrib4Nub( index, x, y, z, w );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4NUBVPROC( GLuint index, GLubyte* v );

    private PFNGLVERTEXATTRIB4NUBVPROC _glVertexAttrib4Nubv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Nubv( GLuint index, GLubyte* v )
    {
        _glVertexAttrib4Nubv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Nubv( GLuint index, params GLubyte[] v )
    {
        fixed ( GLubyte* p = &v[ 0 ] )
        {
            _glVertexAttrib4Nubv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4NUIVPROC( GLuint index, GLuint* v );

    private PFNGLVERTEXATTRIB4NUIVPROC _glVertexAttrib4Nuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Nuiv( GLuint index, GLuint* v )
    {
        _glVertexAttrib4Nuiv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Nuiv( GLuint index, params GLuint[] v )
    {
        fixed ( GLuint* p = &v[ 0 ] )
        {
            _glVertexAttrib4Nuiv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4NUSVPROC( GLuint index, GLushort* v );

    private PFNGLVERTEXATTRIB4NUSVPROC _glVertexAttrib4Nusv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Nusv( GLuint index, GLushort* v )
    {
        _glVertexAttrib4Nusv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4Nusv( GLuint index, params GLushort[] v )
    {
        fixed ( GLushort* p = &v[ 0 ] )
        {
            _glVertexAttrib4Nusv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4BVPROC( GLuint index, GLbyte* v );

    private PFNGLVERTEXATTRIB4BVPROC _glVertexAttrib4bv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4bv( GLuint index, GLbyte* v )
    {
        _glVertexAttrib4bv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4bv( GLuint index, params GLbyte[] v )
    {
        fixed ( GLbyte* p = &v[ 0 ] )
        {
            _glVertexAttrib4bv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4DPROC( GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w );

    private PFNGLVERTEXATTRIB4DPROC _glVertexAttrib4d;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">
    /// Specifies the first component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    /// <param name="y">
    /// Specifies the second component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    /// <param name="z">
    /// Specifies the third component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    /// <param name="w">
    /// Specifies the fourth component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    public void glVertexAttrib4d( GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
    {
        _glVertexAttrib4d( index, x, y, z, w );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4DVPROC( GLuint index, GLdouble* v );

    private PFNGLVERTEXATTRIB4DVPROC _glVertexAttrib4dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4dv( GLuint index, GLdouble* v )
    {
        _glVertexAttrib4dv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4dv( GLuint index, params GLdouble[] v )
    {
        fixed ( GLdouble* p = &v[ 0 ] )
        {
            _glVertexAttrib4dv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4FPROC( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w );

    private PFNGLVERTEXATTRIB4FPROC _glVertexAttrib4f;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">
    /// Specifies the first component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    /// <param name="y">
    /// Specifies the second component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    /// <param name="z">
    /// Specifies the third component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    /// <param name="w">
    /// Specifies the fourth component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    public void glVertexAttrib4f( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
    {
        _glVertexAttrib4f( index, x, y, z, w );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4FVPROC( GLuint index, GLfloat* v );

    private PFNGLVERTEXATTRIB4FVPROC _glVertexAttrib4fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4fv( GLuint index, GLfloat* v )
    {
        _glVertexAttrib4fv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4fv( GLuint index, params GLfloat[] v )
    {
        fixed ( GLfloat* p = &v[ 0 ] )
        {
            _glVertexAttrib4fv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4IVPROC( GLuint index, GLint* v );

    private PFNGLVERTEXATTRIB4IVPROC _glVertexAttrib4iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4iv( GLuint index, GLint* v )
    {
        _glVertexAttrib4iv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4iv( GLuint index, params GLint[] v )
    {
        fixed ( GLint* p = &v[ 0 ] )
        {
            _glVertexAttrib4iv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4SPROC( GLuint index, GLshort x, GLshort y, GLshort z, GLshort w );

    private PFNGLVERTEXATTRIB4SPROC _glVertexAttrib4s;

    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="x">
    /// Specifies the first component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    /// <param name="y">
    /// Specifies the second component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    /// <param name="z">
    /// Specifies the third component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    /// <param name="w">
    /// Specifies the fourth component of the vector to be used when updating the current value of the generic
    /// vertex attribute
    /// </param>
    public void glVertexAttrib4s( GLuint index, GLshort x, GLshort y, GLshort z, GLshort w )
    {
        _glVertexAttrib4s( index, x, y, z, w );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4SVPROC( GLuint index, GLshort* v );

    private PFNGLVERTEXATTRIB4SVPROC _glVertexAttrib4sv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4sv( GLuint index, GLshort* v )
    {
        _glVertexAttrib4sv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4sv( GLuint index, params GLshort[] v )
    {
        fixed ( GLshort* p = &v[ 0 ] )
        {
            _glVertexAttrib4sv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4UBVPROC( GLuint index, GLubyte* v );

    private PFNGLVERTEXATTRIB4UBVPROC _glVertexAttrib4ubv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4ubv( GLuint index, GLubyte* v )
    {
        _glVertexAttrib4ubv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4ubv( GLuint index, params GLubyte[] v )
    {
        fixed ( GLubyte* p = &v[ 0 ] )
        {
            _glVertexAttrib4ubv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4UIVPROC( GLuint index, GLuint* v );

    private PFNGLVERTEXATTRIB4UIVPROC _glVertexAttrib4uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4uiv( GLuint index, GLuint* v )
    {
        _glVertexAttrib4uiv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4uiv( GLuint index, params GLuint[] v )
    {
        fixed ( GLuint* p = &v[ 0 ] )
        {
            _glVertexAttrib4uiv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIB4USVPROC( GLuint index, GLushort* v );

    private PFNGLVERTEXATTRIB4USVPROC _glVertexAttrib4usv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies a pointer to an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4usv( GLuint index, GLushort* v )
    {
        _glVertexAttrib4usv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="v">Specifies an array that contains the new values for the generic vertex attribute</param>
    public void glVertexAttrib4usv( GLuint index, params GLushort[] v )
    {
        fixed ( GLushort* p = &v[ 0 ] )
        {
            _glVertexAttrib4usv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBPOINTERPROC( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, void* pointer );

    private PFNGLVERTEXATTRIBPOINTERPROC _glVertexAttribPointer;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Define an array of generic vertex attribute data
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1,2,3 or 4.</param>
    /// <param name="type">
    /// Specifies the data type of each component in the array. The symbolic constants
    /// <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_SHORT"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>,
    /// <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_HALF_FLOAT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_DOUBLE"/>, <see cref="IGL.GL_FIXED"/>, <see cref="IGL.GL_INT_2_10_10_10_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>, and <see cref="IGL.GL_UNSIGNED_INT_10F_11F_11F_REV"/> are accepted. The
    /// initial value is <see cref="IGL.GL_FLOAT"/>.
    /// </param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized <see langword="true"/> or
    /// converted directly as fixed-point values <see langword="false"/> when they are accessed.
    /// </param>
    /// <param name="stride">
    /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the
    /// generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
    /// </param>
    /// <param name="pointer">
    /// Specifies an offset of the first component in the first generic vertex attribute in the array in
    /// the data store of the buffer currently bound to the <see cref="IGL.GL_ARRAY_BUFFER"/> target. The initial value is 0.
    /// </param>
    public void glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, void* pointer )
    {
        _glVertexAttribPointer( index, size, type, normalized, stride, pointer );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Define an array of generic vertex attribute data
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified</param>
    /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1,2,3 or 4.</param>
    /// <param name="type">
    /// Specifies the data type of each component in the array. The symbolic constants
    /// <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_SHORT"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>,
    /// <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_HALF_FLOAT"/>, <see cref="IGL.GL_FLOAT"/>,
    /// <see cref="IGL.GL_DOUBLE"/>, <see cref="IGL.GL_FIXED"/>, <see cref="IGL.GL_INT_2_10_10_10_REV"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT_2_10_10_10_REV"/>, and <see cref="IGL.GL_UNSIGNED_INT_10F_11F_11F_REV"/> are accepted. The
    /// initial value is <see cref="IGL.GL_FLOAT"/>.
    /// </param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized <see langword="true"/> or
    /// converted directly as fixed-point values <see langword="false"/> when they are accessed.
    /// </param>
    /// <param name="stride">
    /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the
    /// generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
    /// </param>
    /// <param name="pointer">
    /// Specifies an offset of the first component in the first generic vertex attribute in the array in
    /// the data store of the buffer currently bound to the <see cref="IGL.GL_ARRAY_BUFFER"/> target. The initial value is 0.
    /// </param>
    public void glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, uint pointer )
    {
        _glVertexAttribPointer( index, size, type, normalized, stride, ( void* )pointer );
    }
#endif

#endif

    // OpenGL 2.1

#if OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORMMATRIX2X3FVPROC( GLint location, GLsizei count, GLboolean transpose, GLfloat* value );

    private PFNGLUNIFORMMATRIX2X3FVPROC _glUniformMatrix2x3fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="count">
    /// Specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform
    /// variable is not an array of matrices, and 1 or more if it is an array of matrices
    /// </param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies a pointer to an array of values that will be used to update the specified uniform
    /// variable
    /// </param>
    public void glUniformMatrix2x3fv( GLint location, GLsizei count, GLboolean transpose, GLfloat* value )
    {
        _glUniformMatrix2x3fv( location, count, transpose, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies an array of values that will be used to update the specified uniform variable. 6 values
    /// per matrix.
    /// </param>
    public void glUniformMatrix2x3fv( GLint location, GLboolean transpose, params GLfloat[] value )
    {
        fixed ( GLfloat* p =
                   &value[ 0 ] )
        {
            _glUniformMatrix2x3fv( location, value.Length / 6, transpose, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORMMATRIX3X2FVPROC( GLint location, GLsizei count, GLboolean transpose, GLfloat* value );

    private PFNGLUNIFORMMATRIX3X2FVPROC _glUniformMatrix3x2fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="count">
    /// Specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform
    /// variable is not an array of matrices, and 1 or more if it is an array of matrices
    /// </param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies a pointer to an array of values that will be used to update the specified uniform
    /// variable
    /// </param>
    public void glUniformMatrix3x2fv( GLint location, GLsizei count, GLboolean transpose, GLfloat* value )
    {
        _glUniformMatrix3x2fv( location, count, transpose, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies an array of values that will be used to update the specified uniform variable. 6 values
    /// per matrix.
    /// </param>
    public void glUniformMatrix3x2fv( GLint location, GLboolean transpose, params GLfloat[] value )
    {
        fixed ( GLfloat* p =
                   &value[ 0 ] )
        {
            _glUniformMatrix3x2fv( location, value.Length / 6, transpose, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORMMATRIX2X4FVPROC( GLint location, GLsizei count, GLboolean transpose, GLfloat* value );

    private PFNGLUNIFORMMATRIX2X4FVPROC _glUniformMatrix2x4fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="count">
    /// Specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform
    /// variable is not an array of matrices, and 1 or more if it is an array of matrices
    /// </param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies a pointer to an array of values that will be used to update the specified uniform
    /// variable
    /// </param>
    public void glUniformMatrix2x4fv( GLint location, GLsizei count, GLboolean transpose, GLfloat* value )
    {
        _glUniformMatrix2x4fv( location, count, transpose, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies an array of values that will be used to update the specified uniform variable. 8 values
    /// per matrix.
    /// </param>
    public void glUniformMatrix2x4fv( GLint location, GLboolean transpose, params GLfloat[] value )
    {
        fixed ( GLfloat* p =
                   &value[ 0 ] )
        {
            _glUniformMatrix2x4fv( location, value.Length / 8, transpose, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORMMATRIX4X2FVPROC( GLint location, GLsizei count, GLboolean transpose, GLfloat* value );

    private PFNGLUNIFORMMATRIX4X2FVPROC _glUniformMatrix4x2fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="count">
    /// Specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform
    /// variable is not an array of matrices, and 1 or more if it is an array of matrices
    /// </param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies a pointer to an array of values that will be used to update the specified uniform
    /// variable
    /// </param>
    public void glUniformMatrix4x2fv( GLint location, GLsizei count, GLboolean transpose, GLfloat* value )
    {
        _glUniformMatrix4x2fv( location, count, transpose, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies an array of values that will be used to update the specified uniform variable. 8 values
    /// per matrix.
    /// </param>
    public void glUniformMatrix4x2fv( GLint location, GLboolean transpose, params GLfloat[] value )
    {
        fixed ( GLfloat* p =
                   &value[ 0 ] )
        {
            _glUniformMatrix4x2fv( location, value.Length / 8, transpose, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORMMATRIX3X4FVPROC( GLint location, GLsizei count, GLboolean transpose, GLfloat* value );

    private PFNGLUNIFORMMATRIX3X4FVPROC _glUniformMatrix3x4fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="count">
    /// Specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform
    /// variable is not an array of matrices, and 1 or more if it is an array of matrices
    /// </param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies a pointer to an array of values that will be used to update the specified uniform
    /// variable
    /// </param>
    public void glUniformMatrix3x4fv( GLint location, GLsizei count, GLboolean transpose, GLfloat* value )
    {
        _glUniformMatrix3x4fv( location, count, transpose, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies an array of values that will be used to update the specified uniform variable. 12 values
    /// per matrix.
    /// </param>
    public void glUniformMatrix3x4fv( GLint location, GLboolean transpose, params GLfloat[] value )
    {
        fixed ( GLfloat* p =
                   &value[ 0 ] )
        {
            _glUniformMatrix3x4fv( location, value.Length / 12, transpose, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORMMATRIX4X3FVPROC( GLint location, GLsizei count, GLboolean transpose, GLfloat* value );

    private PFNGLUNIFORMMATRIX4X3FVPROC _glUniformMatrix4x3fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="count">
    /// Specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform
    /// variable is not an array of matrices, and 1 or more if it is an array of matrices
    /// </param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies a pointer to an array of values that will be used to update the specified uniform
    /// variable
    /// </param>
    public void glUniformMatrix4x3fv( GLint location, GLsizei count, GLboolean transpose, GLfloat* value )
    {
        _glUniformMatrix4x3fv( location, count, transpose, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable</param>
    /// <param name="value">
    /// Specifies an array of values that will be used to update the specified uniform variable. 12 values
    /// per matrix.
    /// </param>
    public void glUniformMatrix4x3fv( GLint location, GLboolean transpose, params GLfloat[] value )
    {
        fixed ( GLfloat* p =
                   &value[ 0 ] )
        {
            _glUniformMatrix4x3fv( location, value.Length / 12, transpose, p );
        }
    }
#endif

#endif

    // OpenGL 3.0

#if OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOLORMASKIPROC( GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a );

    private PFNGLCOLORMASKIPROC _glColorMaski;

    /// <summary>
    /// Enable and disable writing of frame buffer color components
    /// </summary>
    /// <param name="index">Specifies the index of the draw buffer for which to modify the color mask.</param>
    /// <param name="r">Specifies whether red can or cannot be written into the frame buffer.</param>
    /// <param name="g">Specifies whether green can or cannot be written into the frame buffer.</param>
    /// <param name="b">Specifies whether blue can or cannot be written into the frame buffer.</param>
    /// <param name="a">Specifies whether alpha can or cannot be written into the frame buffer.</param>
    public void glColorMaski( GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a )
    {
        _glColorMaski( index, r, g, b, a );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETBOOLEANI_VPROC( GLenum target, GLuint index, GLboolean* data );

    private PFNGLGETBOOLEANI_VPROC _glGetBooleani_v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the boolean value of a selected indexed state variable
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the query. Refer to <see href="https://docs.gl/gl4/glGet"/> for a list of
    /// possible targets.
    /// </param>
    /// <param name="index">Specifies the index of the indexed state variable to be queried.</param>
    /// <param name="data">Returns the requested data.</param>
    public void glGetBooleani_v( GLenum target, GLuint index, GLboolean* data )
    {
        _glGetBooleani_v( target, index, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the boolean value of a selected indexed state variable
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the query. Refer to <see href="https://docs.gl/gl4/glGet"/> for a list of
    /// possible targets.
    /// </param>
    /// <param name="index">Specifies the index of the indexed state variable to be queried.</param>
    /// <param name="data">A <see langword="ref"/> to an array to receive the data.</param>
    public void glGetBooleani_v( GLenum target, GLuint index, ref GLboolean[] data )
    {
        fixed ( GLboolean* p =
                   &data[ 0 ] )
        {
            _glGetBooleani_v( target, index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETINTEGERI_VPROC( GLenum target, GLuint index, GLint* data );

    private PFNGLGETINTEGERI_VPROC _glGetIntegeri_v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the integer value of a selected indexed state variable
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the query. Refer to <see href="https://docs.gl/gl4/glGet"/> for a list of
    /// possible targets.
    /// </param>
    /// <param name="index">Specifies the index of the indexed state variable to be queried.</param>
    /// <param name="data">Returns the requested data.</param>
    public void glGetIntegeri_v( GLenum target, GLuint index, GLint* data )
    {
        _glGetIntegeri_v( target, index, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the integer value of a selected indexed state variable
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the query. Refer to <see href="https://docs.gl/gl4/glGet"/> for a list of
    /// possible targets.
    /// </param>
    /// <param name="index">Specifies the index of the indexed state variable to be queried.</param>
    /// <param name="data">A <see langword="ref"/> to an array to receive the data.</param>
    public void glGetIntegeri_v( GLenum target, GLuint index, ref GLint[] data )
    {
        fixed ( GLint* p = &data[ 0 ] )
        {
            _glGetIntegeri_v( target, index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLENABLEIPROC( GLenum target, GLuint index );

    private PFNGLENABLEIPROC _glEnablei;

    /// <summary>
    /// Enable capabilities for a specific indexed target
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the capability to enable. Refer to
    /// <see href="https://docs.gl/gl4/glEnable"/> for a list of possible capabilities.
    /// </param>
    /// <param name="index">Specifies the index of the target to enable or disable.</param>
    public void glEnablei( GLenum target, GLuint index )
    {
        _glEnablei( target, index );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDISABLEIPROC( GLenum target, GLuint index );

    private PFNGLDISABLEIPROC _glDisablei;

    /// <summary>
    /// Disable capabilities for a specific indexed target
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the capability to enable. Refer to
    /// <see href="https://docs.gl/gl4/glEnable"/> for a list of possible capabilities.
    /// </param>
    /// <param name="index">Specifies the index of the target to enable or disable.</param>
    public void glDisablei( GLenum target, GLuint index )
    {
        _glDisablei( target, index );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISENABLEDIPROC( GLenum target, GLuint index );

    private PFNGLISENABLEDIPROC _glIsEnabledi;

    /// <summary>
    /// Test whether a specific indexed capability is enabled
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the capability to enable. Refer to
    /// <see href="https://docs.gl/gl4/glEnable"/> for a list of possible capabilities.
    /// </param>
    /// <param name="index">Specifies the index of the target to enable or disable.</param>
    public GLboolean glIsEnabledi( GLenum target, GLuint index )
    {
        return _glIsEnabledi( target, index );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBEGINTRANSFORMFEEDBACKPROC( GLenum primitiveMode );

    private PFNGLBEGINTRANSFORMFEEDBACKPROC _glBeginTransformFeedback;

    /// <summary>
    /// Start transform feedback operations
    /// </summary>
    /// <param name="primitiveMode">
    /// Specifies the mode used to capture vertex data. Symbolic constants <see cref="IGL.GL_POINTS"/>
    /// , <see cref="IGL.GL_LINES"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINE_STRIP"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/> and
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> are accepted. Refer to
    /// <see href="https://docs.gl/gl4/glBeginTransformFeedback"/> for some quirks regarding this parameter.
    /// </param>
    public void glBeginTransformFeedback( GLenum primitiveMode )
    {
        _glBeginTransformFeedback( primitiveMode );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLENDTRANSFORMFEEDBACKPROC();

    private PFNGLENDTRANSFORMFEEDBACKPROC _glEndTransformFeedback;

    /// <summary>
    /// End transform feedback operations
    /// </summary>
    public void glEndTransformFeedback()
    {
        _glEndTransformFeedback();
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDBUFFERRANGEPROC( GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size );

    private PFNGLBINDBUFFERRANGEPROC _glBindBufferRange;

    /// <summary>
    /// Bind a range of a buffer object to an indexed buffer target
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the bind operation. <paramref name="target"/> must be one of
    /// <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/>,
    /// <see cref="IGL.GL_UNIFORM_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>.
    /// </param>
    /// <param name="index">Specifies the index of the binding point within the array specified by <paramref name="target"/>.</param>
    /// <param name="buffer">Specifies the name of a buffer object whose storage to bind to the specified binding point.</param>
    /// <param name="offset">Specifies the starting offset within the buffer of the range to bind.</param>
    /// <param name="size">
    /// Specifies the amount of data in bytes from the buffer object that is to be made available for
    /// reading.
    /// </param>
    public void glBindBufferRange( GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size )
    {
        _glBindBufferRange( target, index, buffer, offset, size );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDBUFFERBASEPROC( GLenum target, GLuint index, GLuint buffer );

    private PFNGLBINDBUFFERBASEPROC _glBindBufferBase;

    /// <summary>
    /// Bind a buffer object to an indexed buffer target
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the bind operation. <paramref name="target"/> must be one of
    /// <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/>,
    /// <see cref="IGL.GL_UNIFORM_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>.
    /// </param>
    /// <param name="index">Specifies the index of the binding point within the array specified by <paramref name="target"/>.</param>
    /// <param name="buffer">Specifies the name of a buffer object whose storage to bind to the specified binding point.</param>
    public void glBindBufferBase( GLenum target, GLuint index, GLuint buffer )
    {
        _glBindBufferBase( target, index, buffer );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTRANSFORMFEEDBACKVARYINGSPROC( GLuint program, GLsizei count, GLchar** varyings, GLenum bufferMode );

    private PFNGLTRANSFORMFEEDBACKVARYINGSPROC _glTransformFeedbackVaryings;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify values to record in transform feedback buffers
    /// </summary>
    /// <param name="program">Specifies the name of the program object whose transform feedback varyings are to be specified.</param>
    /// <param name="count">
    /// Specifies the number of transform feedback varyings to capture when transform feedback is active.
    /// This number may be zero.
    /// </param>
    /// <param name="varyings">
    /// Specifies an array of pointers to buffers into which to place the names of the transform
    /// feedback varyings for the program named by <paramref name="program"/>.
    /// </param>
    /// <param name="bufferMode">
    /// Specifies the mode used to capture the varying variables when transform feedback is active.
    /// <paramref name="bufferMode"/> must be one of <see cref="IGL.GL_INTERLEAVED_ATTRIBS"/> or
    /// <see cref="IGL.GL_SEPARATE_ATTRIBS"/>.
    /// </param>
    public void glTransformFeedbackVaryings( GLuint program, GLsizei count, GLchar** varyings, GLenum bufferMode )
    {
        _glTransformFeedbackVaryings( program, count, varyings, bufferMode );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify values to record in transform feedback buffers
    /// </summary>
    /// <param name="program">Specifies the name of the program object whose transform feedback varyings are to be specified.</param>
    /// <param name="varyings">Specifies an array of names of varying variables to use for transform feedback.</param>
    /// <param name="bufferMode">
    /// Specifies the mode used to capture the varying variables when transform feedback is active.
    /// <paramref name="bufferMode"/> must be one of <see cref="IGL.GL_INTERLEAVED_ATTRIBS"/> or
    /// <see cref="IGL.GL_SEPARATE_ATTRIBS"/>.
    /// </param>
    public void glTransformFeedbackVaryings( GLuint program, string[] varyings, GLenum bufferMode )
    {
        var varyingsBytes = new GLchar[ varyings.Length ][];

        for ( var i = 0; i < varyings.Length; i++ )
        {
            varyingsBytes[ i ] = Encoding.UTF8.GetBytes( varyings[ i ] );
        }

        var varyingsPtrs = new GLchar*[ varyings.Length ];

        for ( var i = 0; i < varyings.Length; i++ )
        {
            fixed ( GLchar* p = &varyingsBytes[ i ][ 0 ] )
            {
                varyingsPtrs[ i ] = p;
            }
        }

        fixed ( GLchar** p = &varyingsPtrs[ 0 ] )
        {
            _glTransformFeedbackVaryings( program, varyings.Length, p, bufferMode );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETTRANSFORMFEEDBACKVARYINGPROC( GLuint program,
                                                                GLuint index,
                                                                GLsizei bufSize,
                                                                GLsizei* length,
                                                                GLsizei* size,
                                                                GLenum* type,
                                                                GLchar* name );

    private PFNGLGETTRANSFORMFEEDBACKVARYINGPROC _glGetTransformFeedbackVarying;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve information about a varying variable from a program object's active transform feedback varyings
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the queried varying variable.</param>
    /// <param name="index">Specifies the index of the varying variable to query.</param>
    /// <param name="bufSize">
    /// Specifies the maximum number of characters OpenGL is allowed to write into
    /// <paramref name="name"/>.
    /// </param>
    /// <param name="length">Returns the number of characters actually written by OpenGL into <paramref name="name"/>.</param>
    /// <param name="size">Returns the size of the requested varying variable.</param>
    /// <param name="type">Returns the data type of the requested varying variable.</param>
    /// <param name="name">Returns a null-terminated string containing the name of the requested varying variable.</param>
    public void glGetTransformFeedbackVarying( GLuint program,
                                               GLuint index,
                                               GLsizei bufSize,
                                               GLsizei* length,
                                               GLsizei* size,
                                               GLenum* type,
                                               GLchar* name )
    {
        _glGetTransformFeedbackVarying( program, index, bufSize, length, size, type, name );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve information about a varying variable from a program object's active transform feedback varyings
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the queried varying variable.</param>
    /// <param name="index">Specifies the index of the varying variable to query.</param>
    /// <param name="bufSize">
    /// Specifies the maximum number of characters OpenGL is allowed to write into
    /// <paramref name="name"/>.
    /// </param>
    /// <param name="size">Returns the size of the requested varying variable.</param>
    /// <param name="type">Returns the data type of the requested varying variable.</param>
    /// <returns>Returns a managed string containing the name of the requested varying variable.</returns>
    public string glGetTransformFeedbackVarying( GLuint program, GLuint index, GLsizei bufSize, out GLsizei size, out GLenum type )
    {
        var     name = new GLchar[ bufSize ];
        GLsizei length;

        fixed ( GLsizei* pSize = &size )
        {
            fixed ( GLenum* pType = &type )
            {
                fixed ( GLchar* p = &name[ 0 ] )
                {
                    _glGetTransformFeedbackVarying( program, index, bufSize, &length, pSize, pType, p );

                    return new string( ( sbyte* )p, 0, length, Encoding.UTF8 );
                }
            }
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCLAMPCOLORPROC( GLenum target, GLenum clamp );

    private PFNGLCLAMPCOLORPROC _glClampColor;

    /// <summary>
    /// Specify whether data read via <see cref="glReadPixels"/> should be clamped.
    /// </summary>
    /// <param name="target">Specifies the target to be clamped. Must be <see cref="IGL.GL_CLAMP_READ_COLOR"/>.</param>
    /// <param name="clamp">
    /// Specifies whether to apply color clamping. <see langword="true"/> specifies that clamping is
    /// enabled, <see langword="false"/> specifies that clamping is disabled.
    /// </param>
    public void glClampColor( GLenum target, GLboolean clamp )
    {
        _glClampColor( target, clamp ? IGL.GL_TRUE : IGL.GL_FALSE );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBEGINCONDITIONALRENDERPROC( GLuint id, GLenum mode );

    private PFNGLBEGINCONDITIONALRENDERPROC _glBeginConditionalRender;

    /// <summary>
    /// Start conditional rendering
    /// </summary>
    /// <param name="id">
    /// Specifies the name of an occlusion query object whose results are used to determine if the rendering
    /// commands are discarded or not.
    /// </param>
    /// <param name="mode">
    /// Specifies how <see cref="glglBeginConditionalRender"/> interprets the results of the occlusion
    /// query.
    /// </param>
    public void glBeginConditionalRender( GLuint id, GLenum mode )
    {
        _glBeginConditionalRender( id, mode );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLENDCONDITIONALRENDERPROC();

    private PFNGLENDCONDITIONALRENDERPROC _glEndConditionalRender;

    /// <summary>
    /// End conditional rendering
    /// </summary>
    public void glEndConditionalRender()
    {
        _glEndConditionalRender();
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBIPOINTERPROC( GLuint index, GLint size, GLenum type, GLsizei stride, void* pointer );

    private PFNGLVERTEXATTRIBIPOINTERPROC _glVertexAttribIPointer;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Define an array of generic vertex attribute data
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.</param>
    /// <param name="type">
    /// Specifies the data type of each component in the array. Must be one of <see cref="IGL.GL_BYTE"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_SHORT"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_INT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/> or <see cref="IGL.GL_DOUBLE"/>.
    /// </param>
    /// <param name="stride">
    /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the
    /// generic vertex attributes are understood to be tightly packed in the array.
    /// </param>
    /// <param name="pointer">
    /// Specifies an offset of the first component of the first generic vertex attribute in the array in
    /// the data store of the buffer currently bound to the <see cref="IGL.GL_ARRAY_BUFFER"/> target. The initial value is 0.
    /// </param>
    public void glVertexAttribIPointer( GLuint index, GLint size, GLenum type, GLsizei stride, void* pointer )
    {
        _glVertexAttribIPointer( index, size, type, stride, pointer );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Define an array of generic vertex attribute data
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.</param>
    /// <param name="type">
    /// Specifies the data type of each component in the array. Must be one of <see cref="IGL.GL_BYTE"/>,
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_SHORT"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_INT"/>,
    /// <see cref="IGL.GL_UNSIGNED_INT"/> or <see cref="IGL.GL_DOUBLE"/>.
    /// </param>
    /// <param name="stride">
    /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the
    /// generic vertex attributes are understood to be tightly packed in the array.
    /// </param>
    /// <param name="pointer">
    /// Specifies an offset of the first component of the first generic vertex attribute in the array in
    /// the data store of the buffer currently bound to the <see cref="IGL.GL_ARRAY_BUFFER"/> target. The initial value is 0.
    /// </param>
    public void glVertexAttribIPointer( GLuint index, GLint size, GLenum type, GLsizei stride, uint pointer )
    {
        _glVertexAttribIPointer( index, size, type, stride, ( void* )pointer );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETVERTEXATTRIBIIVPROC( GLuint index, GLenum pname, GLint* parameters );

    private PFNGLGETVERTEXATTRIBIIVPROC _glGetVertexAttribIiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the integer value of a generic vertex attribute parameter
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the generic vertex attribute parameter to be queried. Must be one of
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>,
    /// <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>.
    /// </param>
    /// <param name="parameters">Returns the requested parameter.</param>
    public void glGetVertexAttribIiv( GLuint index, GLenum pname, GLint* parameters )
    {
        _glGetVertexAttribIiv( index, pname, parameters );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the integer value of a generic vertex attribute parameter
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the generic vertex attribute parameter to be queried. Must be one of
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>,
    /// <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>.
    /// </param>
    /// <param name="parameters">A <see langword="ref"/> to an array into which the returned values will be placed.</param>
    public void glGetVertexAttribIiv( GLuint index, GLenum pname, ref GLint[] parameters )
    {
        fixed ( GLint* p =
                   &parameters[ 0 ] )
        {
            _glGetVertexAttribIiv( index, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETVERTEXATTRIBIUIVPROC( GLuint index, GLenum pname, GLuint* parameters );

    private PFNGLGETVERTEXATTRIBIUIVPROC _glGetVertexAttribIuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the unsigned integer value of a generic vertex attribute parameter
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the generic vertex attribute parameter to be queried. Must be one of
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>,
    /// <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>.
    /// </param>
    /// <param name="parameters">Returns the requested parameter.</param>
    public void glGetVertexAttribIuiv( GLuint index, GLenum pname, GLuint* parameters )
    {
        _glGetVertexAttribIuiv( index, pname, parameters );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the unsigned integer value of a generic vertex attribute parameter
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of the generic vertex attribute parameter to be queried. Must be one of
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>,
    /// <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>,
    /// <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>.
    /// </param>
    /// <param name="parameters">A <see langword="ref"/> to an array into which the returned values will be placed.</param>
    public void glGetVertexAttribIuiv( GLuint index, GLenum pname, ref GLuint[] parameters )
    {
        fixed ( GLuint* p =
                   &parameters[ 0 ] )
        {
            _glGetVertexAttribIuiv( index, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI1IPROC( GLuint index, GLint x );

    private PFNGLVERTEXATTRIBI1IPROC _glVertexAttribI1i;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first component of the vertex attribute.</param>
    public void glVertexAttribI1i( GLuint index, GLint x )
    {
        _glVertexAttribI1i( index, x );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI2IPROC( GLuint index, GLint x, GLint y );

    private PFNGLVERTEXATTRIBI2IPROC _glVertexAttribI2i;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first component of the vertex attribute.</param>
    /// <param name="y">Specifies the second component of the vertex attribute.</param>
    public void glVertexAttribI2i( GLuint index, GLint x, GLint y )
    {
        _glVertexAttribI2i( index, x, y );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI3IPROC( GLuint index, GLint x, GLint y, GLint z );

    private PFNGLVERTEXATTRIBI3IPROC _glVertexAttribI3i;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first component of the vertex attribute.</param>
    /// <param name="y">Specifies the second component of the vertex attribute.</param>
    /// <param name="z">Specifies the third component of the vertex attribute.</param>
    public void glVertexAttribI3i( GLuint index, GLint x, GLint y, GLint z )
    {
        _glVertexAttribI3i( index, x, y, z );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI4IPROC( GLuint index, GLint x, GLint y, GLint z, GLint w );

    private PFNGLVERTEXATTRIBI4IPROC _glVertexAttribI4i;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first component of the vertex attribute.</param>
    /// <param name="y">Specifies the second component of the vertex attribute.</param>
    /// <param name="z">Specifies the third component of the vertex attribute.</param>
    /// <param name="w">Specifies the fourth component of the vertex attribute.</param>
    public void glVertexAttribI4i( GLuint index, GLint x, GLint y, GLint z, GLint w )
    {
        _glVertexAttribI4i( index, x, y, z, w );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI1UIPROC( GLuint index, GLuint x );

    private PFNGLVERTEXATTRIBI1UIPROC _glVertexAttribI1ui;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first component of the vertex attribute.</param>
    public void glVertexAttribI1ui( GLuint index, GLuint x )
    {
        _glVertexAttribI1ui( index, x );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI2UIPROC( GLuint index, GLuint x, GLuint y );

    private PFNGLVERTEXATTRIBI2UIPROC _glVertexAttribI2ui;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first component of the vertex attribute.</param>
    /// <param name="y">Specifies the second component of the vertex attribute.</param>
    public void glVertexAttribI2ui( GLuint index, GLuint x, GLuint y )
    {
        _glVertexAttribI2ui( index, x, y );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI3UIPROC( GLuint index, GLuint x, GLuint y, GLuint z );

    private PFNGLVERTEXATTRIBI3UIPROC _glVertexAttribI3ui;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first component of the vertex attribute.</param>
    /// <param name="y">Specifies the second component of the vertex attribute.</param>
    /// <param name="z">Specifies the third component of the vertex attribute.</param>
    public void glVertexAttribI3ui( GLuint index, GLuint x, GLuint y, GLuint z )
    {
        _glVertexAttribI3ui( index, x, y, z );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI4UIPROC( GLuint index, GLuint x, GLuint y, GLuint z, GLuint w );

    private PFNGLVERTEXATTRIBI4UIPROC _glVertexAttribI4ui;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first component of the vertex attribute.</param>
    /// <param name="y">Specifies the second component of the vertex attribute.</param>
    /// <param name="z">Specifies the third component of the vertex attribute.</param>
    /// <param name="w">Specifies the fourth component of the vertex attribute.</param>
    public void glVertexAttribI4ui( GLuint index, GLuint x, GLuint y, GLuint z, GLuint w )
    {
        _glVertexAttribI4ui( index, x, y, z, w );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI1IVPROC( GLuint index, GLint* v );

    private PFNGLVERTEXATTRIBI1IVPROC _glVertexAttribI1iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI1iv( GLuint index, GLint* v )
    {
        _glVertexAttribI1iv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI1iv( GLuint index, GLint[] v )
    {
        fixed ( GLint* p = &v[ 0 ] )
        {
            _glVertexAttribI1iv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI2IVPROC( GLuint index, GLint* v );

    private PFNGLVERTEXATTRIBI2IVPROC _glVertexAttribI2iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI2iv( GLuint index, GLint* v )
    {
        _glVertexAttribI2iv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI2iv( GLuint index, GLint[] v )
    {
        fixed ( GLint* p = &v[ 0 ] )
        {
            _glVertexAttribI2iv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI3IVPROC( GLuint index, GLint* v );

    private PFNGLVERTEXATTRIBI3IVPROC _glVertexAttribI3iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI3iv( GLuint index, GLint* v )
    {
        _glVertexAttribI3iv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI3iv( GLuint index, GLint[] v )
    {
        fixed ( GLint* p = &v[ 0 ] )
        {
            _glVertexAttribI3iv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI4IVPROC( GLuint index, GLint* v );

    private PFNGLVERTEXATTRIBI4IVPROC _glVertexAttribI4iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4iv( GLuint index, GLint* v )
    {
        _glVertexAttribI4iv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4iv( GLuint index, GLint[] v )
    {
        fixed ( GLint* p = &v[ 0 ] )
        {
            _glVertexAttribI4iv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI1UIVPROC( GLuint index, GLuint* v );

    private PFNGLVERTEXATTRIBI1UIVPROC _glVertexAttribI1uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI1uiv( GLuint index, GLuint* v )
    {
        _glVertexAttribI1uiv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI1uiv( GLuint index, GLuint[] v )
    {
        fixed ( GLuint* p = &v[ 0 ] )
        {
            _glVertexAttribI1uiv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI2UIVPROC( GLuint index, GLuint* v );

    private PFNGLVERTEXATTRIBI2UIVPROC _glVertexAttribI2uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI2uiv( GLuint index, GLuint* v )
    {
        _glVertexAttribI2uiv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI2uiv( GLuint index, GLuint[] v )
    {
        fixed ( GLuint* p = &v[ 0 ] )
        {
            _glVertexAttribI2uiv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI3UIVPROC( GLuint index, GLuint* v );

    private PFNGLVERTEXATTRIBI3UIVPROC _glVertexAttribI3uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI3uiv( GLuint index, GLuint* v )
    {
        _glVertexAttribI3uiv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI3uiv( GLuint index, GLuint[] v )
    {
        fixed ( GLuint* p = &v[ 0 ] )
        {
            _glVertexAttribI3uiv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI4UIVPROC( GLuint index, GLuint* v );

    private PFNGLVERTEXATTRIBI4UIVPROC _glVertexAttribI4uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4uiv( GLuint index, GLuint* v )
    {
        _glVertexAttribI4uiv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4uiv( GLuint index, GLuint[] v )
    {
        fixed ( GLuint* p = &v[ 0 ] )
        {
            _glVertexAttribI4uiv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI4BVPROC( GLuint index, GLbyte* v );

    private PFNGLVERTEXATTRIBI4BVPROC _glVertexAttribI4bv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4bv( GLuint index, GLbyte* v )
    {
        _glVertexAttribI4bv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4bv( GLuint index, GLbyte[] v )
    {
        fixed ( GLbyte* p = &v[ 0 ] )
        {
            _glVertexAttribI4bv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI4SVPROC( GLuint index, GLshort* v );

    private PFNGLVERTEXATTRIBI4SVPROC _glVertexAttribI4sv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4sv( GLuint index, GLshort* v )
    {
        _glVertexAttribI4sv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4sv( GLuint index, GLshort[] v )
    {
        fixed ( GLshort* p = &v[ 0 ] )
        {
            _glVertexAttribI4sv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI4UBVPROC( GLuint index, GLubyte* v );

    private PFNGLVERTEXATTRIBI4UBVPROC _glVertexAttribI4ubv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4ubv( GLuint index, GLubyte* v )
    {
        _glVertexAttribI4ubv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4ubv( GLuint index, GLubyte[] v )
    {
        fixed ( GLubyte* p = &v[ 0 ] )
        {
            _glVertexAttribI4ubv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBI4USVPROC( GLuint index, GLushort* v );

    private PFNGLVERTEXATTRIBI4USVPROC _glVertexAttribI4usv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4usv( GLuint index, GLushort* v )
    {
        _glVertexAttribI4usv( index, v );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that contains the new values for the vertex attribute.</param>
    public void glVertexAttribI4usv( GLuint index, GLushort[] v )
    {
        fixed ( GLushort* p = &v[ 0 ] )
        {
            _glVertexAttribI4usv( index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETUNIFORMUIVPROC( GLuint program, GLint location, GLuint* @params );

    private PFNGLGETUNIFORMUIVPROC _glGetUniformuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the value of a uniform variable of type unsigned int
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be queried.</param>
    /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
    /// <param name="params">Returns the value of the specified uniform variable.</param>
    public void glGetUniformuiv( GLuint program, GLint location, GLuint* @params )
    {
        _glGetUniformuiv( program, location, @params );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the value of a uniform variable of type unsigned int
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be queried.</param>
    /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
    /// <param name="params">A <see langword="ref"/> to an array to receive the value of the specified uniform variable.</param>
    public void glGetUniformuiv( GLuint program, GLint location, ref GLuint[] @params )
    {
        fixed ( GLuint* p =
                   &@params[ 0 ] )
        {
            _glGetUniformuiv( program, location, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDFRAGDATALOCATIONPROC( GLuint program, GLuint color, GLchar* name );

    private PFNGLBINDFRAGDATALOCATIONPROC _glBindFragDataLocation;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Bind a user-defined varying out variable to a fragment shader color number
    /// </summary>
    /// <param name="program">Specifies the program object in which the binding is to occur.</param>
    /// <param name="color">Specifies the color number to which the user-defined varying out variable is to be bound.</param>
    /// <param name="name">Specifies the name of the user-defined varying out variable to whose bound location to set.</param>
    public void glBindFragDataLocation( GLuint program, GLuint color, GLchar* name )
    {
        _glBindFragDataLocation( program, color, name );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Bind a user-defined varying out variable to a fragment shader color number
    /// </summary>
    /// <param name="program">Specifies the program object in which the binding is to occur.</param>
    /// <param name="color">Specifies the color number to which the user-defined varying out variable is to be bound.</param>
    /// <param name="name">Specifies the name of the user-defined varying out variable to whose bound location to set.</param>
    public void glBindFragDataLocation( GLuint program, GLuint color, string name )
    {
        var narr = Encoding.UTF8.GetBytes( name );

        fixed ( GLchar* p =
                   &narr[ 0 ] )
        {
            _glBindFragDataLocation( program, color, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLint PFNGLGETFRAGDATALOCATIONPROC( GLuint program, GLchar* name );

    private PFNGLGETFRAGDATALOCATIONPROC _glGetFragDataLocation;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the location of a user-defined varying out variable
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="name">Specifies the name of the user-defined varying out variable whose location is to be queried.</param>
    /// <returns>The location of the user-defined varying out variable specified by <paramref name="name"/> is returned.</returns>
    public GLint glGetFragDataLocation( GLuint program, GLchar* name )
    {
        return _glGetFragDataLocation( program, name );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the location of a user-defined varying out variable
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="name">Specifies the name of the user-defined varying out variable whose location is to be queried.</param>
    /// <returns>The location of the user-defined varying out variable specified by <paramref name="name"/> is returned.</returns>
    public GLint glGetFragDataLocation( GLuint program, string name )
    {
        var narr = Encoding.UTF8.GetBytes( name );

        fixed ( GLchar* p =
                   &narr[ 0 ] )
        {
            return _glGetFragDataLocation( program, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM1UIPROC( GLint location, GLuint v0 );

    private PFNGLUNIFORM1UIPROC _glUniform1ui;

    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the new value to be used for the specified uniform variable.</param>
    public void glUniform1ui( GLint location, GLuint v0 )
    {
        _glUniform1ui( location, v0 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM2UIPROC( GLint location, GLuint v0, GLuint v1 );

    private PFNGLUNIFORM2UIPROC _glUniform2ui;

    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second value to be used for the specified uniform variable.</param>
    public void glUniform2ui( GLint location, GLuint v0, GLuint v1 )
    {
        _glUniform2ui( location, v0, v1 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM3UIPROC( GLint location, GLuint v0, GLuint v1, GLuint v2 );

    private PFNGLUNIFORM3UIPROC _glUniform3ui;

    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second value to be used for the specified uniform variable.</param>
    /// <param name="v2">Specifies the third value to be used for the specified uniform variable.</param>
    public void glUniform3ui( GLint location, GLuint v0, GLuint v1, GLuint v2 )
    {
        _glUniform3ui( location, v0, v1, v2 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM4UIPROC( GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3 );

    private PFNGLUNIFORM4UIPROC _glUniform4ui;

    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second value to be used for the specified uniform variable.</param>
    /// <param name="v2">Specifies the third value to be used for the specified uniform variable.</param>
    /// <param name="v3">Specifies the fourth value to be used for the specified uniform variable.</param>
    public void glUniform4ui( GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3 )
    {
        _glUniform4ui( location, v0, v1, v2, v3 );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM1UIVPROC( GLint location, GLsizei count, GLuint* value );

    private PFNGLUNIFORM1UIVPROC _glUniform1uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform1uiv( GLint location, GLsizei count, GLuint* value )
    {
        _glUniform1uiv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform1uiv( GLint location, GLuint[] value )
    {
        fixed ( GLuint* p = &value[ 0 ] )
        {
            _glUniform1uiv( location, value.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM2UIVPROC( GLint location, GLsizei count, GLuint* value );

    private PFNGLUNIFORM2UIVPROC _glUniform2uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform2uiv( GLint location, GLsizei count, GLuint* value )
    {
        _glUniform2uiv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform2uiv( GLint location, GLuint[] value )
    {
        fixed ( GLuint* p = &value[ 0 ] )
        {
            _glUniform2uiv( location, value.Length / 2, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM3UIVPROC( GLint location, GLsizei count, GLuint* value );

    private PFNGLUNIFORM3UIVPROC _glUniform3uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform3uiv( GLint location, GLsizei count, GLuint* value )
    {
        _glUniform3uiv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform3uiv( GLint location, GLuint[] value )
    {
        fixed ( GLuint* p = &value[ 0 ] )
        {
            _glUniform3uiv( location, value.Length / 3, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORM4UIVPROC( GLint location, GLsizei count, GLuint* value );

    private PFNGLUNIFORM4UIVPROC _glUniform4uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">
    /// Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the
    /// specified uniform variable.
    /// </param>
    public void glUniform4uiv( GLint location, GLsizei count, GLuint* value )
    {
        _glUniform4uiv( location, count, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of an unsigned int uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform4uiv( GLint location, GLuint[] value )
    {
        fixed ( GLuint* p = &value[ 0 ] )
        {
            _glUniform4uiv( location, value.Length / 4, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXPARAMETERIIVPROC( GLenum target, GLenum pname, GLint* param );

    private PFNGLTEXPARAMETERIIVPROC _glTexParameterIiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set the value of a texture parameter for the current texture unit, with integer values
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture, which must be either <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> or
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter. <paramref name="pname"/> can be
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/> or <see cref="IGL.GL_TEXTURE_WRAP_R"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glTexParameterIiv( GLenum target, GLenum pname, GLint* param )
    {
        _glTexParameterIiv( target, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set the value of a texture parameter for the current texture unit, with integer values
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture, which must be either <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> or
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter. <paramref name="pname"/> can be
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/> or <see cref="IGL.GL_TEXTURE_WRAP_R"/>.
    /// </param>
    /// <param name="param">Specifies an array of values that will be used to update the specified texture parameter.</param>
    public void glTexParameterIiv( GLenum target, GLenum pname, GLint[] param )
    {
        fixed ( GLint* p = &param[ 0 ] )
        {
            _glTexParameterIiv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXPARAMETERIUIVPROC( GLenum target, GLenum pname, GLuint* param );

    private PFNGLTEXPARAMETERIUIVPROC _glTexParameterIuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set the value of a texture parameter for the current texture unit, with unsigned integer values
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture, which must be either <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> or
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter. <paramref name="pname"/> can be
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/> or <see cref="IGL.GL_TEXTURE_WRAP_R"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glTexParameterIuiv( GLenum target, GLenum pname, GLuint* param )
    {
        _glTexParameterIuiv( target, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set the value of a texture parameter for the current texture unit, with unsigned integer values
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture, which must be either <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> or
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter. <paramref name="pname"/> can be
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/> or <see cref="IGL.GL_TEXTURE_WRAP_R"/>.
    /// </param>
    /// <param name="param">Specifies an array of values that will be used to update the specified texture parameter.</param>
    public void glTexParameterIuiv( GLenum target, GLenum pname, GLuint[] param )
    {
        fixed ( GLuint* p =
                   &param[ 0 ] )
        {
            _glTexParameterIuiv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETTEXPARAMETERIIVPROC( GLenum target, GLenum pname, GLint* parameters );

    private PFNGLGETTEXPARAMETERIIVPROC _glGetTexParameterIiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Get the value of a texture parameter for the current texture unit, with signed integer values
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture, which must be either <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> or
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter. <paramref name="pname"/> can be
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/> or <see cref="IGL.GL_TEXTURE_WRAP_R"/>.
    /// </param>
    /// <param name="parameters">Returns the texture parameter value.</param>
    public void glGetTexParameterIiv( GLenum target, GLenum pname, GLint* parameters )
    {
        _glGetTexParameterIiv( target, pname, parameters );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Get the value of a texture parameter for the current texture unit, with signed integer values
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture, which must be either <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> or
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter. <paramref name="pname"/> can be
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/> or <see cref="IGL.GL_TEXTURE_WRAP_R"/>.
    /// </param>
    /// <param name="parameters">A <see langword="ref"/> to an array to receive the texture parameter value.</param>
    public void glGetTexParameterIiv( GLenum target, GLenum pname, ref GLint[] parameters )
    {
        fixed ( GLint* p =
                   &parameters[ 0 ] )
        {
            _glGetTexParameterIiv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETTEXPARAMETERIUIVPROC( GLenum target, GLenum pname, GLuint* parameters );

    private PFNGLGETTEXPARAMETERIUIVPROC _glGetTexParameterIuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Get the value of a texture parameter for the current texture unit, with unsigned integer values
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture, which must be either <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> or
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter. <paramref name="pname"/> can be
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/> or <see cref="IGL.GL_TEXTURE_WRAP_R"/>.
    /// </param>
    /// <param name="parameters">Returns the texture parameter value.</param>
    public void glGetTexParameterIuiv( GLenum target, GLenum pname, GLuint* parameters )
    {
        _glGetTexParameterIuiv( target, pname, parameters );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Get the value of a texture parameter for the current texture unit, with unsigned integer values
    /// </summary>
    /// <param name="target">
    /// Specifies the target texture, which must be either <see cref="IGL.GL_TEXTURE_1D"/>,
    /// <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/>, <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/> or
    /// <see cref="IGL.GL_TEXTURE_RECTANGLE"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued texture parameter. <paramref name="pname"/> can be
    /// <see cref="IGL.GL_DEPTH_STENCIL_TEXTURE_MODE"/>, <see cref="IGL.GL_TEXTURE_BASE_LEVEL"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>, <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_MIN_LOD"/>,
    /// <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LEVEL"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_R"/>,
    /// <see cref="IGL.GL_TEXTURE_SWIZZLE_G"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_B"/>, <see cref="IGL.GL_TEXTURE_SWIZZLE_A"/>,
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/> or <see cref="IGL.GL_TEXTURE_WRAP_R"/>.
    /// </param>
    /// <param name="parameters">A <see langword="ref"/> to an array to receive the texture parameter value.</param>
    public void glGetTexParameterIuiv( GLenum target, GLenum pname, ref GLuint[] parameters )
    {
        fixed ( GLuint* p =
                   &parameters[ 0 ] )
        {
            _glGetTexParameterIuiv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCLEARBUFFERIVPROC( GLenum buffer, GLint drawbuffer, GLint* value );

    private PFNGLCLEARBUFFERIVPROC _glClearBufferiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear a buffer to an integer value. Refer to <see href="https://docs.gl/gl4/glClearBuffer"/> for details on how to
    /// use this function.
    /// </summary>
    /// <param name="buffer">
    /// Specifies the buffer to clear. <paramref name="buffer"/> must be one of <see cref="IGL.GL_COLOR"/>,
    /// <see cref="IGL.GL_DEPTH"/>, <see cref="IGL.GL_STENCIL"/>.
    /// </param>
    /// <param name="drawbuffer">Specify a partical draw buffer to clear.</param>
    /// <param name="value">Specifies the value to clear the buffer to.</param>
    public void glClearBufferiv( GLenum buffer, GLint drawbuffer, GLint* value )
    {
        _glClearBufferiv( buffer, drawbuffer, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear a buffer to an integer value. Refer to <see href="https://docs.gl/gl4/glClearBuffer"/> for details on how to
    /// use this function.
    /// </summary>
    /// <param name="buffer">
    /// Specifies the buffer to clear. <paramref name="buffer"/> must be one of <see cref="IGL.GL_COLOR"/>,
    /// <see cref="IGL.GL_DEPTH"/>, <see cref="IGL.GL_STENCIL"/>.
    /// </param>
    /// <param name="drawbuffer">Specify a partical draw buffer to clear.</param>
    /// <param name="value">Specifies the value to clear the buffer to.</param>
    public void glClearBufferiv( GLenum buffer, GLint drawbuffer, GLint[] value )
    {
        fixed ( GLint* p =
                   &value[ 0 ] )
        {
            _glClearBufferiv( buffer, drawbuffer, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCLEARBUFFERUIVPROC( GLenum buffer, GLint drawbuffer, GLuint* value );

    private PFNGLCLEARBUFFERUIVPROC _glClearBufferuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear a buffer to an unsigned integer value. Refer to <see href="https://docs.gl/gl4/glClearBuffer"/> for details
    /// on how to use this function.
    /// </summary>
    /// <param name="buffer">
    /// Specifies the buffer to clear. <paramref name="buffer"/> must be one of <see cref="IGL.GL_COLOR"/>,
    /// <see cref="IGL.GL_DEPTH"/>, <see cref="IGL.GL_STENCIL"/>.
    /// </param>
    /// <param name="drawbuffer">Specify a partical draw buffer to clear.</param>
    /// <param name="value">Specifies the value to clear the buffer to.</param>
    public void glClearBufferuiv( GLenum buffer, GLint drawbuffer, GLuint* value )
    {
        _glClearBufferuiv( buffer, drawbuffer, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear a buffer to an unsigned integer value. Refer to <see href="https://docs.gl/gl4/glClearBuffer"/> for details
    /// on how to use this function.
    /// </summary>
    /// <param name="buffer">
    /// Specifies the buffer to clear. <paramref name="buffer"/> must be one of <see cref="IGL.GL_COLOR"/>,
    /// <see cref="IGL.GL_DEPTH"/>, <see cref="IGL.GL_STENCIL"/>.
    /// </param>
    /// <param name="drawbuffer">Specify a partical draw buffer to clear.</param>
    /// <param name="value">Specifies the value to clear the buffer to.</param>
    public void glClearBufferuiv( GLenum buffer, GLint drawbuffer, GLuint[] value )
    {
        fixed ( GLuint* p =
                   &value[ 0 ] )
        {
            _glClearBufferuiv( buffer, drawbuffer, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCLEARBUFFERFVPROC( GLenum buffer, GLint drawbuffer, GLfloat* value );

    private PFNGLCLEARBUFFERFVPROC _glClearBufferfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear a buffer to a floating point value. Refer to <see href="https://docs.gl/gl4/glClearBuffer"/> for details on
    /// how to use this function.
    /// </summary>
    /// <param name="buffer">
    /// Specifies the buffer to clear. <paramref name="buffer"/> must be one of <see cref="IGL.GL_COLOR"/>,
    /// <see cref="IGL.GL_DEPTH"/>, <see cref="IGL.GL_STENCIL"/>.
    /// </param>
    /// <param name="drawbuffer">Specify a partical draw buffer to clear.</param>
    /// <param name="value">Specifies the value to clear the buffer to.</param>
    public void glClearBufferfv( GLenum buffer, GLint drawbuffer, GLfloat* value )
    {
        _glClearBufferfv( buffer, drawbuffer, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear a buffer to a floating point value. Refer to <see href="https://docs.gl/gl4/glClearBuffer"/> for details on
    /// how to use this function.
    /// </summary>
    /// <param name="buffer">
    /// Specifies the buffer to clear. <paramref name="buffer"/> must be one of <see cref="IGL.GL_COLOR"/>,
    /// <see cref="IGL.GL_DEPTH"/>, <see cref="IGL.GL_STENCIL"/>.
    /// </param>
    /// <param name="drawbuffer">Specify a partical draw buffer to clear.</param>
    /// <param name="value">Specifies the value to clear the buffer to.</param>
    public void glClearBufferfv( GLenum buffer, GLint drawbuffer, GLfloat[] value )
    {
        fixed ( GLfloat* p =
                   &value[ 0 ] )
        {
            _glClearBufferfv( buffer, drawbuffer, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCLEARBUFFERFIPROC( GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil );

    private PFNGLCLEARBUFFERFIPROC _glClearBufferfi;

    /// <summary>
    /// Clear a buffer to a floating point value. Refer to <see href="https://docs.gl/gl4/glClearBuffer"/> for details on
    /// how to use this function.
    /// </summary>
    /// <param name="buffer">
    /// Specifies the buffer to clear. <paramref name="buffer"/> must be one of
    /// <see cref="IGL.GL_DEPTH_STENCIL"/>.
    /// </param>
    /// <param name="drawbuffer">Must be zero.</param>
    /// <param name="depth">Specifies the value to clear the depth buffer to.</param>
    /// <param name="stencil">Specifies the value to clear the stencil buffer to.</param>
    public void glClearBufferfi( GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil )
    {
        _glClearBufferfi( buffer, drawbuffer, depth, stencil );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLubyte* PFNGLGETSTRINGIPROC( GLenum name, GLuint index );

    private PFNGLGETSTRINGIPROC _glGetStringi;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns a string describing the current GL connection.
    /// </summary>
    /// <param name="name">
    /// Specifies a symbolic constant, one of <see cref="IGL.GL_VENDOR"/>, <see cref="IGL.GL_RENDERER"/>,
    /// <see cref="IGL.GL_VERSION"/>, <see cref="IGL.GL_SHADING_LANGUAGE_VERSION"/> or <see cref="IGL.GL_EXTENSIONS"/>.
    /// </param>
    /// <param name="index">Specifies the index of the string to return.</param>
    /// <returns>The requested string.</returns>
    public GLubyte* glGetStringi( GLenum name, GLuint index )
    {
        return _glGetStringi( name, index );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns a string describing the current GL connection.
    /// </summary>
    /// <param name="name">
    /// Specifies a symbolic constant, one of <see cref="IGL.GL_VENDOR"/>, <see cref="IGL.GL_RENDERER"/>,
    /// <see cref="IGL.GL_VERSION"/>, <see cref="IGL.GL_SHADING_LANGUAGE_VERSION"/> or <see cref="IGL.GL_EXTENSIONS"/>.
    /// </param>
    /// <param name="index">Specifies the index of the string to return.</param>
    /// <returns>The requested string.</returns>
    public string glGetStringiSafe( GLenum name, GLuint index )
    {
        var ptr = _glGetStringi( name, index );

        if ( ptr == null )
        {
            return null;
        }

        var i = 0;

        while ( ptr[ i ] != 0 )
        {
            i++;
        }

        return new string( ( sbyte* )ptr, 0, i, Encoding.UTF8 );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISRENDERBUFFERPROC( GLuint renderbuffer );

    private PFNGLISRENDERBUFFERPROC _glIsRenderbuffer;

    /// <summary>
    /// Determine if a name corresponds to a renderbuffer object.
    /// </summary>
    /// <param name="renderbuffer">Specifies a value that may be the name of a renderbuffer object.</param>
    /// <returns>
    /// <see langword="true"/> if <paramref name="renderbuffer"/> is the name of a renderbuffer object.
    /// <see langword="false"/> otherwise.
    /// </returns>
    public GLboolean glIsRenderbuffer( GLuint renderbuffer )
    {
        return _glIsRenderbuffer( renderbuffer );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDRENDERBUFFERPROC( GLenum target, GLuint renderbuffer );

    private PFNGLBINDRENDERBUFFERPROC _glBindRenderbuffer;

    /// <summary>
    /// Bind a named renderbuffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the renderbuffer target of the binding operation. <paramref name="target"/> must be
    /// <see cref="IGL.GL_RENDERBUFFER"/>.
    /// </param>
    /// <param name="renderbuffer">Specifies the name of the renderbuffer object to bind.</param>
    public void glBindRenderbuffer( GLenum target, GLuint renderbuffer )
    {
        _glBindRenderbuffer( target, renderbuffer );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDELETERENDERBUFFERSPROC( GLsizei n, GLuint* renderbuffers );

    private PFNGLDELETERENDERBUFFERSPROC _glDeleteRenderbuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Delete named renderbuffer objects.
    /// </summary>
    /// <param name="n">Specifies the number of renderbuffer objects to be deleted.</param>
    /// <param name="renderbuffers">
    /// Specifies an array of <paramref name="n"/> values, each of which contains a renderbuffer
    /// object name to be deleted.
    /// </param>
    public void glDeleteRenderbuffers( GLsizei n, GLuint* renderbuffers )
    {
        _glDeleteRenderbuffers( n, renderbuffers );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Delete named renderbuffer objects.
    /// </summary>
    /// <param name="renderbuffers">Specifies an array of renderbuffer object names to be deleted.</param>
    public void glDeleteRenderbuffers( params GLuint[] renderbuffers )
    {
        fixed ( GLuint* p =
                   &renderbuffers[ 0 ] )
        {
            _glDeleteRenderbuffers( renderbuffers.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGENRENDERBUFFERSPROC( GLsizei n, GLuint* renderbuffers );

    private PFNGLGENRENDERBUFFERSPROC _glGenRenderbuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate renderbuffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of renderbuffer object names to generate.</param>
    /// <param name="renderbuffers">Specifies an array in which the generated renderbuffer object names are to be stored.</param>
    public void glGenRenderbuffers( GLsizei n, GLuint* renderbuffers )
    {
        _glGenRenderbuffers( n, renderbuffers );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate renderbuffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of renderbuffer object names to generate.</param>
    /// <returns>Array of generated renderbuffer object names.</returns>
    public GLuint[] glGenRenderbuffers( GLsizei n )
    {
        var renderbuffers = new GLuint[ n ];

        fixed ( GLuint* p =
                   &renderbuffers[ 0 ] )
        {
            _glGenRenderbuffers( n, p );
        }

        return renderbuffers;
    }

    /// <summary>
    /// Generate a single renderbuffer object name.
    /// </summary>
    /// <returns>The generated renderbuffer object name.</returns>
    public GLuint glGenRenderbuffer()
    {
        return glGenRenderbuffers( 1 )[ 0 ];
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLRENDERBUFFERSTORAGEPROC( GLenum target, GLenum internalformat, GLsizei width, GLsizei height );

    private PFNGLRENDERBUFFERSTORAGEPROC _glRenderbufferStorage;

    /// <summary>
    /// Establish data storage, format and dimensions of a renderbuffer object's image.
    /// </summary>
    /// <param name="target">
    /// Specifies a binding to which the target of the allocation and must be
    /// <see cref="IGL.GL_RENDERBUFFER"/>.
    /// </param>
    /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
    /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
    /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
    public void glRenderbufferStorage( GLenum target, GLenum internalformat, GLsizei width, GLsizei height )
    {
        _glRenderbufferStorage( target, internalformat, width, height );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETRENDERBUFFERPARAMETERIVPROC( GLenum target, GLenum pname, GLint* parameters );

    private PFNGLGETRENDERBUFFERPARAMETERIVPROC _glGetRenderbufferParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return renderbuffer object parameter values.
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the query operation. <paramref name="target"/> must be
    /// <see cref="IGL.GL_RENDERBUFFER"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a renderbuffer object parameter. <paramref name="pname"/> can be
    /// one of the following: <see cref="IGL.GL_RENDERBUFFER_WIDTH"/>, <see cref="IGL.GL_RENDERBUFFER_HEIGHT"/>,
    /// <see cref="IGL.GL_RENDERBUFFER_INTERNAL_FORMAT"/>, <see cref="IGL.GL_RENDERBUFFER_SAMPLES"/>,
    /// <see cref="IGL.GL_RENDERBUFFER_RED_SIZE"/>, <see cref="IGL.GL_RENDERBUFFER_GREEN_SIZE"/>,
    /// <see cref="IGL.GL_RENDERBUFFER_BLUE_SIZE"/>, <see cref="IGL.GL_RENDERBUFFER_ALPHA_SIZE"/>,
    /// <see cref="IGL.GL_RENDERBUFFER_DEPTH_SIZE"/>, or <see cref="IGL.GL_RENDERBUFFER_STENCIL_SIZE"/>.
    /// </param>
    /// <param name="parameters">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetRenderbufferParameteriv( GLenum target, GLenum pname, GLint* parameters )
    {
        _glGetRenderbufferParameteriv( target, pname, parameters );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return renderbuffer object parameter values.
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the query operation. <paramref name="target"/> must be
    /// <see cref="IGL.GL_RENDERBUFFER"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a renderbuffer object parameter. <paramref name="pname"/> can be
    /// one of the following: <see cref="IGL.GL_RENDERBUFFER_WIDTH"/>, <see cref="IGL.GL_RENDERBUFFER_HEIGHT"/>,
    /// <see cref="IGL.GL_RENDERBUFFER_INTERNAL_FORMAT"/>, <see cref="IGL.GL_RENDERBUFFER_SAMPLES"/>,
    /// <see cref="IGL.GL_RENDERBUFFER_RED_SIZE"/>, <see cref="IGL.GL_RENDERBUFFER_GREEN_SIZE"/>,
    /// <see cref="IGL.GL_RENDERBUFFER_BLUE_SIZE"/>, <see cref="IGL.GL_RENDERBUFFER_ALPHA_SIZE"/>,
    /// <see cref="IGL.GL_RENDERBUFFER_DEPTH_SIZE"/>, or <see cref="IGL.GL_RENDERBUFFER_STENCIL_SIZE"/>.
    /// </param>
    /// <param name="parameters">A <see langword="ref"/> to an array which will receive the value of the queried parameter.</param>
    public void glGetRenderbufferParameteriv( GLenum target, GLenum pname, ref GLint[] parameters )
    {
        fixed ( GLint* p =
                   &parameters[ 0 ] )
        {
            _glGetRenderbufferParameteriv( target, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISFRAMEBUFFERPROC( GLuint framebuffer );

    private PFNGLISFRAMEBUFFERPROC _glIsFramebuffer;

    /// <summary>
    /// Determine if a name corresponds to a framebuffer object.
    /// </summary>
    /// <param name="framebuffer">Specifies a value that may be the name of a framebuffer object.</param>
    /// <returns>
    /// <see langword="true"/> if <paramref name="framebuffer"/> is the name of a framebuffer object.
    /// <see langword="false"/> otherwise.
    /// </returns>
    public GLboolean glIsFramebuffer( GLuint framebuffer )
    {
        return _glIsFramebuffer( framebuffer );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDFRAMEBUFFERPROC( GLenum target, GLuint framebuffer );

    private PFNGLBINDFRAMEBUFFERPROC _glBindFramebuffer;

    /// <summary>
    /// Bind a named framebuffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the bind operation. <paramref name="target"/> must be one of
    /// <see cref="IGL.GL_FRAMEBUFFER"/>, <see cref="IGL.GL_DRAW_FRAMEBUFFER"/> or <see cref="IGL.GL_READ_FRAMEBUFFER"/>.
    /// </param>
    /// <param name="framebuffer">Specifies the name of a framebuffer object.</param>
    public void glBindFramebuffer( GLenum target, GLuint framebuffer )
    {
        _glBindFramebuffer( target, framebuffer );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDELETEFRAMEBUFFERSPROC( GLsizei n, GLuint* framebuffers );

    private PFNGLDELETEFRAMEBUFFERSPROC _glDeleteFramebuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Delete named framebuffer objects.
    /// </summary>
    /// <param name="n">Specifies the number of framebuffer objects to be deleted.</param>
    /// <param name="framebuffers">Specifies an array of framebuffer objects to be deleted.</param>
    public void glDeleteFramebuffers( GLsizei n, GLuint* framebuffers )
    {
        _glDeleteFramebuffers( n, framebuffers );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Delete named framebuffer objects.
    /// </summary>
    /// <param name="framebuffers">Specifies an array of framebuffer objects to be deleted.</param>
    public void glDeleteFramebuffers( params GLuint[] framebuffers )
    {
        fixed ( GLuint* p =
                   &framebuffers[ 0 ] )
        {
            _glDeleteFramebuffers( framebuffers.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGENFRAMEBUFFERSPROC( GLsizei n, GLuint* framebuffers );

    private PFNGLGENFRAMEBUFFERSPROC _glGenFramebuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate framebuffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of framebuffer object names to generate.</param>
    /// <param name="framebuffers">Specifies an array in which the generated framebuffer object names are stored.</param>
    public void glGenFramebuffers( GLsizei n, GLuint* framebuffers )
    {
        _glGenFramebuffers( n, framebuffers );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate framebuffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of framebuffer object names to generate.</param>
    /// <returns>An array in which the generated framebuffer object names are stored.</returns>
    public GLuint[] glGenFramebuffers( GLsizei n )
    {
        var framebuffers = new GLuint[ n ];

        fixed ( GLuint* p =
                   &framebuffers[ 0 ] )
        {
            _glGenFramebuffers( n, p );
        }

        return framebuffers;
    }

    /// <summary>
    /// Generate a single framebuffer object name.
    /// </summary>
    /// <returns>The generated framebuffer object name.</returns>
    public GLuint glGenFramebuffer()
    {
        return glGenFramebuffers( 1 )[ 0 ];
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLenum PFNGLCHECKFRAMEBUFFERSTATUSPROC( GLenum target );

    private PFNGLCHECKFRAMEBUFFERSTATUSPROC _glCheckFramebufferStatus;

    /// <summary>
    /// Check the completeness status of a framebuffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the framebuffer completeness check. <paramref name="target"/> must be one
    /// of <see cref="IGL.GL_FRAMEBUFFER"/>, <see cref="IGL.GL_DRAW_FRAMEBUFFER"/> or <see cref="IGL.GL_READ_FRAMEBUFFER"/>.
    /// </param>
    /// <returns>
    /// The framebuffer completeness status of <paramref name="target"/>. Refer to
    /// <see href="https://docs.gl/gl4/glCheckFramebufferStatus"/> for a list of all possible values.
    /// </returns>
    public GLenum glCheckFramebufferStatus( GLenum target )
    {
        return _glCheckFramebufferStatus( target );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLFRAMEBUFFERTEXTURE1DPROC( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level );

    private PFNGLFRAMEBUFFERTEXTURE1DPROC _glFramebufferTexture1D;

    /// <summary>
    /// Attach a level of a 1D texture object as a logical buffer to the currently bound framebuffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the framebuffer target. <paramref name="target"/> must be one of
    /// <see cref="IGL.GL_FRAMEBUFFER"/>, <see cref="IGL.GL_DRAW_FRAMEBUFFER"/> or <see cref="IGL.GL_READ_FRAMEBUFFER"/>.
    /// </param>
    /// <param name="attachment">
    /// Specifies the attachment point of the framebuffer. One of <see cref="IGL.GL_COLOR_ATTACHMENT0"/>
    /// through <see cref="IGL.GL_COLOR_ATTACHMENT31"/>, <see cref="IGL.GL_DEPTH_ATTACHMENT"/>,
    /// <see cref="IGL.GL_STENCIL_ATTACHMENT"/>, <see cref="IGL.GL_DEPTH_STENCIL_ATTACHMENT"/>.
    /// </param>
    /// <param name="textarget">Specifies the type of texture.</param>
    /// <param name="texture">Specifies the name of an existing 1D texture object.</param>
    /// <param name="level">Specifies the mipmap level of the texture object to attach.</param>
    public void glFramebufferTexture1D( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level )
    {
        _glFramebufferTexture1D( target, attachment, textarget, texture, level );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLFRAMEBUFFERTEXTURE2DPROC( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level );

    private PFNGLFRAMEBUFFERTEXTURE2DPROC _glFramebufferTexture2D;

    /// <summary>
    /// Attach a level of a 2D texture object as a logical buffer to the currently bound framebuffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the framebuffer target. <paramref name="target"/> must be one of
    /// <see cref="IGL.GL_FRAMEBUFFER"/>, <see cref="IGL.GL_DRAW_FRAMEBUFFER"/> or <see cref="IGL.GL_READ_FRAMEBUFFER"/>.
    /// </param>
    /// <param name="attachment">
    /// Specifies the attachment point of the framebuffer. One of <see cref="IGL.GL_COLOR_ATTACHMENT0"/>
    /// through <see cref="IGL.GL_COLOR_ATTACHMENT31"/>, <see cref="IGL.GL_DEPTH_ATTACHMENT"/>,
    /// <see cref="IGL.GL_STENCIL_ATTACHMENT"/>, <see cref="IGL.GL_DEPTH_STENCIL_ATTACHMENT"/>.
    /// </param>
    /// <param name="textarget">Specifies the type of texture.</param>
    /// <param name="texture">Specifies the name of an existing 2D texture object.</param>
    /// <param name="level">Specifies the mipmap level of the texture object to attach.</param>
    public void glFramebufferTexture2D( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level )
    {
        _glFramebufferTexture2D( target, attachment, textarget, texture, level );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLFRAMEBUFFERTEXTURE3DPROC( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset );

    private PFNGLFRAMEBUFFERTEXTURE3DPROC _glFramebufferTexture3D;

    /// <summary>
    /// Attach a level of a 3D texture object as a logical buffer to the currently bound framebuffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the framebuffer target. <paramref name="target"/> must be one of
    /// <see cref="IGL.GL_FRAMEBUFFER"/>, <see cref="IGL.GL_DRAW_FRAMEBUFFER"/> or <see cref="IGL.GL_READ_FRAMEBUFFER"/>.
    /// </param>
    /// <param name="attachment">
    /// Specifies the attachment point of the framebuffer. One of <see cref="IGL.GL_COLOR_ATTACHMENT0"/>
    /// through <see cref="IGL.GL_COLOR_ATTACHMENT31"/>, <see cref="IGL.GL_DEPTH_ATTACHMENT"/>,
    /// <see cref="IGL.GL_STENCIL_ATTACHMENT"/>, <see cref="IGL.GL_DEPTH_STENCIL_ATTACHMENT"/>.
    /// </param>
    /// <param name="textarget">Specifies the type of texture.</param>
    /// <param name="texture">Specifies the name of an existing 3D texture object.</param>
    /// <param name="level">Specifies the mipmap level of the texture object to attach.</param>
    /// <param name="zoffset">Specifies the zoffset texel to be used as the framebuffer attachment point.</param>
    public void glFramebufferTexture3D( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset )
    {
        _glFramebufferTexture3D( target, attachment, textarget, texture, level, zoffset );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLFRAMEBUFFERRENDERBUFFERPROC( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer );

    private PFNGLFRAMEBUFFERRENDERBUFFERPROC _glFramebufferRenderbuffer;

    /// <summary>
    /// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the framebuffer target. <paramref name="target"/> must be one of
    /// <see cref="IGL.GL_FRAMEBUFFER"/>, <see cref="IGL.GL_DRAW_FRAMEBUFFER"/> or <see cref="IGL.GL_READ_FRAMEBUFFER"/>.
    /// </param>
    /// <param name="attachment">
    /// Specifies the attachment point of the framebuffer. One of <see cref="IGL.GL_COLOR_ATTACHMENT0"/>
    /// through <see cref="IGL.GL_COLOR_ATTACHMENT31"/>, <see cref="IGL.GL_DEPTH_ATTACHMENT"/>,
    /// <see cref="IGL.GL_STENCIL_ATTACHMENT"/>, <see cref="IGL.GL_DEPTH_STENCIL_ATTACHMENT"/>.
    /// </param>
    /// <param name="renderbuffertarget">
    /// Specifies the renderbuffer target. <paramref name="renderbuffertarget"/> must be
    /// <see cref="IGL.GL_RENDERBUFFER"/>.
    /// </param>
    /// <param name="renderbuffer">
    /// Specifies the name of an existing renderbuffer object of type
    /// <paramref name="renderbuffertarget"/>.
    /// </param>
    public void glFramebufferRenderbuffer( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer )
    {
        _glFramebufferRenderbuffer( target, attachment, renderbuffertarget, renderbuffer );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC( GLenum target, GLenum attachment, GLenum pname, GLint* parameters );

    private PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC _glGetFramebufferAttachmentParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a framebuffer attachment.
    /// </summary>
    /// <param name="target">
    /// Specifies the framebuffer target. <paramref name="target"/> must be one of
    /// <see cref="IGL.GL_FRAMEBUFFER"/>, <see cref="IGL.GL_DRAW_FRAMEBUFFER"/> or <see cref="IGL.GL_READ_FRAMEBUFFER"/>.
    /// </param>
    /// <param name="attachment">
    /// Specifies the attachment point of the framebuffer. One of <see cref="IGL.GL_COLOR_ATTACHMENT0"/>
    /// through <see cref="IGL.GL_COLOR_ATTACHMENT31"/>, <see cref="IGL.GL_DEPTH_ATTACHMENT"/>,
    /// <see cref="IGL.GL_STENCIL_ATTACHMENT"/>, <see cref="IGL.GL_DEPTH_STENCIL_ATTACHMENT"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the parameter of <paramref name="attachment"/> to query. Refer to
    /// <see href="https://docs.gl/gl4/glGetFramebufferAttachmentParameter"/> for details.
    /// </param>
    /// <param name="parameters">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetFramebufferAttachmentParameteriv( GLenum target, GLenum attachment, GLenum pname, GLint* parameters )
    {
        _glGetFramebufferAttachmentParameteriv( target, attachment, pname, parameters );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a framebuffer attachment.
    /// </summary>
    /// <param name="target">
    /// Specifies the framebuffer target. <paramref name="target"/> must be one of
    /// <see cref="IGL.GL_FRAMEBUFFER"/>, <see cref="IGL.GL_DRAW_FRAMEBUFFER"/> or <see cref="IGL.GL_READ_FRAMEBUFFER"/>.
    /// </param>
    /// <param name="attachment">
    /// Specifies the attachment point of the framebuffer. One of <see cref="IGL.GL_COLOR_ATTACHMENT0"/>
    /// through <see cref="IGL.GL_COLOR_ATTACHMENT31"/>, <see cref="IGL.GL_DEPTH_ATTACHMENT"/>,
    /// <see cref="IGL.GL_STENCIL_ATTACHMENT"/>, <see cref="IGL.GL_DEPTH_STENCIL_ATTACHMENT"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the parameter of <paramref name="attachment"/> to query. Refer to
    /// <see href="https://docs.gl/gl4/glGetFramebufferAttachmentParameter"/> for details.
    /// </param>
    /// <param name="parameters">A <see langword="ref"/> to an array which will receive the returned value(s).</param>
    public void glGetFramebufferAttachmentParameteriv( GLenum target, GLenum attachment, GLenum pname, ref GLint[] parameters )
    {
        fixed ( GLint* p =
                   &parameters[ 0 ] )
        {
            _glGetFramebufferAttachmentParameteriv( target, attachment, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGENERATEMIPMAPPROC( GLenum target );

    private PFNGLGENERATEMIPMAPPROC _glGenerateMipmap;

    /// <summary>
    /// Generate mipmaps for a specified texture object.
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture whose mimaps to generate is bound.
    /// <paramref name="target"/> must be one of <see cref="IGL.GL_TEXTURE_1D"/>, <see cref="IGL.GL_TEXTURE_2D"/>,
    /// <see cref="IGL.GL_TEXTURE_3D"/>, <see cref="IGL.GL_TEXTURE_1D_ARRAY"/>, <see cref="IGL.GL_TEXTURE_2D_ARRAY"/>,
    /// <see cref="IGL.GL_TEXTURE_CUBE_MAP"/>, <see cref="IGL.GL_TEXTURE_CUBE_MAP_ARRAY"/>.
    /// </param>
    public void glGenerateMipmap( GLenum target )
    {
        _glGenerateMipmap( target );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBLITFRAMEBUFFERPROC( GLint srcX0,
                                                    GLint srcY0,
                                                    GLint srcX1,
                                                    GLint srcY1,
                                                    GLint dstX0,
                                                    GLint dstY0,
                                                    GLint dstX1,
                                                    GLint dstY1,
                                                    GLbitfield mask,
                                                    GLenum filter );

    private PFNGLBLITFRAMEBUFFERPROC _glBlitFramebuffer;

    /// <summary>
    /// Copy a block of pixels from the read framebuffer to the draw framebuffer.
    /// </summary>
    /// <param name="srcX0">Specify the left pixel coordinate of the source rectangle.</param>
    /// <param name="srcY0">Specify the bottom pixel coordinate of the source rectangle.</param>
    /// <param name="srcX1">Specify the right pixel coordinate of the source rectangle.</param>
    /// <param name="srcY1">Specify the top pixel coordinate of the source rectangle.</param>
    /// <param name="dstX0">Specify the left pixel coordinate of the destination rectangle.</param>
    /// <param name="dstY0">Specify the bottom pixel coordinate of the destination rectangle.</param>
    /// <param name="dstX1">Specify the right pixel coordinate of the destination rectangle.</param>
    /// <param name="dstY1">Specify the top pixel coordinate of the destination rectangle.</param>
    /// <param name="mask">
    /// Specifies the bitwise OR of the flags indicating which buffers are to be copied. The allowed flags
    /// are <see cref="IGL.GL_COLOR_BUFFER_BIT"/>, <see cref="IGL.GL_DEPTH_BUFFER_BIT"/> and <see cref="IGL.GL_STENCIL_BUFFER_BIT"/>
    /// .
    /// </param>
    /// <param name="filter">
    /// Specifies the interpolation to be applied if the image is stretched. Must be one of
    /// <see cref="IGL.GL_NEAREST"/> or <see cref="IGL.GL_LINEAR"/>.
    /// </param>
    public void glBlitFramebuffer( GLint srcX0,
                                   GLint srcY0,
                                   GLint srcX1,
                                   GLint srcY1,
                                   GLint dstX0,
                                   GLint dstY0,
                                   GLint dstX1,
                                   GLint dstY1,
                                   GLbitfield mask,
                                   GLenum filter )
    {
        _glBlitFramebuffer( srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height );

    private PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC _glRenderbufferStorageMultisample;

    /// <summary>
    /// Establish data storage, format and dimensions of a renderbuffer object's image.
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the renderbuffer object is bound for storage. Must be
    /// <see cref="IGL.GL_RENDERBUFFER"/>.
    /// </param>
    /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object's storage.</param>
    /// <param name="internalformat">Specifies the internal format to be used for the renderbuffer object's image.</param>
    /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
    /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
    public void glRenderbufferStorageMultisample( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height )
    {
        _glRenderbufferStorageMultisample( target, samples, internalformat, width, height );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLFRAMEBUFFERTEXTURELAYERPROC( GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer );

    private PFNGLFRAMEBUFFERTEXTURELAYERPROC _glFramebufferTextureLayer;

    /// <summary>
    /// Attach a single layer of a texture object as a logical buffer to the currently bound framebuffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the texture should be attached. Must be
    /// <see cref="IGL.GL_FRAMEBUFFER"/>.
    /// </param>
    /// <param name="attachment">Specifies the attachment point of the framebuffer.</param>
    /// <param name="texture">Specifies the name of an existing texture object.</param>
    /// <param name="level">Specifies the mipmap level of the texture image to be attached.</param>
    /// <param name="layer">
    /// Specifies the layer of a 3D texture that is to be attached, if any. Must be a number in the range 0
    /// to the value of <see cref="IGL.GL_MAX_ARRAY_TEXTURE_LAYERS"/> minus 1.
    /// </param>
    public void glFramebufferTextureLayer( GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer )
    {
        _glFramebufferTextureLayer( target, attachment, texture, level, layer );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void* PFNGLMAPBUFFERRANGEPROC( GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access );

    private PFNGLMAPBUFFERRANGEPROC _glMapBufferRange;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Map all or part of a buffer object's data store into the client's address space.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object being mapped. The symbolic constant must be
    /// <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="offset">Specifies the starting offset within the buffer of the range to be mapped.</param>
    /// <param name="length">Specifies the length of the range to be mapped.</param>
    /// <param name="access">Specifies a combination of access flags indicating the desired access to the range.</param>
    /// <returns>Returns a pointer to the beginning of the mapped range.</returns>
    public void* glMapBufferRange( GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access )
    {
        return _glMapBufferRange( target, offset, length, access );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Map all or part of a buffer object's data store into the client's address space.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object being mapped. The symbolic constant must be
    /// <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="offset">Specifies the starting offset within the buffer of the range to be mapped.</param>
    /// <param name="length">Specifies the length of the range to be mapped.</param>
    /// <param name="access">Specifies a combination of access flags indicating the desired access to the range.</param>
    /// <returns>Returns a type-safe and memory-safe <see cref="System.Span{T}"/> of the entire mapped memory.</returns>
    public Span< T > glMapBufferRange< T >( GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access ) where T : unmanaged
    {
        void* ret = _glMapBufferRange( target, offset, length, access );

        return new Span< T >( ret, length );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLFLUSHMAPPEDBUFFERRANGEPROC( GLenum target, GLintptr offset, GLsizeiptr length );

    private PFNGLFLUSHMAPPEDBUFFERRANGEPROC _glFlushMappedBufferRange;

    /// <summary>
    /// Invalidate portions of the buffer object's data store.
    /// </summary>
    /// <param name="target">
    /// Specifies the target buffer object whose data store is to be flushed and/or invalidated. The
    /// symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_READ_BUFFER"/>, <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>,
    /// <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>, <see cref="IGL.GL_TEXTURE_BUFFER"/>,
    /// <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/> or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="offset">
    /// Specifies the offset within the buffer object's data store of the first byte to be flushed and/or
    /// invalidated.
    /// </param>
    /// <param name="length">Specifies the length of the range of bytes to be flushed and/or invalidated.</param>
    public void glFlushMappedBufferRange( GLenum target, GLintptr offset, GLsizeiptr length )
    {
        _glFlushMappedBufferRange( target, offset, length );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDVERTEXARRAYPROC( GLuint array );

    private PFNGLBINDVERTEXARRAYPROC _glBindVertexArray;

    /// <summary>
    /// Bind a vertex array object.
    /// </summary>
    /// <param name="array">Specifies the name of the vertex array to bind.</param>
    public void glBindVertexArray( GLuint array )
    {
        _glBindVertexArray( array );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDELETEVERTEXARRAYSPROC( GLsizei n, GLuint* arrays );

    private PFNGLDELETEVERTEXARRAYSPROC _glDeleteVertexArrays;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Delete vertex array objects.
    /// </summary>
    /// <param name="n">Specifies the number of vertex array objects to be deleted.</param>
    /// <param name="arrays">Specifies an array of <paramref name="n"/> names of vertex array objects to be deleted.</param>
    public void glDeleteVertexArrays( GLsizei n, GLuint* arrays )
    {
        _glDeleteVertexArrays( n, arrays );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Delete vertex array objects.
    /// </summary>
    /// <param name="arrays">Specifies an array of vertex array objects to be deleted.</param>
    public void glDeleteVertexArrays( params GLuint[] arrays )
    {
        fixed ( GLuint* p = &arrays[ 0 ] )
        {
            _glDeleteVertexArrays( arrays.Length, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGENVERTEXARRAYSPROC( GLsizei n, GLuint* arrays );

    private PFNGLGENVERTEXARRAYSPROC _glGenVertexArrays;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate vertex array object names.
    /// </summary>
    /// <param name="n">Specifies the number of vertex array object names to generate.</param>
    /// <param name="arrays">Specifies an array in which the generated vertex array object names are stored.</param>
    public void glGenVertexArrays( GLsizei n, GLuint* arrays )
    {
        _glGenVertexArrays( n, arrays );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate vertex array object names.
    /// </summary>
    /// <param name="n">Specifies the number of vertex array object names to generate.</param>
    /// <returns>Returns an array of <paramref name="n"/> generated vertex array object names.</returns>
    public GLuint[] glGenVertexArrays( GLsizei n )
    {
        var arrays = new GLuint[ n ];

        fixed ( GLuint* p =
                   &arrays[ 0 ] )
        {
            _glGenVertexArrays( n, p );
        }

        return arrays;
    }

    /// <summary>
    /// Generate a single vertex array object name.
    /// </summary>
    /// <returns>Returns a generated vertex array object name.</returns>
    public GLuint glGenVertexArray()
    {
        GLuint array = 0;
        _glGenVertexArrays( 1, &array );

        return array;
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISVERTEXARRAYPROC( GLuint array );

    private PFNGLISVERTEXARRAYPROC _glIsVertexArray;

    /// <summary>
    /// Determine if a name corresponds to a vertex array object.
    /// </summary>
    /// <param name="array">Specifies a value that may be the name of a vertex array object.</param>
    /// <returns>
    /// Returns <see langword="true"/> if <paramref name="array"/> is the name of a vertex array object. Otherwise,
    /// returns <see langword="false"/>.
    /// </returns>
    public GLboolean glIsVertexArray( GLuint array )
    {
        return _glIsVertexArray( array );
    }

#endif

    // OpenGL 3.1

#if OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDRAWARRAYSINSTANCEDPROC( GLenum mode, GLint first, GLsizei count, GLsizei instancecount );

    private PFNGLDRAWARRAYSINSTANCEDPROC _glDrawArraysInstanced;

    /// <summary>
    /// Draw multiple instances of a range of elements
    /// </summary>
    /// <param mode="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param first="first">Specifies the starting index in the enabled arrays.</param>
    /// <param count="count">Specifies the number of indices to be rendered.</param>
    /// <param instancecount="instancecount">
    /// Specifies the number of instances of the specified range of indices to be
    /// rendered.
    /// </param>
    public void glDrawArraysInstanced( GLenum mode, GLint first, GLsizei count, GLsizei instancecount )
    {
        _glDrawArraysInstanced( mode, first, count, instancecount );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDRAWELEMENTSINSTANCEDPROC( GLenum mode, GLsizei count, GLenum type, void* indices, GLsizei instancecount );

    private PFNGLDRAWELEMENTSINSTANCEDPROC _glDrawElementsInstanced;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Draw multiple instances of a set of elements
    /// </summary>
    /// <param mode="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param count="count">Specifies the number of elements to be rendered.</param>
    /// <param type="type">
    /// Specifies the type of the values in indices. Must be one of <see cref="IGL.GL_UNSIGNED_BYTE"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param indices="indices">Specifies a pointer to the location where the indices are stored.</param>
    /// <param instancecount="instancecount">
    /// Specifies the number of instances of the specified range of indices to be
    /// rendered.
    /// </param>
    public void glDrawElementsInstanced( GLenum mode, GLsizei count, GLenum type, void* indices, GLsizei instancecount )
    {
        _glDrawElementsInstanced( mode, count, type, indices, instancecount );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Draw multiple instances of a set of elements
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">
    /// Specifies the type of the values in indices. Must be one of <see cref="IGL.GL_UNSIGNED_BYTE"/>,
    /// <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">
    /// Specifies an array containin the indices. Make sure to match <typeparamref name="T"/> to the
    /// type of the indices.
    /// </param>
    /// <param name="instancecount">Specifies the number of instances of the specified range of indices to be rendered.</param>
    public void glDrawElementsInstanced< T >( GLenum mode, GLsizei count, GLenum type, T[] indices, GLsizei instancecount )
        where T : unmanaged, IUnsignedNumber< T >
    {
        fixed ( T* p
                   = &indices[ 0 ] )
        {
            _glDrawElementsInstanced( mode, count, type, p, instancecount );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXBUFFERPROC( GLenum target, GLenum internalformat, GLuint buffer );

    private PFNGLTEXBUFFERPROC _glTexBuffer;

    /// <summary>
    /// Attach a buffer object's data store to a buffer texture object
    /// </summary>
    /// <param name="target">
    /// Specifies the target to which the buffer object's data store is attached for the purposes of the
    /// specified buffer texture object. target​ must be <see cref="IGL.GL_TEXTURE_BUFFER"/>.
    /// </param>
    /// <param name="internalformat">Specifies the internal format of the data in the store belonging to buffer.</param>
    /// <param name="buffer">
    /// Specifies the name of an existing buffer object whose storage to attach to the specified buffer
    /// texture object.
    /// </param>
    public void glTexBuffer( GLenum target, GLenum internalformat, GLuint buffer )
    {
        _glTexBuffer( target, internalformat, buffer );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPRIMITIVERESTARTINDEXPROC( GLuint index );

    private PFNGLPRIMITIVERESTARTINDEXPROC _glPrimitiveRestartIndex;

    /// <summary>
    /// Specify the primitive restart index
    /// </summary>
    /// <param name="index">Specifies the value to be interpreted as the primitive restart index.</param>
    public void glPrimitiveRestartIndex( GLuint index )
    {
        _glPrimitiveRestartIndex( index );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLCOPYBUFFERSUBDATAPROC( GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size );

    private PFNGLCOPYBUFFERSUBDATAPROC _glCopyBufferSubData;

    /// <summary>
    /// Copy part of a buffer object's data store to the the data store of another buffer object.
    /// </summary>
    /// <param name="readTarget">
    /// Specifies the target from which the data will be copied. The symbolic constant must be
    /// <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>
    /// , <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>, <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>,
    /// <see cref="IGL.GL_TEXTURE_BUFFER"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/>, or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="writeTarget">
    /// Specifies the target to which the data will be copied. The symbolic constant must be
    /// <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>
    /// , <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>, <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>,
    /// <see cref="IGL.GL_TEXTURE_BUFFER"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/>, or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="readOffset">Specifies the offset into the data store of the buffer object containing the data to copy.</param>
    /// <param name="writeOffset">Specifies the offset into the data store of the buffer object into which data will be copied.</param>
    /// <param name="size">Specifies the size in bytes of the data to be copied.</param>
    public void glCopyBufferSubData( GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size )
    {
        _glCopyBufferSubData( readTarget, writeTarget, readOffset, writeOffset, size );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETUNIFORMINDICESPROC( GLuint program, GLsizei uniformCount, GLchar** uniformNames, GLuint* uniformIndices );

    private PFNGLGETUNIFORMINDICESPROC _glGetUniformIndices;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the indices of a number of uniforms within a program object
    /// </summary>
    /// <param name="program">Specifies the name of a program containing uniforms whose indices to retrieve.</param>
    /// <param name="uniformCount">Specifies the number of uniforms whose indices to retrieve.</param>
    /// <param name="uniformNames">Specifies an array of pointers to strings containing the names of the queried uniforms.</param>
    /// <param name="uniformIndices">Specifies an array to receive the indices of the uniforms specified in uniformNames.</param>
    public void glGetUniformIndices( GLuint program, GLsizei uniformCount, GLchar** uniformNames, GLuint* uniformIndices )
    {
        _glGetUniformIndices( program, uniformCount, uniformNames, uniformIndices );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the indices of a number of uniforms within a program object
    /// </summary>
    /// <param name="program">Specifies the name of a program containing uniforms whose indices to retrieve.</param>
    /// <param name="uniformNames">Specifies an array of strings containing the names of the queried uniforms.</param>
    /// <returns>An array of indices of the uniforms specified in uniformNames.</returns>
    public GLuint[] glGetUniformIndices( GLuint program, params string[] uniformNames )
    {
        var uniformCount     = uniformNames.Length;
        var uniformNamesPtrs = new GLchar[ uniformCount ][];

        for ( var i = 0; i < uniformCount; i++ )
        {
            uniformNamesPtrs[ i ] = Encoding.UTF8.GetBytes( uniformNames[ i ] );
        }

        var pUniformNames = stackalloc GLchar*[ uniformCount ];

        for ( var i = 0; i < uniformCount; i++ )
        {
            fixed ( GLchar* p = &uniformNamesPtrs[ i ][ 0 ] )
            {
                pUniformNames[ i ] = p;
            }
        }

        var uniformIndices = new GLuint[ uniformCount ];

        fixed ( GLuint* p = &uniformIndices[ 0 ] )
        {
            _glGetUniformIndices( program, uniformCount, pUniformNames, p );
        }

        return uniformIndices;
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETACTIVEUNIFORMSIVPROC( GLuint program, GLsizei uniformCount, GLuint* uniformIndices, GLenum pname, GLint* parameters );

    private PFNGLGETACTIVEUNIFORMSIVPROC _glGetActiveUniformsiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns information about several active uniform variables for the specified program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="uniformCount">Specifies the number of elements in the array of indices <paramref name="uniformIndices"/>.</param>
    /// <param name="uniformIndices">
    /// Specifies an array of <paramref name="uniformCount"/> integers containing the indices of
    /// the uniform variables to be queried.
    /// </param>
    /// <param name="pname">
    /// Specifies the information to be queried about each uniform variable specified in
    /// <paramref name="uniformIndices"/>.
    /// </param>
    /// <param name="parameters">
    /// Specifies an array of <paramref name="uniformCount"/> integers to receive the information
    /// requested about each uniform variable specified in <paramref name="uniformIndices"/>.
    /// </param>
    public void glGetActiveUniformsiv( GLuint program, GLsizei uniformCount, GLuint* uniformIndices, GLenum pname, GLint* parameters )
    {
        _glGetActiveUniformsiv( program, uniformCount, uniformIndices, pname, parameters );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns information about several active uniform variables for the specified program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="pname">
    /// Specifies the information to be queried about each uniform variable specified in
    /// <paramref name="uniformIndices"/>.
    /// </param>
    /// <param name="uniformIndices">
    /// Specifies an array of integers containing the indices of the uniform variables to be
    /// queried.
    /// </param>
    /// <returns>
    /// An array of integers to receive the information requested about each uniform variable specified in
    /// <paramref name="uniformIndices"/>.
    /// </returns>
    public GLint[] glGetActiveUniformsiv( GLuint program, GLenum pname, params GLuint[] uniformIndices )
    {
        var uniformCount = uniformIndices.Length;
        var parameters   = new GLint[ uniformCount ];

        fixed ( GLuint* p = &uniformIndices[ 0 ] )
        {
            fixed ( GLint* pParameters = &parameters[ 0 ] )
            {
                _glGetActiveUniformsiv( program, uniformCount, p, pname, pParameters );
            }
        }

        return parameters;
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETACTIVEUNIFORMNAMEPROC( GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName );

    private PFNGLGETACTIVEUNIFORMNAMEPROC _glGetActiveUniformName;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the name of an active uniform variable at the specified index within a program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="uniformIndex">Specifies the index of the uniform variable to be queried.</param>
    /// <param name="bufSize">
    /// Specifies the size of the buffer whose address is specified by <paramref name="uniformName"/>,
    /// in characters.
    /// </param>
    /// <param name="length">
    /// Returns the number of characters actually written into the buffer indicated by
    /// <paramref name="uniformName"/>.
    /// </param>
    /// <param name="uniformName">
    /// Returns the name of the uniform variable at the specified index in the program object
    /// specified by <paramref name="program"/>.
    /// </param>
    public void glGetActiveUniformName( GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName )
    {
        _glGetActiveUniformName( program, uniformIndex, bufSize, length, uniformName );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the name of an active uniform variable at the specified index within a program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="uniformIndex">Specifies the index of the uniform variable to be queried.</param>
    /// <param name="bufSize">
    /// Specifies the size of the buffer whose address is specified by <paramref name="uniformName"/>,
    /// in characters.
    /// </param>
    /// <returns>
    /// The name of the uniform variable at the specified index in the program object specified by
    /// <paramref name="program"/>, in the correct size.
    /// </returns>
    public string glGetActiveUniformName( GLuint program, GLuint uniformIndex, GLsizei bufSize )
    {
        var     uniformName = stackalloc GLchar[ bufSize ];
        GLsizei length;
        _glGetActiveUniformName( program, uniformIndex, bufSize, &length, uniformName );

        return new string( ( sbyte* )uniformName, 0, length, Encoding.UTF8 );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLuint PFNGLGETUNIFORMBLOCKINDEXPROC( GLuint program, GLchar* uniformBlockName );

    private PFNGLGETUNIFORMBLOCKINDEXPROC _glGetUniformBlockIndex;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the index of a uniform block within a program
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="uniformBlockName">
    /// Points to a null terminated string containing the name of the uniform block whose index
    /// to query.
    /// </param>
    /// <returns>
    /// The index of the uniform block named <paramref name="uniformBlockName"/> within the program object
    /// <paramref name="program"/>.
    /// </returns>
    public GLuint glGetUniformBlockIndex( GLuint program, GLchar* uniformBlockName )
    {
        return _glGetUniformBlockIndex( program, uniformBlockName );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the index of a uniform block within a program
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="uniformBlockName">Contains the name of the uniform block whose index to query.</param>
    public GLuint glGetUniformBlockIndex( GLuint program, string uniformBlockName )
    {
        var uniformBlockNameBytes = Encoding.UTF8.GetBytes( uniformBlockName );

        fixed ( GLchar* p = &uniformBlockNameBytes[ 0 ] )
        {
            return _glGetUniformBlockIndex( program, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETACTIVEUNIFORMBLOCKIVPROC( GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* parameters );

    private PFNGLGETACTIVEUNIFORMBLOCKIVPROC _glGetActiveUniformBlockiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns information about an active uniform block
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="uniformBlockIndex">
    /// Specifies the index of the uniform block within <paramref name="program"/> whose
    /// information to query.
    /// </param>
    /// <param name="pname">Specifies the specific information to query about the active uniform block.</param>
    /// <param name="parameters">Returns the requested information about the uniform block.</param>
    public void glGetActiveUniformBlockiv( GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* parameters )
    {
        _glGetActiveUniformBlockiv( program, uniformBlockIndex, pname, parameters );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns information about an active uniform block
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="uniformBlockIndex">
    /// Specifies the index of the uniform block within <paramref name="program"/> whose
    /// information to query.
    /// </param>
    /// <param name="pname">Specifies the specific information to query about the active uniform block.</param>
    /// <param name="parameters">Returns the requested information about the uniform block.</param>
    public void glGetActiveUniformBlockiv( GLuint program, GLuint uniformBlockIndex, GLenum pname, ref GLint[] parameters )
    {
        fixed ( GLint* p =
                   &parameters[ 0 ] )
        {
            _glGetActiveUniformBlockiv( program, uniformBlockIndex, pname, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC( GLuint program,
                                                              GLuint uniformBlockIndex,
                                                              GLsizei bufSize,
                                                              GLsizei* length,
                                                              GLchar* uniformBlockName );

    private PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC _glGetActiveUniformBlockName;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the name of an active uniform block at the specified index within a program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="uniformBlockIndex">
    /// Specifies the index of the uniform block within <paramref name="program"/> whose name
    /// to retrieve.
    /// </param>
    /// <param name="bufSize">
    /// Specifies the size of the buffer whose address is specified by
    /// <paramref name="uniformBlockName"/>, in characters.
    /// </param>
    /// <param name="length">Returns the length of the uniform block name.</param>
    /// <param name="uniformBlockName">
    /// Returns the name of the uniform block at the specified index in the program object
    /// specified by <paramref name="program"/>.
    /// </param>
    public void glGetActiveUniformBlockName( GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName )
    {
        _glGetActiveUniformBlockName( program, uniformBlockIndex, bufSize, length, uniformBlockName );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the name of an active uniform block at the specified index within a program object
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="uniformBlockIndex">
    /// Specifies the index of the uniform block within <paramref name="program"/> whose name
    /// to retrieve.
    /// </param>
    /// <param name="bufSize">Specifies a maximum amount of characters OpenGL is allowed to write in the character buffer.</param>
    /// <param name="length">Returns the length of the uniform block name.</param>
    public string glGetActiveUniformBlockName( GLuint program, GLuint uniformBlockIndex, GLsizei bufSize )
    {
        var     uniformBlockName = stackalloc GLchar[ bufSize ];
        GLsizei length;
        _glGetActiveUniformBlockName( program, uniformBlockIndex, bufSize, &length, uniformBlockName );

        return new string( ( sbyte* )uniformBlockName, 0, length, Encoding.UTF8 );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLUNIFORMBLOCKBINDINGPROC( GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding );

    private PFNGLUNIFORMBLOCKBINDINGPROC _glUniformBlockBinding;

    /// <summary>
    /// Assigns a binding point to an active uniform block
    /// </summary>
    /// <param name="program">Specifies the program object containing the active uniform block whose binding to assign.</param>
    /// <param name="uniformBlockIndex">
    /// Specifies the index of the active uniform block within <paramref name="program"/>
    /// whose binding to assign.
    /// </param>
    /// <param name="uniformBlockBinding">
    /// Specifies the binding point to which to bind the uniform block with index
    /// <paramref name="uniformBlockIndex"/> within the program object <paramref name="program"/>.
    /// </param>
    public void glUniformBlockBinding( GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding )
    {
        _glUniformBlockBinding( program, uniformBlockIndex, uniformBlockBinding );
    }

#endif

    // OpenGL 3.2

#if OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDRAWELEMENTSBASEVERTEXPROC( GLenum mode, GLsizei count, GLenum type, void* indices, GLint basevertex );

    private PFNGLDRAWELEMENTSBASEVERTEXPROC _glDrawElementsBaseVertex;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render primitives from array data with a per-element offset.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">
    /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
    /// <param name="basevertex">
    /// Specifies a constant that should be added to each element of <paramref name="indices"/> when
    /// choosing elements from the enabled vertex arrays.
    /// </param>
    public void glDrawElementsBaseVertex( GLenum mode, GLsizei count, GLenum type, void* indices, GLint basevertex )
    {
        _glDrawElementsBaseVertex( mode, count, type, indices, basevertex );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render primitives from array data with a per-element offset.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">
    /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">
    /// Specifies an array of indices. Make sure to match the type <typeparamref name="T"/> with
    /// <paramref name="type"/>.
    /// </param>
    /// <param name="basevertex">
    /// Specifies a constant that should be added to each element of <paramref name="indices"/> when
    /// choosing elements from the enabled vertex arrays.
    /// </param>
    public void glDrawElementsBaseVertex< T >( GLenum mode, GLsizei count, GLenum type, T[] indices, GLint basevertex )
        where T : unmanaged, IUnsignedNumber< T >
    {
        fixed ( void* p
                   = &indices[ 0 ] )
        {
            _glDrawElementsBaseVertex( mode, count, type, p, basevertex );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC( GLenum mode,
                                                                GLuint start,
                                                                GLuint end,
                                                                GLsizei count,
                                                                GLenum type,
                                                                void* indices,
                                                                GLint basevertex );

    private PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC _glDrawRangeElementsBaseVertex;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render primitives from array data with a per-element offset.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="start">Specifies the minimum array index contained in <paramref name="indices"/>.</param>
    /// <param name="end">Specifies the maximum array index contained in <paramref name="indices"/>.</param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">
    /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
    /// <param name="basevertex">
    /// Specifies a constant that should be added to each element of <paramref name="indices"/> when
    /// choosing elements from the enabled vertex arrays.
    /// </param>
    public void glDrawRangeElementsBaseVertex( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void* indices, GLint basevertex )
    {
        _glDrawRangeElementsBaseVertex( mode, start, end, count, type, indices, basevertex );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render primitives from array data with a per-element offset.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="start">Specifies the minimum array index contained in <paramref name="indices"/>.</param>
    /// <param name="end">Specifies the maximum array index contained in <paramref name="indices"/>.</param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">
    /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">
    /// Specifies an array of indices. Make sure to match the type <typeparamref name="T"/> with
    /// <paramref name="type"/>.
    /// </param>
    /// <param name="basevertex">
    /// Specifies a constant that should be added to each element of <paramref name="indices"/> when
    /// choosing elements from the enabled vertex arrays.
    /// </param>
    public void glDrawRangeElementsBaseVertex< T >( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, T[] indices, GLint basevertex )
        where T : unmanaged, IUnsignedNumber< T >
    {
        fixed ( void* p
                   = &indices[ 0 ] )
        {
            _glDrawRangeElementsBaseVertex( mode, start, end, count, type, p, basevertex );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC( GLenum mode,
                                                                    GLsizei count,
                                                                    GLenum type,
                                                                    void* indices,
                                                                    GLsizei instancecount,
                                                                    GLint basevertex );

    private PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC _glDrawElementsInstancedBaseVertex;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render multiple instances of a set of primitives from array data with a per-element offset.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">
    /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
    /// <param name="instancecount">Specifies the number of instances of the indexed geometry that should be drawn.</param>
    /// <param name="basevertex">
    /// Specifies a constant that should be added to each element of <paramref name="indices"/> when
    /// choosing elements from the enabled vertex arrays.
    /// </param>
    public void glDrawElementsInstancedBaseVertex( GLenum mode, GLsizei count, GLenum type, void* indices, GLsizei instancecount, GLint basevertex )
    {
        _glDrawElementsInstancedBaseVertex( mode, count, type, indices, instancecount, basevertex );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render multiple instances of a set of primitives from array data with a per-element offset.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">
    /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">
    /// Specifies an array of indices. Make sure to match the type <typeparamref name="T"/> with
    /// <paramref name="type"/>.
    /// </param>
    /// <param name="instancecount">Specifies the number of instances of the indexed geometry that should be drawn.</param>
    /// <param name="basevertex">
    /// Specifies a constant that should be added to each element of <paramref name="indices"/> when
    /// choosing elements from the enabled vertex arrays.
    /// </param>
    public void glDrawElementsInstancedBaseVertex< T >( GLenum mode, GLsizei count, GLenum type, T[] indices, GLsizei instancecount, GLint basevertex )
        where T : unmanaged, IUnsignedNumber< T >
    {
        fixed ( void* p
                   = &indices[ 0 ] )
        {
            _glDrawElementsInstancedBaseVertex( mode, count, type, p, instancecount, basevertex );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC( GLenum mode,
                                                                GLsizei* count,
                                                                GLenum type,
                                                                void** indices,
                                                                GLsizei drawcount,
                                                                GLint* basevertex );

    private PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC _glMultiDrawElementsBaseVertex;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render multiple sets of primitives from array data with a per-element offset.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="count">Specifies an array of the elements counts.</param>
    /// <param name="type">
    /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">Specifies an array of pointers to the location where the indices are stored.</param>
    /// <param name="drawcount">Specifies the size of the <paramref name="count"/> and <paramref name="basevertex"/> arrays.</param>
    /// <param name="basevertex">
    /// Specifies an array of the constants that should be added to each element of
    /// <paramref name="indices"/> when choosing elements from the enabled vertex arrays.
    /// </param>
    public void glMultiDrawElementsBaseVertex( GLenum mode, GLsizei* count, GLenum type, void** indices, GLsizei drawcount, GLint* basevertex )
    {
        _glMultiDrawElementsBaseVertex( mode, count, type, indices, drawcount, basevertex );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render multiple sets of primitives from array data with a per-element offset.
    /// </summary>
    /// <param name="mode">
    /// Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>,
    /// <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>,
    /// <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>,
    /// <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/> and <see cref="IGL.GL_PATCHES"/> are accepted.
    /// </param>
    /// <param name="type">
    /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
    /// <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.
    /// </param>
    /// <param name="indices">
    /// Specifies an array of arrays of indices. Make sure to match the type <typeparamref name="T"/>
    /// with <paramref name="type"/>.
    /// </param>
    /// <param name="basevertex">
    /// Specifies an array of the constants that should be added to each element of
    /// <paramref name="indices"/> when choosing elements from the enabled vertex arrays.
    /// </param>
    public void glMultiDrawElementsBaseVertex< T >( GLenum mode, GLenum type, T[][] indices, GLint[] basevertex ) where T : unmanaged, IUnsignedNumber< T >
    {
        if ( indices.Length != basevertex.Length )
        {
            throw new ArgumentException( "indices and basevertex must have the same length" );
        }

        var counts    = new GLsizei[ indices.Length ];
        var indexPtrs = new T*[ indices.Length ];

        for ( var i = 0; i < indices.Length; i++ )
        {
            counts[ i ] = indices[ i ].Length;

            fixed ( T* p = &indices[ i ][ 0 ] )
            {
                indexPtrs[ i ] = p;
            }
        }

        fixed ( GLsizei* cp = &counts[ 0 ] )
        {
            fixed ( GLint* bvp = &basevertex[ 0 ] )
            {
                fixed ( T** ip = &indexPtrs[ 0 ] )
                {
                    _glMultiDrawElementsBaseVertex( mode, cp, type, ( void** )ip, indices.Length, bvp );
                }
            }
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLPROVOKINGVERTEXPROC( GLenum mode );

    private PFNGLPROVOKINGVERTEXPROC _glProvokingVertex;

    /// <summary>
    /// Specify the vertex to be used as the source of data for flat shaded varyings.
    /// </summary>
    /// <param name="mode">
    /// Specifies the vertex to be used as the source of data for flat shaded varyings. Must be
    /// <see cref="IGL.GL_FIRST_VERTEX_CONVENTION"/> or <see cref="IGL.GL_LAST_VERTEX_CONVENTION"/>.
    /// </param>
    public void glProvokingVertex( GLenum mode )
    {
        _glProvokingVertex( mode );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void* PFNGLFENCESYNCPROC( GLenum condition, GLbitfield flags );

    private PFNGLFENCESYNCPROC _glFenceSync;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Creates a new sync object and inserts it into the GL command stream.
    /// </summary>
    /// <param name="condition">
    /// Specifies the condition that must be met to set the sync object's state to signaled. Must be
    /// <see cref="IGL.GL_SYNC_GPU_COMMANDS_COMPLETE"/>.
    /// </param>
    /// <param name="flags">
    /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are
    /// presently defined for this operation and <paramref name="flags"/> must be zero.
    /// </param>
    /// <returns>The sync object.</returns>
    public void* glFenceSync( GLenum condition, GLbitfield flags )
    {
        return _glFenceSync( condition, flags );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Creates a new sync object and inserts it into the GL command stream.
    /// </summary>
    /// <param name="condition">
    /// Specifies the condition that must be met to set the sync object's state to signaled. Must be
    /// <see cref="IGL.GL_SYNC_GPU_COMMANDS_COMPLETE"/>.
    /// </param>
    /// <param name="flags">
    /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are
    /// presently defined for this operation and <paramref name="flags"/> must be zero.
    /// </param>
    /// <returns>The sync object.</returns>
    public IntPtr glFenceSyncSafe( GLenum condition, GLbitfield flags )
    {
        return new IntPtr( _glFenceSync( condition, flags ) );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISSYNCPROC( void* sync );

    private PFNGLISSYNCPROC _glIsSync;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Determines if a name corresponds to a sync object.
    /// </summary>
    /// <param name="sync">Specifies a value that may be the name of a sync object.</param>
    /// <returns>
    /// <see langword="true"/> if <paramref name="sync"/> is a name of a sync object. Otherwise,
    /// <see langword="false"/>.
    /// </returns>
    public GLboolean glIsSync( void* sync )
    {
        return _glIsSync( sync );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Determines if a name corresponds to a sync object.
    /// </summary>
    /// <param name="sync">Specifies a value that may be the name of a sync object.</param>
    /// <returns>
    /// <see langword="true"/> if <paramref name="sync"/> is a name of a sync object. Otherwise,
    /// <see langword="false"/>.
    /// </returns>
    public GLboolean glIsSyncSafe( IntPtr sync )
    {
        return _glIsSync( sync.ToPointer() );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDELETESYNCPROC( void* sync );

    private PFNGLDELETESYNCPROC _glDeleteSync;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Deletes a sync object.
    /// </summary>
    /// <param name="sync">Specifies the sync object to be deleted.</param>
    public void glDeleteSync( void* sync )
    {
        _glDeleteSync( sync );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Deletes a sync object.
    /// </summary>
    /// <param name="sync">Specifies the sync object to be deleted.</param>
    public void glDeleteSyncSafe( IntPtr sync )
    {
        _glDeleteSync( sync.ToPointer() );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLenum PFNGLCLIENTWAITSYNCPROC( void* sync, GLbitfield flags, GLuint64 timeout );

    private PFNGLCLIENTWAITSYNCPROC _glClientWaitSync;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Causes the client to block and wait for a sync object to become signaled.
    /// </summary>
    /// <param name="sync">Specifies the sync object whose status to wait on.</param>
    /// <param name="flags">
    /// A bitfield controlling the command flushing behavior. <paramref name="flags"/> may be
    /// <see cref="IGL.GL_SYNC_FLUSH_COMMANDS_BIT"/> or zero.
    /// </param>
    /// <param name="timeout">
    /// The timeout, specified in nanoseconds, for which the implementation should wait for
    /// <paramref name="sync"/> to become signaled.
    /// </param>
    /// <returns>
    /// One of <see cref="IGL.GL_ALREADY_SIGNALED"/>, <see cref="IGL.GL_TIMEOUT_EXPIRED"/>,
    /// <see cref="IGL.GL_CONDITION_SATISFIED"/>, or <see cref="IGL.GL_WAIT_FAILED"/>.
    /// </returns>
    public GLenum glClientWaitSync( void* sync, GLbitfield flags, GLuint64 timeout )
    {
        return _glClientWaitSync( sync, flags, timeout );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Causes the client to block and wait for a sync object to become signaled.
    /// </summary>
    /// <param name="sync">Specifies the sync object whose status to wait on.</param>
    /// <param name="flags">
    /// A bitfield controlling the command flushing behavior. <paramref name="flags"/> may be
    /// <see cref="IGL.GL_SYNC_FLUSH_COMMANDS_BIT"/> or zero.
    /// </param>
    /// <param name="timeout">
    /// The timeout, specified in nanoseconds, for which the implementation should wait for
    /// <paramref name="sync"/> to become signaled.
    /// </param>
    /// <returns>
    /// One of <see cref="IGL.GL_ALREADY_SIGNALED"/>, <see cref="IGL.GL_TIMEOUT_EXPIRED"/>,
    /// <see cref="IGL.GL_CONDITION_SATISFIED"/>, or <see cref="IGL.GL_WAIT_FAILED"/>.
    /// </returns>
    public GLenum glClientWaitSyncSafe( IntPtr sync, GLbitfield flags, GLuint64 timeout )
    {
        return _glClientWaitSync( sync.ToPointer(), flags, timeout );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLWAITSYNCPROC( void* sync, GLbitfield flags, GLuint64 timeout );

    private PFNGLWAITSYNCPROC _glWaitSync;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Causes the server to block and wait for a sync object to become signaled.
    /// </summary>
    /// <param name="sync">Specifies the sync object whose status to wait on.</param>
    /// <param name="flags">A bitfield controlling the command flushing behavior. <paramref name="flags"/> must be zero.</param>
    /// <param name="timeout">
    /// The timeout, specified in nanoseconds, for which the implementation should wait for
    /// <paramref name="sync"/> to become signaled.
    /// </param>
    public void glWaitSync( void* sync, GLbitfield flags, GLuint64 timeout )
    {
        _glWaitSync( sync, flags, timeout );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Causes the server to block and wait for a sync object to become signaled.
    /// </summary>
    /// <param name="sync">Specifies the sync object whose status to wait on.</param>
    /// <param name="flags">A bitfield controlling the command flushing behavior. <paramref name="flags"/> must be zero.</param>
    /// <param name="timeout">
    /// The timeout, specified in nanoseconds, for which the implementation should wait for
    /// <paramref name="sync"/> to become signaled.
    /// </param>
    public void glWaitSyncSafe( IntPtr sync, GLbitfield flags, GLuint64 timeout )
    {
        _glWaitSync( sync.ToPointer(), flags, timeout );
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETINTEGER64VPROC( GLenum pname, GLint64* data );

    private PFNGLGETINTEGER64VPROC _glGetInteger64v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the 64bit integer value or values of a selected parameter.
    /// </summary>
    /// <param name="pname">
    /// Specifies the parameter value to be returned. Refer to <see href="https://docs.gl/gl4/glGet"/> for
    /// a list of possible values.
    /// </param>
    /// <param name="data">Returns the value or values of the specified parameter.</param>
    public void glGetInteger64v( GLenum pname, GLint64* data )
    {
        _glGetInteger64v( pname, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the 64bit integer value or values of a selected parameter.
    /// </summary>
    /// <param name="pname">
    /// Specifies the parameter value to be returned. Refer to <see href="https://docs.gl/gl4/glGet"/> for
    /// a list of possible values.
    /// </param>
    /// <param name="data">Returns the value or values of the specified parameter.</param>
    public void glGetInteger64v( GLenum pname, ref GLint64[] data )
    {
        fixed ( GLint64* dp = &data[ 0 ] )
        {
            _glGetInteger64v( pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETSYNCIVPROC( void* sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values );

    private PFNGLGETSYNCIVPROC _glGetSynciv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Query the properties of a sync object.
    /// </summary>
    /// <param name="sync">Specifies the sync object whose properties to query.</param>
    /// <param name="pname">
    /// Specifies the parameter whose value to retrieve from the sync object indicated by
    /// <paramref name="sync"/>. Allowed values are <see cref="IGL.GL_OBJECT_TYPE"/>, <see cref="IGL.GL_SYNC_STATUS"/>,
    /// <see cref="IGL.GL_SYNC_CONDITION"/>, <see cref="IGL.GL_SYNC_FLAGS"/>.
    /// </param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given by <paramref name="values"/>.</param>
    /// <param name="length">Returns the number of integers placed in <paramref name="values"/>.</param>
    /// <param name="values">Returns the requested parameter.</param>
    public void glGetSynciv( void* sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values )
    {
        _glGetSynciv( sync, pname, bufSize, length, values );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Query the properties of a sync object.
    /// </summary>
    /// <param name="sync">Specifies the sync object whose properties to query.</param>
    /// <param name="pname">
    /// Specifies the parameter whose value to retrieve from the sync object indicated by
    /// <paramref name="sync"/>. Allowed values are <see cref="IGL.GL_OBJECT_TYPE"/>, <see cref="IGL.GL_SYNC_STATUS"/>,
    /// <see cref="IGL.GL_SYNC_CONDITION"/>, <see cref="IGL.GL_SYNC_FLAGS"/>.
    /// </param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given by <paramref name="values"/>.</param>
    /// <returns>Returns the requested parameter(s).</returns>
    public GLint[] glGetSynciv( IntPtr sync, GLenum pname, GLsizei bufSize )
    {
        var ret = new GLint[ bufSize ];

        fixed ( GLint* dp = &ret[ 0 ] )
        {
            GLsizei len;
            _glGetSynciv( sync.ToPointer(), pname, bufSize, &len, dp );
            Array.Resize( ref ret, len );
        }

        return ret;
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETINTEGER64I_VPROC( GLenum target, GLuint index, GLint64* data );

    private PFNGLGETINTEGER64I_VPROC _glGetInteger64i_v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the 64bit integer value or values of a selected parameter.
    /// </summary>
    /// <param name="target">
    /// Specifies the target of which the indexed parameter <paramref name="index"/> is to be returned.
    /// Refer to <see href="https://docs.gl/gl4/glGet"/> for a list of possible values.
    /// </param>
    /// <param name="index">Specifies the index of the value to be returned.</param>
    /// <param name="data">Returns the value or values of the specified parameter.</param>
    public void glGetInteger64i_v( GLenum target, GLuint index, GLint64* data )
    {
        _glGetInteger64i_v( target, index, data );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the 64bit integer value or values of a selected parameter.
    /// </summary>
    /// <param name="target">
    /// Specifies the target of which the indexed parameter <paramref name="index"/> is to be returned.
    /// Refer to <see href="https://docs.gl/gl4/glGet"/> for a list of possible values.
    /// </param>
    /// <param name="index">Specifies the index of the value to be returned.</param>
    /// <param name="data">Returns the value or values of the specified parameter.</param>
    public void glGetInteger64i_v( GLenum target, GLuint index, ref GLint64[] data )
    {
        fixed ( GLint64* dp =
                   &data[ 0 ] )
        {
            _glGetInteger64i_v( target, index, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETBUFFERPARAMETERI64VPROC( GLenum target, GLenum pname, GLint64* parameters );

    private PFNGLGETBUFFERPARAMETERI64VPROC _glGetBufferParameteri64v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the value or values of a selected parameter.
    /// </summary>
    /// <param name="target">
    /// . Specifies the target to which the buffer object is bound. Must be one of
    /// <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>
    /// , <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>, <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>,
    /// <see cref="IGL.GL_TEXTURE_BUFFER"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/>, or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a buffer object parameter. Accepted values are
    /// <see cref="IGL.GL_BUFFER_ACCESS"/>, <see cref="IGL.GL_BUFFER_ACCESS_FLAGS"/>, <see cref="IGL.GL_BUFFER_IMMUTABLE_STORAGE"/>,
    /// <see cref="IGL.GL_BUFFER_MAPPED"/>, <see cref="IGL.GL_BUFFER_MAP_LENGTH"/>, <see cref="IGL.GL_BUFFER_MAP_OFFSET"/>,
    /// <see cref="IGL.GL_BUFFER_SIZE"/>, <see cref="IGL.GL_BUFFER_STORAGE_FLAGS"/>, <see cref="IGL.GL_BUFFER_USAGE"/>.
    /// </param>
    /// <param name="parameters">Returns the requested parameter.</param>
    public void glGetBufferParameteri64v( GLenum target, GLenum pname, GLint64* parameters )
    {
        _glGetBufferParameteri64v( target, pname, parameters );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the value or values of a selected parameter.
    /// </summary>
    /// <param name="target">
    /// . Specifies the target to which the buffer object is bound. Must be one of
    /// <see cref="IGL.GL_ARRAY_BUFFER"/>, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER"/>, <see cref="IGL.GL_COPY_READ_BUFFER"/>,
    /// <see cref="IGL.GL_COPY_WRITE_BUFFER"/>, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER"/>,
    /// <see cref="IGL.GL_DRAW_INDIRECT_BUFFER"/>, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/>, <see cref="IGL.GL_PIXEL_PACK_BUFFER"/>
    /// , <see cref="IGL.GL_PIXEL_UNPACK_BUFFER"/>, <see cref="IGL.GL_QUERY_BUFFER"/>, <see cref="IGL.GL_SHADER_STORAGE_BUFFER"/>,
    /// <see cref="IGL.GL_TEXTURE_BUFFER"/>, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER"/>, or <see cref="IGL.GL_UNIFORM_BUFFER"/>.
    /// </param>
    /// <param name="pname">
    /// Specifies the symbolic name of a buffer object parameter. Accepted values are
    /// <see cref="IGL.GL_BUFFER_ACCESS"/>, <see cref="IGL.GL_BUFFER_ACCESS_FLAGS"/>, <see cref="IGL.GL_BUFFER_IMMUTABLE_STORAGE"/>,
    /// <see cref="IGL.GL_BUFFER_MAPPED"/>, <see cref="IGL.GL_BUFFER_MAP_LENGTH"/>, <see cref="IGL.GL_BUFFER_MAP_OFFSET"/>,
    /// <see cref="IGL.GL_BUFFER_SIZE"/>, <see cref="IGL.GL_BUFFER_STORAGE_FLAGS"/>, <see cref="IGL.GL_BUFFER_USAGE"/>.
    /// </param>
    /// <param name="parameters">Returns the requested parameter.</param>
    public void glGetBufferParameteri64v( GLenum target, GLenum pname, ref GLint64[] parameters )
    {
        fixed ( GLint64* dp =
                   &parameters[ 0 ] )
        {
            _glGetBufferParameteri64v( target, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLFRAMEBUFFERTEXTUREPROC( GLenum target, GLenum attachment, GLuint texture, GLint level );

    private PFNGLFRAMEBUFFERTEXTUREPROC _glFramebufferTexture;

    /// <summary>
    /// Attaches a level of a texture object as a logical buffer to the currently bound framebuffer object.
    /// </summary>
    /// <param name="target">
    /// Specifies the framebuffer target. Must be <see cref="IGL.GL_DRAW_FRAMEBUFFER"/>,
    /// <see cref="IGL.GL_READ_FRAMEBUFFER"/> or <see cref="IGL.GL_FRAMEBUFFER"/>.
    /// </param>
    /// <param name="attachment">
    /// Specifies the attachment point of the framebuffer. Must be one of
    /// <see cref="IGL.GL_COLOR_ATTACHMENT0"/> through <see cref="IGL.GL_COLOR_ATTACHMENT31"/>,
    /// <see cref="IGL.GL_DEPTH_ATTACHMENT"/>, <see cref="IGL.GL_STENCIL_ATTACHMENT"/>,
    /// <see cref="IGL.GL_DEPTH_STENCIL_ATTACHMENT"/>.
    /// </param>
    /// <param name="texture">Specifies the texture object whose image is to be attached.</param>
    /// <param name="level">Specifies the mipmap level of the texture object to be attached.</param>
    public void glFramebufferTexture( GLenum target, GLenum attachment, GLuint texture, GLint level )
    {
        _glFramebufferTexture( target, attachment, texture, level );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXIMAGE2DMULTISAMPLEPROC( GLenum target,
                                                          GLsizei samples,
                                                          GLenum internalformat,
                                                          GLsizei width,
                                                          GLsizei height,
                                                          GLboolean fixedsamplelocations );

    private PFNGLTEXIMAGE2DMULTISAMPLEPROC _glTexImage2DMultisample;

    /// <summary>
    /// Establishes the data storage, format, dimensions, and number of samples of a multisample texture's image.
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the operation. Must be <see cref="IGL.GL_TEXTURE_2D_MULTISAMPLE"/> or
    /// <see cref="IGL.GL_PROXY_TEXTURE_2D_MULTISAMPLE"/>.
    /// </param>
    /// <param name="samples">Specifies the number of samples in the multisample texture's image.</param>
    /// <param name="internalformat">Specifies the internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the multisample texture's image, in texels.</param>
    /// <param name="height">Specifies the height of the multisample texture's image, in texels.</param>
    /// <param name="fixedsamplelocations">
    /// Specifies whether the image will use identical sample locations and the same number
    /// of samples for all texels in the image, and the sample locations will not depend on the internal format or size of
    /// the image.
    /// </param>
    public void glTexImage2DMultisample( GLenum target,
                                         GLsizei samples,
                                         GLenum internalformat,
                                         GLsizei width,
                                         GLsizei height,
                                         GLboolean fixedsamplelocations )
    {
        _glTexImage2DMultisample( target, samples, internalformat, width, height, fixedsamplelocations );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLTEXIMAGE3DMULTISAMPLEPROC( GLenum target,
                                                          GLsizei samples,
                                                          GLenum internalformat,
                                                          GLsizei width,
                                                          GLsizei height,
                                                          GLsizei depth,
                                                          GLboolean fixedsamplelocations );

    private PFNGLTEXIMAGE3DMULTISAMPLEPROC _glTexImage3DMultisample;

    /// <summary>
    /// Establishes the data storage, format, dimensions, and number of samples of a multisample texture's image.
    /// </summary>
    /// <param name="target">
    /// Specifies the target of the operation. Must be <see cref="IGL.GL_TEXTURE_3D_MULTISAMPLE"/> or
    /// <see cref="IGL.GL_PROXY_TEXTURE_3D_MULTISAMPLE"/>.
    /// </param>
    /// <param name="samples">Specifies the number of samples in the multisample texture's image.</param>
    /// <param name="internalformat">Specifies the internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the multisample texture's image, in texels.</param>
    /// <param name="height">Specifies the height of the multisample texture's image, in texels.</param>
    /// <param name="depth">Specifies the depth of the multisample texture's image, in texels.</param>
    /// <param name="fixedsamplelocations">
    /// Specifies whether the image will use identical sample locations and the same number
    /// of samples for all texels in the image, and the sample locations will not depend on the internal format or size of
    /// the image.
    /// </param>
    public void glTexImage3DMultisample( GLenum target,
                                         GLsizei samples,
                                         GLenum internalformat,
                                         GLsizei width,
                                         GLsizei height,
                                         GLsizei depth,
                                         GLboolean fixedsamplelocations )
    {
        _glTexImage3DMultisample( target, samples, internalformat, width, height, depth, fixedsamplelocations );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETMULTISAMPLEFVPROC( GLenum pname, GLuint index, GLfloat* val );

    private PFNGLGETMULTISAMPLEFVPROC _glGetMultisamplefv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns the location of a sample.
    /// </summary>
    /// <param name="pname">Specifies the sample parameter to query. Must be <see cref="IGL.GL_SAMPLE_POSITION"/>.</param>
    /// <param name="index">Specifies the index of the sample.</param>
    /// <param name="val">Specifies the address of an array to receive the location of the sample.</param>
    public void glGetMultisamplefv( GLenum pname, GLuint index, GLfloat* val )
    {
        _glGetMultisamplefv( pname, index, val );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns the location of a sample.
    /// </summary>
    /// <param name="pname">Specifies the sample parameter to query. Must be <see cref="IGL.GL_SAMPLE_POSITION"/>.</param>
    /// <param name="index">Specifies the index of the sample.</param>
    /// <param name="val">Specifies the address of an array to receive the location of the sample.</param>
    public void glGetMultisamplefvSafe( GLenum pname, GLuint index, ref GLfloat[] val )
    {
        fixed ( GLfloat* dp =
                   &val[ 0 ] )
        {
            _glGetMultisamplefv( pname, index, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSAMPLEMASKIPROC( GLuint maskNumber, GLbitfield mask );

    private PFNGLSAMPLEMASKIPROC _glSampleMaski;

    /// <summary>
    /// Controls the writing of individual bits in a logical multisample color sample.
    /// </summary>
    /// <param name="maskNumber">Specifies which 32-bit sub-word of the sample mask to update.</param>
    /// <param name="mask">Specifies a mask to enable and disable sample coverage.</param>
    public void glSampleMaski( GLuint maskNumber, GLbitfield mask )
    {
        _glSampleMaski( maskNumber, mask );
    }

#endif

    // OpenGL 3.3

#if OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDFRAGDATALOCATIONINDEXEDPROC( GLuint program, GLuint colorNumber, GLuint index, GLchar* name );

    private PFNGLBINDFRAGDATALOCATIONINDEXEDPROC _glBindFragDataLocationIndexed;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Bind a user-defined varying out variable to a fragment shader color number and index.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing varying out variable whose binding to modify.</param>
    /// <param name="colorNumber">Specifies the color number to bind the user-defined varying out variable to.</param>
    /// <param name="index">Specifies the index of the color number to bind the user-defined varying out variable to.</param>
    /// <param name="name">Specifies the name of the user-defined varying out variable whose binding to modify.</param>
    public void glBindFragDataLocationIndexed( GLuint program, GLuint colorNumber, GLuint index, GLchar* name )
    {
        _glBindFragDataLocationIndexed( program, colorNumber, index, name );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Bind a user-defined varying out variable to a fragment shader color number and index.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing varying out variable whose binding to modify.</param>
    /// <param name="colorNumber">Specifies the color number to bind the user-defined varying out variable to.</param>
    /// <param name="index">Specifies the index of the color number to bind the user-defined varying out variable to.</param>
    /// <param name="name">Specifies the name of the user-defined varying out variable whose binding to modify.</param>
    public void glBindFragDataLocationIndexed( GLuint program, GLuint colorNumber, GLuint index, string name )
    {
        var nameBytes = Encoding.UTF8.GetBytes( name );

        fixed ( GLchar* p = &nameBytes[ 0 ] )
        {
            _glBindFragDataLocationIndexed( program, colorNumber, index, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLint PFNGLGETFRAGDATAINDEXPROC( GLuint program, GLchar* name );

    private PFNGLGETFRAGDATAINDEXPROC _glGetFragDataIndex;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the index of a user-defined varying out variable.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing varying out variable whose index to query.</param>
    /// <param name="name">Specifies the name of the user-defined varying out variable whose index to query.</param>
    /// <returns>The index of the user-defined varying out variable.</returns>
    public GLint glGetFragDataIndex( GLuint program, GLchar* name )
    {
        return _glGetFragDataIndex( program, name );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the index of a user-defined varying out variable.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing varying out variable whose index to query.</param>
    /// <param name="name">Specifies the name of the user-defined varying out variable whose index to query.</param>
    /// <returns>The index of the user-defined varying out variable.</returns>
    public GLint glGetFragDataIndex( GLuint program, string name )
    {
        var nameBytes = Encoding.UTF8.GetBytes( name );

        fixed ( GLchar* p = &nameBytes[ 0 ] )
        {
            return _glGetFragDataIndex( program, p );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGENSAMPLERSPROC( GLsizei count, GLuint* samplers );

    private PFNGLGENSAMPLERSPROC _glGenSamplers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate sampler object names.
    /// </summary>
    /// <param name="count">Specifies the number of sampler object names to generate.</param>
    /// <param name="samplers">Specifies an array in which the generated sampler object names are stored.</param>
    public void glGenSamplers( GLsizei count, GLuint* samplers )
    {
        _glGenSamplers( count, samplers );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate sampler object names.
    /// </summary>
    /// <param name="count">Specifies the number of sampler object names to generate.</param>
    /// <returns>An array in which the generated sampler object names are stored.</returns>
    public GLuint[] glGenSamplers( GLsizei count )
    {
        var result = new GLuint[ count ];

        fixed ( GLuint* dp =
                   &result[ 0 ] )
        {
            _glGenSamplers( count, dp );
        }

        return result;
    }

    /// <summary>
    /// Generate a single sampler object name.
    /// </summary>
    /// <returns>The generated sampler object name.</returns>
    public GLuint glGenSampler()
    {
        return glGenSamplers( 1 )[ 0 ];
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLDELETESAMPLERSPROC( GLsizei count, GLuint* samplers );

    private PFNGLDELETESAMPLERSPROC _glDeleteSamplers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Delete named sampler objects.
    /// </summary>
    /// <param name="count">Specifies the number of sampler objects to be deleted.</param>
    /// <param name="samplers">Specifies an array of sampler objects to be deleted.</param>
    public void glDeleteSamplers( GLsizei count, GLuint* samplers )
    {
        _glDeleteSamplers( count, samplers );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Delete named sampler objects.
    /// </summary>
    /// <param name="samplers">Specifies an array of sampler objects to be deleted.</param>
    public void glDeleteSamplers( params GLuint[] samplers )
    {
        fixed ( GLuint* dp = &samplers[ 0 ] )
        {
            _glDeleteSamplers( samplers.Length, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate GLboolean PFNGLISSAMPLERPROC( GLuint sampler );

    private PFNGLISSAMPLERPROC _glIsSampler;

    /// <summary>
    /// Determine if a name corresponds to a sampler object.
    /// </summary>
    /// <param name="sampler">Specifies a value that may be the name of a sampler object.</param>
    /// <returns>
    /// <see langword="true"/> if <paramref name="sampler"/> is a value generated by OpenGL; otherwise,
    /// <see langword="false"/>.
    /// </returns>
    public GLboolean glIsSampler( GLuint sampler )
    {
        return _glIsSampler( sampler );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLBINDSAMPLERPROC( GLuint unit, GLuint sampler );

    private PFNGLBINDSAMPLERPROC _glBindSampler;

    /// <summary>
    /// Bind a named sampler to a texturing unit.
    /// </summary>
    /// <param name="unit">Specifies the index of the texture unit to which the sampler is bound.</param>
    /// <param name="sampler">Specifies the name of a sampler.</param>
    public void glBindSampler( GLuint unit, GLuint sampler )
    {
        _glBindSampler( unit, sampler );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSAMPLERPARAMETERIPROC( GLuint sampler, GLenum pname, GLint param );

    private PFNGLSAMPLERPARAMETERIPROC _glSamplerParameteri;

    /// <summary>
    /// Set the integer value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to modify.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glSamplerParameteri( GLuint sampler, GLenum pname, GLint param )
    {
        _glSamplerParameteri( sampler, pname, param );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSAMPLERPARAMETERIVPROC( GLuint sampler, GLenum pname, GLint* param );

    private PFNGLSAMPLERPARAMETERIVPROC _glSamplerParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set the integer value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to modify.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glSamplerParameteriv( GLuint sampler, GLenum pname, GLint* param )
    {
        _glSamplerParameteriv( sampler, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set the integer value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to modify.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glSamplerParameteriv( GLuint sampler, GLenum pname, GLint[] param )
    {
        fixed ( GLint* dp =
                   &param[ 0 ] )
        {
            _glSamplerParameteriv( sampler, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSAMPLERPARAMETERFPROC( GLuint sampler, GLenum pname, GLfloat param );

    private PFNGLSAMPLERPARAMETERFPROC _glSamplerParameterf;

    /// <summary>
    /// Set the float value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to modify.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glSamplerParameterf( GLuint sampler, GLenum pname, GLfloat param )
    {
        _glSamplerParameterf( sampler, pname, param );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSAMPLERPARAMETERFVPROC( GLuint sampler, GLenum pname, GLfloat* param );

    private PFNGLSAMPLERPARAMETERFVPROC _glSamplerParameterfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set the float value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to modify.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glSamplerParameterfv( GLuint sampler, GLenum pname, GLfloat* param )
    {
        _glSamplerParameterfv( sampler, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set the float value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to modify.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glSamplerParameterfv( GLuint sampler, GLenum pname, GLfloat[] param )
    {
        fixed ( GLfloat* dp =
                   &param[ 0 ] )
        {
            _glSamplerParameterfv( sampler, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSAMPLERPARAMETERIIVPROC( GLuint sampler, GLenum pname, GLint* param );

    private PFNGLSAMPLERPARAMETERIIVPROC _glSamplerParameterIiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set the integer value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to modify.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glSamplerParameterIiv( GLuint sampler, GLenum pname, GLint* param )
    {
        _glSamplerParameterIiv( sampler, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set the integer value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to modify.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glSamplerParameterIiv( GLuint sampler, GLenum pname, GLint[] param )
    {
        fixed ( GLint* dp =
                   &param[ 0 ] )
        {
            _glSamplerParameterIiv( sampler, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLSAMPLERPARAMETERIUIVPROC( GLuint sampler, GLenum pname, GLuint* param );

    private PFNGLSAMPLERPARAMETERIUIVPROC _glSamplerParameterIuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set the unsigned integer value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to modify.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glSamplerParameterIuiv( GLuint sampler, GLenum pname, GLuint* param )
    {
        _glSamplerParameterIuiv( sampler, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set the unsigned integer value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to modify.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Specifies the value of <paramref name="pname"/>.</param>
    public void glSamplerParameterIuiv( GLuint sampler, GLenum pname, GLuint[] param )
    {
        fixed ( GLuint* dp =
                   &param[ 0 ] )
        {
            _glSamplerParameterIuiv( sampler, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETSAMPLERPARAMETERIVPROC( GLuint sampler, GLenum pname, GLint* param );

    private PFNGLGETSAMPLERPARAMETERIVPROC _glGetSamplerParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the integer value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to query.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Returns the value of <paramref name="pname"/>.</param>
    public void glGetSamplerParameteriv( GLuint sampler, GLenum pname, GLint* param )
    {
        _glGetSamplerParameteriv( sampler, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the value of a sampler parameter.
    /// </summary>
    /// <param name="sampler">Specifies the name of the sampler object whose parameter to query.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a single-valued sampler parameter. One of
    /// <see cref="IGL.GL_TEXTURE_WRAP_S"/>, <see cref="IGL.GL_TEXTURE_WRAP_T"/>, <see cref="IGL.GL_TEXTURE_WRAP_R"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_FILTER"/>, <see cref="IGL.GL_TEXTURE_MAG_FILTER"/>, <see cref="IGL.GL_TEXTURE_BORDER_COLOR"/>,
    /// <see cref="IGL.GL_TEXTURE_MIN_LOD"/>, <see cref="IGL.GL_TEXTURE_MAX_LOD"/>, <see cref="IGL.GL_TEXTURE_LOD_BIAS"/>,
    /// <see cref="IGL.GL_TEXTURE_COMPARE_MODE"/>, <see cref="IGL.GL_TEXTURE_COMPARE_FUNC"/>.
    /// </param>
    /// <param name="param">Returns the value of <paramref name="pname"/>.</param>
    public void glGetSamplerParameteriv( GLuint sampler, GLenum pname, ref GLint[] param )
    {
        fixed ( GLint* dp =
                   &param[ 0 ] )
        {
            _glGetSamplerParameteriv( sampler, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETSAMPLERPARAMETERIIVPROC( GLuint sampler, GLenum pname, GLint* param );

    private PFNGLGETSAMPLERPARAMETERIIVPROC _glGetSamplerParameterIiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <inheritdoc cref="glGetSamplerParameteriv(GLuint, GLenum, GLint*)"/>
    public void glGetSamplerParameterIiv( GLuint sampler, GLenum pname, GLint* param )
    {
        _glGetSamplerParameterIiv( sampler, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <inheritdoc cref="glGetSamplerParameteriv(GLuint, GLenum, ref GLint[])"/>
    public void glGetSamplerParameterIiv( GLuint sampler, GLenum pname, ref GLint[] param )
    {
        fixed ( GLint* dp =
                   &param[ 0 ] )
        {
            _glGetSamplerParameterIiv( sampler, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETSAMPLERPARAMETERFVPROC( GLuint sampler, GLenum pname, GLfloat* param );

    private PFNGLGETSAMPLERPARAMETERFVPROC _glGetSamplerParameterfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <inheritdoc cref="glGetSamplerParameteriv(GLuint, GLenum, GLint*)"/>
    public void glGetSamplerParameterfv( GLuint sampler, GLenum pname, GLfloat* param )
    {
        _glGetSamplerParameterfv( sampler, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <inheritdoc cref="glGetSamplerParameteriv(GLuint, GLenum, ref GLint[])"/>
    public void glGetSamplerParameterfv( GLuint sampler, GLenum pname, ref GLfloat[] param )
    {
        fixed ( GLfloat* dp =
                   &param[ 0 ] )
        {
            _glGetSamplerParameterfv( sampler, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETSAMPLERPARAMETERIUIVPROC( GLuint sampler, GLenum pname, GLuint* param );

    private PFNGLGETSAMPLERPARAMETERIUIVPROC _glGetSamplerParameterIuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <inheritdoc cref="glGetSamplerParameteriv(GLuint, GLenum, GLint*)"/>
    public void glGetSamplerParameterIuiv( GLuint sampler, GLenum pname, GLuint* param )
    {
        _glGetSamplerParameterIuiv( sampler, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <inheritdoc cref="glGetSamplerParameteriv(GLuint, GLenum, ref GLint[])"/>
    public void glGetSamplerParameterIuiv( GLuint sampler, GLenum pname, ref GLuint[] param )
    {
        fixed ( GLuint* dp =
                   &param[ 0 ] )
        {
            _glGetSamplerParameterIuiv( sampler, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLQUERYCOUNTERPROC( GLuint id, GLenum target );

    private PFNGLQUERYCOUNTERPROC _glQueryCounter;

    /// <summary>
    /// Record the GL time into a query object after all previous commands have reached the GL server but have not yet
    /// necessarily executed.
    /// </summary>
    /// <param name="id">Specifies the name of a query object into which to record the GL time.</param>
    /// <param name="target">Specifies the counter to use as the source of the time.</param>
    public void glQueryCounter( GLuint id, GLenum target )
    {
        _glQueryCounter( id, target );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETQUERYOBJECTI64VPROC( GLuint id, GLenum pname, GLint64* param );

    private PFNGLGETQUERYOBJECTI64VPROC _glGetQueryObjecti64v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the 64bit integer value of a query object parameter.
    /// </summary>
    /// <param name="id">Specifies the name of a query object.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a query object parameter. One of <see cref="IGL.GL_QUERY_RESULT"/>,
    /// <see cref="IGL.GL_QUERY_RESULT_NO_WAIT"/> or <see cref="IGL.GL_QUERY_RESULT_AVAILABLE"/>.
    /// </param>
    /// <param name="param">Returns the value of <paramref name="pname"/>.</param>
    public void glGetQueryObjecti64v( GLuint id, GLenum pname, GLint64* param )
    {
        _glGetQueryObjecti64v( id, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <inheritdoc cref="glGetQueryObjecti64v(GLuint, GLenum, GLint64*)"/>
    public void glGetQueryObjecti64v( GLuint id, GLenum pname, ref GLint64[] param )
    {
        fixed ( GLint64* dp =
                   &param[ 0 ] )
        {
            _glGetQueryObjecti64v( id, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLGETQUERYOBJECTUI64VPROC( GLuint id, GLenum pname, GLuint64* param );

    private PFNGLGETQUERYOBJECTUI64VPROC _glGetQueryObjectui64v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the 64bit unsigned integer value of a query object parameter.
    /// </summary>
    /// <param name="id">Specifies the name of a query object.</param>
    /// <param name="pname">
    /// Specifies the symbolic name of a query object parameter. One of <see cref="IGL.GL_QUERY_RESULT"/>,
    /// <see cref="IGL.GL_QUERY_RESULT_NO_WAIT"/> or <see cref="IGL.GL_QUERY_RESULT_AVAILABLE"/>.
    /// </param>
    /// <param name="param">Returns the value of <paramref name="pname"/>.</param>
    public void glGetQueryObjectui64v( GLuint id, GLenum pname, GLuint64* param )
    {
        _glGetQueryObjectui64v( id, pname, param );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <inheritdoc cref="glGetQueryObjectui64v(GLuint, GLenum, GLuint64*)"/>
    public void glGetQueryObjectui64v( GLuint id, GLenum pname, ref GLuint64[] param )
    {
        fixed ( GLuint64* dp =
                   &param[ 0 ] )
        {
            _glGetQueryObjectui64v( id, pname, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBDIVISORPROC( GLuint index, GLuint divisor );

    private PFNGLVERTEXATTRIBDIVISORPROC _glVertexAttribDivisor;

    /// <summary>
    /// Modify the reate at which generic vertex attributes advance during instanced rendering
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute.</param>
    /// <param name="divisor">
    /// Specifies the number of instances that will pass between updates of the generic attribute at slot
    /// <paramref name="index"/>.
    /// </param>
    public void glVertexAttribDivisor( GLuint index, GLuint divisor )
    {
        _glVertexAttribDivisor( index, divisor );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBP1UIPROC( GLuint index, GLenum type, GLboolean normalized, GLuint value );

    private PFNGLVERTEXATTRIBP1UIPROC _glVertexAttribP1ui;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies the value of the vertex attribute.</param>
    public void glVertexAttribP1ui( GLuint index, GLenum type, GLboolean normalized, GLuint value )
    {
        _glVertexAttribP1ui( index, type, normalized, value );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBP1UIVPROC( GLuint index, GLenum type, GLboolean normalized, GLuint* value );

    private PFNGLVERTEXATTRIBP1UIVPROC _glVertexAttribP1uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies a pointer to the value of the vertex attribute.</param>
    public void glVertexAttribP1uiv( GLuint index, GLenum type, GLboolean normalized, GLuint* value )
    {
        _glVertexAttribP1uiv( index, type, normalized, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies the value of the vertex attribute.</param>
    public void glVertexAttribP1uiv( GLuint index, GLenum type, GLboolean normalized, GLuint[] value )
    {
        fixed ( GLuint* dp =
                   &value[ 0 ] )
        {
            _glVertexAttribP1uiv( index, type, normalized, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBP2UIPROC( GLuint index, GLenum type, GLboolean normalized, GLuint value );

    private PFNGLVERTEXATTRIBP2UIPROC _glVertexAttribP2ui;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies the value of the vertex attribute.</param>
    public void glVertexAttribP2ui( GLuint index, GLenum type, GLboolean normalized, GLuint value )
    {
        _glVertexAttribP2ui( index, type, normalized, value );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBP2UIVPROC( GLuint index, GLenum type, GLboolean normalized, GLuint* value );

    private PFNGLVERTEXATTRIBP2UIVPROC _glVertexAttribP2uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies a pointer to the value of the vertex attribute.</param>
    public void glVertexAttribP2uiv( GLuint index, GLenum type, GLboolean normalized, GLuint* value )
    {
        _glVertexAttribP2uiv( index, type, normalized, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies the value of the vertex attribute.</param>
    public void glVertexAttribP2uiv( GLuint index, GLenum type, GLboolean normalized, GLuint[] value )
    {
        fixed ( GLuint* dp =
                   &value[ 0 ] )
        {
            _glVertexAttribP2uiv( index, type, normalized, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBP3UIPROC( GLuint index, GLenum type, GLboolean normalized, GLuint value );

    private PFNGLVERTEXATTRIBP3UIPROC _glVertexAttribP3ui;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies the value of the vertex attribute.</param>
    public void glVertexAttribP3ui( GLuint index, GLenum type, GLboolean normalized, GLuint value )
    {
        _glVertexAttribP3ui( index, type, normalized, value );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBP3UIVPROC( GLuint index, GLenum type, GLboolean normalized, GLuint* value );

    private PFNGLVERTEXATTRIBP3UIVPROC _glVertexAttribP3uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies a pointer to the value of the vertex attribute.</param>
    public void glVertexAttribP3uiv( GLuint index, GLenum type, GLboolean normalized, GLuint* value )
    {
        _glVertexAttribP3uiv( index, type, normalized, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies the value of the vertex attribute.</param>
    public void glVertexAttribP3uiv( GLuint index, GLenum type, GLboolean normalized, GLuint[] value )
    {
        fixed ( GLuint* dp =
                   &value[ 0 ] )
        {
            _glVertexAttribP3uiv( index, type, normalized, dp );
        }
    }
#endif

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBP4UIPROC( GLuint index, GLenum type, GLboolean normalized, GLuint value );

    private PFNGLVERTEXATTRIBP4UIPROC _glVertexAttribP4ui;

    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies the value of the vertex attribute.</param>
    public void glVertexAttribP4ui( GLuint index, GLenum type, GLboolean normalized, GLuint value )
    {
        _glVertexAttribP4ui( index, type, normalized, value );
    }

    [UnmanagedFunctionPointer( CallingConvention.Cdecl )]
    private delegate void PFNGLVERTEXATTRIBP4UIVPROC( GLuint index, GLenum type, GLboolean normalized, GLuint* value );

    private PFNGLVERTEXATTRIBP4UIVPROC _glVertexAttribP4uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies a pointer to the value of the vertex attribute.</param>
    public void glVertexAttribP4uiv( GLuint index, GLenum type, GLboolean normalized, GLuint* value )
    {
        _glVertexAttribP4uiv( index, type, normalized, value );
    }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="type">Specifies the data type of the vertex attribute value.</param>
    /// <param name="normalized">
    /// Specifies whether fixed-point data values should be normalized (<see langword="true"/>), or
    /// converted directly as fixed-point values (<see langword="false"/>).
    /// </param>
    /// <param name="value">Specifies the value of the vertex attribute.</param>
    public void glVertexAttribP4uiv( GLuint index, GLenum type, GLboolean normalized, GLuint[] value )
    {
        fixed ( GLuint* dp =
                   &value[ 0 ] )
        {
            _glVertexAttribP4uiv( index, type, normalized, dp );
        }
    }
#endif

#endif

    // OpenGL 4.0

#if OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLMINSAMPLESHADINGPROC(GLfloat value);
    private PFNGLMINSAMPLESHADINGPROC _glMinSampleShading;
    /// <summary>
    /// Specifies minimum rate at which sample shading takes place.
    /// </summary>
    /// <param name="value">Minimum rate at which sample shading takes place.</param>
    public void glMinSampleShading(GLfloat value) { _glMinSampleShading(value); }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBLENDEQUATIONIPROC(GLuint buf, GLenum mode);
    private PFNGLBLENDEQUATIONIPROC _glBlendEquationi;
    /// <summary>
    /// Set the equation used for both the RGB blend equation and the Alpha blend equation.
    /// </summary>
    /// <param name="buf">Specifies the index of the draw buffer for which to set the blend equation.</param>
    /// <param name="mode">Specifies how source and destination colors are combined. It must be one of <see cref="IGL.GL_FUNC_ADD"/>, <see cref="IGL.GL_FUNC_SUBTRACT"/>, <see cref="IGL.GL_FUNC_REVERSE_SUBTRACT"/>, <see cref="IGL.GL_MIN"/> or <see cref="IGL.GL_MAX"/>.</param>
    public void glBlendEquationi(GLuint buf, GLenum mode) { _glBlendEquationi(buf, mode); }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBLENDEQUATIONSEPARATEIPROC(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
    private PFNGLBLENDEQUATIONSEPARATEIPROC _glBlendEquationSeparatei;
    /// <summary>
    /// Set the equation used for both the RGB blend equation and the Alpha blend equation.
    /// </summary>
    /// <param name="buf">Specifies the index of the draw buffer for which to set the blend equation.</param>
    /// <param name="modeRGB">Specifies how the red, green, and blue blending factors are computed. The following symbolic constants are accepted: <see cref="IGL.GL_FUNC_ADD"/>, <see cref="IGL.GL_FUNC_SUBTRACT"/>, <see cref="IGL.GL_FUNC_REVERSE_SUBTRACT"/>, <see cref="IGL.GL_MIN"/> or <see cref="IGL.GL_MAX"/>.</param>
    /// <param name="modeAlpha">Specifies how the alpha blending factor is computed. The following symbolic constants are accepted: <see cref="IGL.GL_FUNC_ADD"/>, <see cref="IGL.GL_FUNC_SUBTRACT"/>, <see cref="IGL.GL_FUNC_REVERSE_SUBTRACT"/>, <see cref="IGL.GL_MIN"/> or <see cref="IGL.GL_MAX"/>.</param>
    public void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha) { _glBlendEquationSeparatei(buf, modeRGB, modeAlpha); }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBLENDFUNCIPROC(GLuint buf, GLenum src, GLenum dst);
    private PFNGLBLENDFUNCIPROC _glBlendFunci;
    /// <summary>
    /// Specify pixel arithmetic
    /// </summary>
    /// <param name="buf">Specifies the index of the draw buffer for which to set the blend function.</param>
    /// <param name="src">Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is <see cref="IGL.GL_ONE"/>.</param>
    /// <param name="dst">Specifies how the red, green, blue, and alpha destination blending factors are computed. Allowed values are the same as for <see cref="glBlendFunc"/>.</param>
    public void glBlendFunci(GLuint buf, GLenum src, GLenum dst) { _glBlendFunci(buf, src, dst); }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBLENDFUNCSEPARATEIPROC(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
    private PFNGLBLENDFUNCSEPARATEIPROC _glBlendFuncSeparatei;
    /// <summary>
    /// Specify pixel arithmetic for RGB and alpha components separately
    /// </summary>
    /// <param name="buf">Specifies the index of the draw buffer for which to set the blend function.</param>
    /// <param name="srcRGB">Specifies how the red, green, and blue blending factors are computed. The initial value is <see cref="IGL.GL_ONE"/>.</param>
    /// <param name="dstRGB">Specifies how the red, green, and blue destination blending factors are computed. The initial value is <see cref="IGL.GL_ZERO"/>.</param>
    /// <param name="srcAlpha">Specifies how the alpha source blending factor is computed. The initial value is <see cref="IGL.GL_ONE"/>.</param>
    /// <param name="dstAlpha">Specifies how the alpha destination blending factor is computed. The initial value is <see cref="IGL.GL_ZERO"/>.</param>
    public void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) { _glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha); }

#if OGL_V_4_0 || OGL_V_4_1 
    public struct DrawArraysIndirectCommand
    {
        public GLuint count;
        public GLuint primCount;
        public GLuint first;
        public GLuint reservedMustBeZero;
    }
#endif
#if OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    public struct DrawArraysIndirectCommand
    {
        public GLuint count;
        public GLuint instanceCount;
        public GLuint first;
        public GLuint baseInstance;
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDRAWARRAYSINDIRECTPROC(GLenum mode, void* indirect);
    private PFNGLDRAWARRAYSINDIRECTPROC _glDrawArraysIndirect;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render primitives from array data, taking parameters from memory
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>, <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, <see cref="IGL.GL_PATCHES"/> are accepted.</param>
    /// <param name="indirect">Specifies the address of an array of DrawArraysIndirectCommand structures.</param>
    public void glDrawArraysIndirect(GLenum mode, void* indirect) { _glDrawArraysIndirect(mode, indirect); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render primitives from array data, taking parameters from memory
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>, <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, <see cref="IGL.GL_PATCHES"/> are accepted.</param>
    /// <param name="indirect">Specifies an instance of <see cref="DrawArraysIndirectCommand"/>.</param>
    public void glDrawArraysIndirect(GLenum mode, DrawArraysIndirectCommand indirect) { _glDrawArraysIndirect(mode, &indirect); }
#endif

#if (OGL_V_4_0 || OGL_V_4_1) && (OGL_WRAPPER_API_SAFE || OGL_WRAPPER_API_BOTH) 
    public struct DrawElementsIndirectCommand
    {
        public GLuint count;
        public GLuint primCount;
        public GLuint firstIndex;
        public GLuint baseVertex;
        public GLuint reservedMustBeZero;
    }
#endif
#if (OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6) && (OGL_WRAPPER_API_SAFE || OGL_WRAPPER_API_BOTH)  
    public struct DrawElementsIndirectCommand
    {
        public GLuint count;
        public GLuint primCount;
        public GLuint firstIndex;
        public GLuint baseVertex;
        public GLuint baseInstance;
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDRAWELEMENTSINDIRECTPROC(GLenum mode, GLenum type, void* indirect);
    private PFNGLDRAWELEMENTSINDIRECTPROC _glDrawElementsIndirect;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render indexed primitives from array data, taking parameters from memory
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>, <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, <see cref="IGL.GL_PATCHES"/> are accepted.</param>
    /// <param name="type">Specifies the type of data in the buffer bound to the <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/> binding.</param>
    /// <param name="indirect">Specifies the address of a DrawElementsIndirectCommand structure.</param>
    public void glDrawElementsIndirect(GLenum mode, GLenum type, void* indirect) { _glDrawElementsIndirect(mode, type, indirect); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render indexed primitives from array data, taking parameters from memory
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>, <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_LINES_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY"/>, <see cref="IGL.GL_TRIANGLES_ADJACENCY"/>, <see cref="IGL.GL_PATCHES"/> are accepted.</param>
    /// <param name="type">Specifies the type of data in the buffer bound to the <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER"/> binding.</param>
    /// <param name="indirect">Specifies an instance of <see cref="DrawElementsIndirectCommand"/>.</param>
    public void glDrawElementsIndirect(GLenum mode, GLenum type, DrawElementsIndirectCommand indirect) { _glDrawElementsIndirect(mode, type, &indirect); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORM1DPROC(GLint location, GLdouble x);
    private PFNGLUNIFORM1DPROC _glUniform1d;
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="x">Specifies the new value to be used for the specified uniform variable.</param>
    public void glUniform1d(GLint location, GLdouble x) { _glUniform1d(location, x); }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORM2DPROC(GLint location, GLdouble x, GLdouble y);
    private PFNGLUNIFORM2DPROC _glUniform2d;
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="x">Specifies the first value to be used for the specified uniform variable.</param>
    /// <param name="y">Specifies the second value to be used for the specified uniform variable.</param>
    public void glUniform2d(GLint location, GLdouble x, GLdouble y) { _glUniform2d(location, x, y); }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORM3DPROC(GLint location, GLdouble x, GLdouble y, GLdouble z);
    private PFNGLUNIFORM3DPROC _glUniform3d;
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="x">Specifies the first value to be used for the specified uniform variable.</param>
    /// <param name="y">Specifies the second value to be used for the specified uniform variable.</param>
    /// <param name="z">Specifies the third value to be used for the specified uniform variable.</param>
    public void glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z) { _glUniform3d(location, x, y, z); }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORM4DPROC(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
    private PFNGLUNIFORM4DPROC _glUniform4d;
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="x">Specifies the first value to be used for the specified uniform variable.</param>
    /// <param name="y">Specifies the second value to be used for the specified uniform variable.</param>
    /// <param name="z">Specifies the third value to be used for the specified uniform variable.</param>
    public void glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) { _glUniform4d(location, x, y, z, w); }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORM1DVPROC(GLint location, GLsizei count, GLdouble* value);
    private PFNGLUNIFORM1DVPROC _glUniform1dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of values in the <paramref name="value"/> array.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniform1dv(GLint location, GLsizei count, GLdouble* value) { _glUniform1dv(location, count, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform1dv(GLint location, GLdouble[] value) { fixed (GLdouble* p = &value[0]) _glUniform1dv(location, value.Length, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORM2DVPROC(GLint location, GLsizei count, GLdouble* value);
    private PFNGLUNIFORM2DVPROC _glUniform2dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of values in the <paramref name="value"/> array.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniform2dv(GLint location, GLsizei count, GLdouble* value) { _glUniform2dv(location, count, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform2dv(GLint location, GLdouble[] value) { fixed (GLdouble* p = &value[0]) _glUniform2dv(location, value.Length / 2, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORM3DVPROC(GLint location, GLsizei count, GLdouble* value);
    private PFNGLUNIFORM3DVPROC _glUniform3dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of values in the <paramref name="value"/> array.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniform3dv(GLint location, GLsizei count, GLdouble* value) { _glUniform3dv(location, count, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform3dv(GLint location, GLdouble[] value) { fixed (GLdouble* p = &value[0]) _glUniform3dv(location, value.Length / 3, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORM4DVPROC(GLint location, GLsizei count, GLdouble* value);
    private PFNGLUNIFORM4DVPROC _glUniform4dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of values in the <paramref name="value"/> array.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniform4dv(GLint location, GLsizei count, GLdouble* value) { _glUniform4dv(location, count, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glUniform4dv(GLint location, GLdouble[] value) { fixed (GLdouble* p = &value[0]) _glUniform4dv(location, value.Length / 4, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORMMATRIX2DVPROC(GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLUNIFORMMATRIX2DVPROC _glUniformMatrix2dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, GLdouble* value) { _glUniformMatrix2dv(location, count, transpose, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable. 4 values per matrix.</param>
    public void glUniformMatrix2dv(GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* p =
 &value[0]) _glUniformMatrix2dv(location, value.Length / 4, transpose, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORMMATRIX3DVPROC(GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLUNIFORMMATRIX3DVPROC _glUniformMatrix3dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, GLdouble* value) { _glUniformMatrix3dv(location, count, transpose, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable. 9 values per matrix.</param>
    public void glUniformMatrix3dv(GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* p =
 &value[0]) _glUniformMatrix3dv(location, value.Length / 9, transpose, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORMMATRIX4DVPROC(GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLUNIFORMMATRIX4DVPROC _glUniformMatrix4dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, GLdouble* value) { _glUniformMatrix4dv(location, count, transpose, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable. 16 values per matrix.</param>
    public void glUniformMatrix4dv(GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* p =
 &value[0]) _glUniformMatrix4dv(location, value.Length / 16, transpose, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORMMATRIX2X3DVPROC(GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLUNIFORMMATRIX2X3DVPROC _glUniformMatrix2x3dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, GLdouble* value) { _glUniformMatrix2x3dv(location, count, transpose, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable. 6 values per matrix.</param>
    public void glUniformMatrix2x3dv(GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* p =
 &value[0]) _glUniformMatrix2x3dv(location, value.Length / 6, transpose, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORMMATRIX2X4DVPROC(GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLUNIFORMMATRIX2X4DVPROC _glUniformMatrix2x4dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, GLdouble* value) { _glUniformMatrix2x4dv(location, count, transpose, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable. 8 values per matrix.</param>
    public void glUniformMatrix2x4dv(GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* p =
 &value[0]) _glUniformMatrix2x4dv(location, value.Length / 8, transpose, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORMMATRIX3X2DVPROC(GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLUNIFORMMATRIX3X2DVPROC _glUniformMatrix3x2dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, GLdouble* value) { _glUniformMatrix3x2dv(location, count, transpose, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable. 6 values per matrix.</param>
    public void glUniformMatrix3x2dv(GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* p =
 &value[0]) _glUniformMatrix3x2dv(location, value.Length / 6, transpose, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORMMATRIX3X4DVPROC(GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLUNIFORMMATRIX3X4DVPROC _glUniformMatrix3x4dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, GLdouble* value) { _glUniformMatrix3x4dv(location, count, transpose, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable. 12 values per matrix.</param>
    public void glUniformMatrix3x4dv(GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* p =
 &value[0]) _glUniformMatrix3x4dv(location, value.Length / 12, transpose, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORMMATRIX4X2DVPROC(GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLUNIFORMMATRIX4X2DVPROC _glUniformMatrix4x2dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, GLdouble* value) { _glUniformMatrix4x2dv(location, count, transpose, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable. 8 values per matrix.</param>
    public void glUniformMatrix4x2dv(GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* p =
 &value[0]) _glUniformMatrix4x2dv(location, value.Length / 8, transpose, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORMMATRIX4X3DVPROC(GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLUNIFORMMATRIX4X3DVPROC _glUniformMatrix4x3dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of matrices that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, GLdouble* value) { _glUniformMatrix4x3dv(location, count, transpose, value); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a double uniform variable for the current program object
    /// </summary>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable. 12 values per matrix.</param>
    public void glUniformMatrix4x3dv(GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* p =
 &value[0]) _glUniformMatrix4x3dv(location, value.Length / 12, transpose, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETUNIFORMDVPROC(GLuint program, GLint location, GLdouble* parameters);
    private PFNGLGETUNIFORMDVPROC _glGetUniformdv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the value or values of a double uniform variable
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be queried.</param>
    /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
    /// <param name="parameters">Specifies the address of a variable to receive the value or values of the uniform variable.</param>
    public void glGetUniformdv(GLuint program, GLint location, GLdouble* parameters) { _glGetUniformdv(program, location, parameters); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the value or values of a double uniform variable
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be queried.</param>
    /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
    /// <param name="parameters">Specifies an array to receive the value or values of the uniform variable.</param>
    public void glGetUniformdv(GLuint program, GLint location, ref GLdouble[] parameters) { fixed (GLdouble* p =
 &parameters[0]) _glGetUniformdv(program, location, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLint PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC(GLuint program, GLenum shadertype, GLchar* name);
    private PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC _glGetSubroutineUniformLocation;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the location of a subroutine uniform variable
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the subroutine uniform variable whose location to query.</param>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniform variable whose location to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="name">Specifies the name of the subroutine uniform variable whose location to query.</param>
    /// <returns>The location of the subroutine uniform variable.</returns>
    public GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, GLchar* name) { return _glGetSubroutineUniformLocation(program, shadertype, name); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the location of a subroutine uniform variable
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the subroutine uniform variable whose location to query.</param>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniform variable whose location to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="name">Specifies the name of the subroutine uniform variable whose location to query.</param>
    /// <returns>The location of the subroutine uniform variable.</returns>
    public GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, string name)
    {
        GLchar[] nameBytes = Encoding.UTF8.GetBytes(name);
        fixed (GLchar* p = &nameBytes[0])
        {
            return _glGetSubroutineUniformLocation(program, shadertype, p);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLuint PFNGLGETSUBROUTINEINDEXPROC(GLuint program, GLenum shadertype, GLchar* name);
    private PFNGLGETSUBROUTINEINDEXPROC _glGetSubroutineIndex;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the index of a subroutine uniform of a given shader stage within a program.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the subroutine uniform variable whose index to query.</param>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniform variable whose index to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="name">Specifies the name of the subroutine uniform variable whose index to query.</param>
    /// <returns>The index of the subroutine uniform variable.</returns>
    public GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, GLchar* name) { return _glGetSubroutineIndex(program, shadertype, name); }
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the index of a subroutine uniform of a given shader stage within a program.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the subroutine uniform variable whose index to query.</param>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniform variable whose index to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="name">Specifies the name of the subroutine uniform variable whose index to query.</param>
    /// <returns>The index of the subroutine uniform variable.</returns>
    public GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, string name)
    {
        GLchar[] nameBytes = Encoding.UTF8.GetBytes(name);
        fixed (GLchar* p = &nameBytes[0])
        {
            return _glGetSubroutineIndex(program, shadertype, p);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
    private PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC _glGetActiveSubroutineUniformiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Query a property of an active shader subroutine uniform variable.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the subroutine uniform variable whose properties to query.</param>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniform variable whose properties to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="index">Specifies the index of the subroutine uniform variable whose properties to query.</param>
    /// <param name="pname">Specifies the property of the subroutine uniform variable to query. One of <see cref="IGL.GL_NUM_COMPATIBLE_SUBROUTINES"/>, <see cref="IGL.GL_COMPATIBLE_SUBROUTINES"/>, <see cref="IGL.GL_UNIFORM_SIZE" />, or <see cref="IGL.GL_UNIFORM_NAME_LENGTH"/>.</param>
    /// <param name="values">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values) => _glGetActiveSubroutineUniformiv(program, shadertype, index, pname, values);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Query a property of an active shader subroutine uniform variable.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the subroutine uniform variable whose properties to query.</param>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniform variable whose properties to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="index">Specifies the index of the subroutine uniform variable whose properties to query.</param>
    /// <param name="pname">Specifies the property of the subroutine uniform variable to query. One of <see cref="IGL.GL_NUM_COMPATIBLE_SUBROUTINES"/>, <see cref="IGL.GL_COMPATIBLE_SUBROUTINES"/>, <see cref="IGL.GL_UNIFORM_SIZE" />, or <see cref="IGL.GL_UNIFORM_NAME_LENGTH"/>.</param>
    /// <param name="values">Specifies an array to receive the value of the queried parameter.</param>
    public void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, ref GLint[] values) { fixed (GLint* p =
 &values[0]) _glGetActiveSubroutineUniformiv(program, shadertype, index, pname, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name);
    private PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC _glGetActiveSubroutineUniformName;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the name of an active shader subroutine uniform variable.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the subroutine uniform variable whose name to query.</param>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniform variable whose name to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="index">Specifies the index of the subroutine uniform variable whose name to query.</param>
    /// <param name="bufsize">Specifies the max amount of characters that may be written into <paramref name="name"/>.</param>
    /// <param name="length">Specifies the address of a variable to receive the number of characters that were written.</param>
    /// <param name="name">Specifies the address of a buffer into which the name of the subroutine uniform variable will be written.</param>
    public void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name) => _glGetActiveSubroutineUniformName(program, shadertype, index, bufsize, length, name);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the name of an active shader subroutine uniform variable.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the subroutine uniform variable whose name to query.</param>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniform variable whose name to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="index">Specifies the index of the subroutine uniform variable whose name to query.</param>
    /// <param name="bufsize">Specifies the max amount of characters that may be written into <paramref name="name"/>.</param>
    /// <returns>The name of the subroutine uniform variable, resized correctly.</returns>
    public string glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize)
    {
        GLchar[] name = new GLchar[bufsize];
        GLsizei length;
        fixed (GLchar* p = &name[0])
        {
            _glGetActiveSubroutineUniformName(program, shadertype, index, bufsize, &length, p);
            return new string((sbyte*)p, 0, length, Encoding.UTF8);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETACTIVESUBROUTINENAMEPROC(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name);
    private PFNGLGETACTIVESUBROUTINENAMEPROC _glGetActiveSubroutineName;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the name of an active shader subroutine.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the subroutine whose name to query.</param>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine whose name to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="index">Specifies the index of the subroutine whose name to query.</param>
    /// <param name="bufsize">Specifies the max amount of characters that may be written into <paramref name="name"/>.</param>
    /// <param name="length">Specifies the address of a variable to receive the number of characters that were written.</param>
    /// <param name="name">Specifies the address of a buffer into which the name of the subroutine will be written.</param>
    public void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name) => _glGetActiveSubroutineName(program, shadertype, index, bufsize, length, name);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the name of an active shader subroutine.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the subroutine whose name to query.</param>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine whose name to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="index">Specifies the index of the subroutine whose name to query.</param>
    /// <param name="bufsize">Specifies the max amount of characters that may be written into <paramref name="name"/>.</param>
    /// <returns>The name of the subroutine, resized correctly.</returns>
    public string glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize)
    {
        GLchar[] name = new GLchar[bufsize];
        GLsizei length;
        fixed (GLchar* p = &name[0])
        {
            _glGetActiveSubroutineName(program, shadertype, index, bufsize, &length, p);
            return new string((sbyte*)p, 0, length, Encoding.UTF8);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUNIFORMSUBROUTINESUIVPROC(GLenum shadertype, GLsizei count, GLuint* indices);
    private PFNGLUNIFORMSUBROUTINESUIVPROC _glUniformSubroutinesuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Load active subroutine uniforms.
    /// </summary>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniforms to load. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="count">Specifies the number of subroutine uniform incides in the array pointed to by <paramref name="indices"/>.</param>
    /// <param name="indices">Specifies an array containing the subroutine uniform indices to load.</param>
    public void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, GLuint* indices) => _glUniformSubroutinesuiv(shadertype, count, indices);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Load active subroutine uniforms.
    /// </summary>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniforms to load. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="indices">Specifies an array containing the subroutine uniform indices to load.</param>
    public void glUniformSubroutinesuiv(GLenum shadertype, GLuint[] indices) { fixed (GLuint* p =
 &indices[0]) _glUniformSubroutinesuiv(shadertype, indices.Length, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETUNIFORMSUBROUTINEUIVPROC(GLenum shadertype, GLint location, GLuint* @params);
    private PFNGLGETUNIFORMSUBROUTINEUIVPROC _glGetUniformSubroutineuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the value of a subroutine uniform of a given shader stage of the current program.
    /// </summary>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniform whose value to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="location">Specifies the location of the subroutine uniform whose value to query.</param>
    /// <param name="params">Specifies the address of a variable to receive the value of the subroutine uniform.</param>
    public void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint* @params) => _glGetUniformSubroutineuiv(shadertype, location, @params);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the value of a subroutine uniform of a given shader stage of the current program.
    /// </summary>
    /// <param name="shadertype">Specifies the shader stage containing the subroutine uniform whose value to query. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="location">Specifies the location of the subroutine uniform whose value to query.</param>
    /// <param name="params">Specifies an array to receive the value of the subroutine uniform.</param>
    public void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, ref GLuint[] @params) { fixed (GLuint* p =
 &@params[0]) _glGetUniformSubroutineuiv(shadertype, location, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETPROGRAMSTAGEIVPROC(GLuint program, GLenum shadertype, GLenum pname, GLint* values);
    private PFNGLGETPROGRAMSTAGEIVPROC _glGetProgramStageiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve a parameter from a shader stage of the current program.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the shader stage to query.</param>
    /// <param name="shadertype">Specifies the shader stage from which to query the parameter. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="pname">Specifies the parameter to query. One of <see cref="IGL.GL_ACTIVE_SUBROUTINE_UNIFORMS"/>, <see cref="IGL.GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS"/>, <see cref="IGL.GL_ACTIVE_SUBROUTINES"/>, <see cref="IGL.GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH"/>, <see cref="IGL.GL_ACTIVE_SUBROUTINE_MAX_LENGTH"/>.</param>
    /// <param name="values">Specifies the address of a variable to receive the value of the parameter.</param>
    public void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint* values) => _glGetProgramStageiv(program, shadertype, pname, values);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve a parameter from a shader stage of the current program.
    /// </summary>
    /// <param name="program">Specifies the name of the program containing the shader stage to query.</param>
    /// <param name="shadertype">Specifies the shader stage from which to query the parameter. One of <see cref="IGL.GL_VERTEX_SHADER"/>, <see cref="IGL.GL_TESS_CONTROL_SHADER"/>, <see cref="IGL.GL_TESS_EVALUATION_SHADER"/>, <see cref="IGL.GL_GEOMETRY_SHADER"/>, <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="pname">Specifies the parameter to query. One of <see cref="IGL.GL_ACTIVE_SUBROUTINE_UNIFORMS"/>, <see cref="IGL.GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS"/>, <see cref="IGL.GL_ACTIVE_SUBROUTINES"/>, <see cref="IGL.GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH"/>, <see cref="IGL.GL_ACTIVE_SUBROUTINE_MAX_LENGTH"/>.</param>
    /// <param name="values">Specifies an array to receive the value of the parameter.</param>
    public void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, ref GLint[] values) { fixed (GLint* p =
 &values[0]) _glGetProgramStageiv(program, shadertype, pname, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPATCHPARAMETERIPROC(GLenum pname, GLint value);
    private PFNGLPATCHPARAMETERIPROC _glPatchParameteri;
    /// <summary>
    /// Specifies the parameters for patch primitives.
    /// </summary>
    /// <param name="pname">Specifies the parameter to set. One of <see cref="IGL.GL_PATCH_VERTICES"/>, <see cref="IGL.GL_PATCH_DEFAULT_INNER_LEVEL"/>, <see cref="IGL.GL_PATCH_DEFAULT_OUTER_LEVEL"/>.</param>
    /// <param name="value">Specifies the value to set for <paramref name="pname"/>.</param>
    public void glPatchParameteri(GLenum pname, GLint value) => _glPatchParameteri(pname, value);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPATCHPARAMETERFVPROC(GLenum pname, GLfloat* values);
    private PFNGLPATCHPARAMETERFVPROC _glPatchParameterfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specifies the parameters for patch primitives.
    /// </summary>
    /// <param name="pname">Specifies the parameter to set. One of <see cref="IGL.GL_PATCH_VERTICES"/>, <see cref="IGL.GL_PATCH_DEFAULT_INNER_LEVEL"/>, <see cref="IGL.GL_PATCH_DEFAULT_OUTER_LEVEL"/>.</param>
    /// <param name="values">Specifies the address of an array containing the value or values to set for <paramref name="pname"/>.</param>
    public void glPatchParameterfv(GLenum pname, GLfloat* values) => _glPatchParameterfv(pname, values);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specifies the parameters for patch primitives.
    /// </summary>
    /// <param name="pname">Specifies the parameter to set. One of <see cref="IGL.GL_PATCH_VERTICES"/>, <see cref="IGL.GL_PATCH_DEFAULT_INNER_LEVEL"/>, <see cref="IGL.GL_PATCH_DEFAULT_OUTER_LEVEL"/>.</param>
    /// <param name="values">Specifies an array containing the value or values to set for <paramref name="pname"/>.</param>
    public void glPatchParameterfv(GLenum pname, GLfloat[] values) { fixed (GLfloat* p = &values[0]) _glPatchParameterfv(pname, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDTRANSFORMFEEDBACKPROC(GLenum target, GLuint id);
    private PFNGLBINDTRANSFORMFEEDBACKPROC _glBindTransformFeedback;
    /// <summary>
    /// Bind a named transform feedback object.
    /// </summary>
    /// <param name="target">Specifies the target to which the transform feedback object is bound. Must be <see cref="IGL.GL_TRANSFORM_FEEDBACK"/>.</param>
    /// <param name="id">Specifies the name of a transform feedback object.</param>
    public void glBindTransformFeedback(GLenum target, GLuint id) => _glBindTransformFeedback(target, id);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDELETETRANSFORMFEEDBACKSPROC(GLsizei n, GLuint* ids);
    private PFNGLDELETETRANSFORMFEEDBACKSPROC _glDeleteTransformFeedbacks;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Delete named transform feedback objects.
    /// </summary>
    /// <param name="n">Specifies the number of transform feedback objects to be deleted.</param>
    /// <param name="ids">Specifies the address of an array containing the n names of the objects to be deleted.</param>
    public void glDeleteTransformFeedbacks(GLsizei n, GLuint* ids) => _glDeleteTransformFeedbacks(n, ids);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Delete named transform feedback objects.
    /// </summary>
    /// <param name="ids">Specifies the names of the objects to be deleted.</param>
    public void glDeleteTransformFeedbacks(params GLuint[] ids) { fixed (GLuint* p = &ids[0]) _glDeleteTransformFeedbacks(ids.Length, p); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGENTRANSFORMFEEDBACKSPROC(GLsizei n, GLuint* ids);
    private PFNGLGENTRANSFORMFEEDBACKSPROC _glGenTransformFeedbacks;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate transform feedback object names.
    /// </summary>
    /// <param name="n">Specifies the number of transform feedback object names to generate.</param>
    /// <param name="ids">Specifies the address of an array in which to place the generated transform feedback object names.</param>
    public void glGenTransformFeedbacks(GLsizei n, GLuint* ids) => _glGenTransformFeedbacks(n, ids);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate transform feedback object names.
    /// </summary>
    /// <param name="n">Specifies the number of transform feedback object names to generate.</param>
    /// <returns>Array of generated transform feedback object names.</returns>
    public GLuint[] glGenTransformFeedbacks(GLsizei n) { var r = new GLuint[n]; fixed (GLuint* p = &r[0]) _glGenTransformFeedbacks(n, p); return r; }
    /// <summary>
    /// Generate a single transform feedback object name.
    /// </summary>
    /// <returns>Generated transform feedback object name.</returns>
    public GLuint glGenTransformFeedback() => glGenTransformFeedbacks(1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLboolean PFNGLISTRANSFORMFEEDBACKPROC(GLuint id);
    private PFNGLISTRANSFORMFEEDBACKPROC _glIsTransformFeedback;
    /// <summary>
    /// Determine if a name corresponds to a transform feedback object.
    /// </summary>
    /// <param name="id">Specifies a value that may be the name of a transform feedback object.</param>
    /// <returns><see langword="true" />, if <paramref name="id"/> corresponds to a transform feedback object; otherwise, <see langword="false" />.</returns>
    public GLboolean glIsTransformFeedback(GLuint id) => _glIsTransformFeedback(id);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPAUSETRANSFORMFEEDBACKPROC();
    private PFNGLPAUSETRANSFORMFEEDBACKPROC _glPauseTransformFeedback;
    /// <summary>
    /// Pause transform feedback operations.
    /// </summary>
    public void glPauseTransformFeedback() => _glPauseTransformFeedback();

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLRESUMETRANSFORMFEEDBACKPROC();
    private PFNGLRESUMETRANSFORMFEEDBACKPROC _glResumeTransformFeedback;
    /// <summary>
    /// Resume transform feedback operations.
    /// </summary>
    public void glResumeTransformFeedback() => _glResumeTransformFeedback();

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDRAWTRANSFORMFEEDBACKPROC(GLenum mode, GLuint id);
    private PFNGLDRAWTRANSFORMFEEDBACKPROC _glDrawTransformFeedback;
    /// <summary>
    /// Render primitives using a count derived from a transform feedback object.
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>, <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY" />, <see cref="IGL.GL_LINES_ADJACENCY" />, <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY" />, <see cref="IGL.GL_TRIANGLES_ADJACENCY" />, and <see cref="IGL.GL_PATCHES"/> are accepted.</param>
    /// <param name="id">Specifies the name of a transform feedback object from which to retrieve a primitive count and a primitive mode.</param>
    public void glDrawTransformFeedback(GLenum mode, GLuint id) => _glDrawTransformFeedback(mode, id);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC(GLenum mode, GLuint id, GLuint stream);
    private PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC _glDrawTransformFeedbackStream;
    /// <summary>
    /// Render primitives using a counter derived from a specified stream of a transform feedback object.
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants <see cref="IGL.GL_POINTS"/>, <see cref="IGL.GL_LINE_STRIP"/>, <see cref="IGL.GL_LINE_LOOP"/>, <see cref="IGL.GL_LINES"/>, <see cref="IGL.GL_LINE_STRIP_ADJACENCY" />, <see cref="IGL.GL_LINES_ADJACENCY" />, <see cref="IGL.GL_TRIANGLE_STRIP"/>, <see cref="IGL.GL_TRIANGLE_FAN"/>, <see cref="IGL.GL_TRIANGLES"/>, <see cref="IGL.GL_TRIANGLE_STRIP_ADJACENCY" />, <see cref="IGL.GL_TRIANGLES_ADJACENCY" />, and <see cref="IGL.GL_PATCHES"/> are accepted.</param>
    /// <param name="id">Specifies the name of a transform feedback object from which to retrieve a primitive count and a primitive mode.</param>
    /// <param name="stream">Specifies the index of the stream from which to retrieve the primitive count and mode.</param>
    public void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream) => _glDrawTransformFeedbackStream(mode, id, stream);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBEGINQUERYINDEXEDPROC(GLenum target, GLuint index, GLuint id);
    private PFNGLBEGINQUERYINDEXEDPROC _glBeginQueryIndexed;
    /// <summary>
    /// Begin a query object target.
    /// </summary>
    /// <param name="target">Specifies the target of the query object. The symbolic constant must be <see cref="IGL.GL_SAMPLES_PASSED"/>, <see cref="IGL.GL_ANY_SAMPLES_PASSED"/>, <see cref="IGL.GL_PRIMITIVES_GENERATED" />, <see cref="IGL.GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN" />, <see cref="IGL.GL_TIME_ELAPSED" />.</param>
    /// <param name="index">Specifies the index of the query object target.</param>
    /// <param name="id">Specifies the name of a query object.</param>
    public void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id) => _glBeginQueryIndexed(target, index, id);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLENDQUERYINDEXEDPROC(GLenum target, GLuint index);
    private PFNGLENDQUERYINDEXEDPROC _glEndQueryIndexed;
    /// <summary>
    /// End a query object target.
    /// </summary>
    /// <param name="target">Specifies the target of the query object. The symbolic constant must be <see cref="IGL.GL_SAMPLES_PASSED"/>, <see cref="IGL.GL_ANY_SAMPLES_PASSED"/>, <see cref="IGL.GL_PRIMITIVES_GENERATED" />, <see cref="IGL.GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN" />, <see cref="IGL.GL_TIME_ELAPSED" />.</param>
    /// <param name="index">Specifies the index of the query object target.</param>
    public void glEndQueryIndexed(GLenum target, GLuint index) => _glEndQueryIndexed(target, index);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETQUERYINDEXEDIVPROC(GLenum target, GLuint index, GLenum pname, GLint* parameters);
    private PFNGLGETQUERYINDEXEDIVPROC _glGetQueryIndexediv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a query object target.
    /// </summary>
    /// <param name="target">Specifies the target of the query object. The symbolic constant must be <see cref="IGL.GL_SAMPLES_PASSED"/>, <see cref="IGL.GL_ANY_SAMPLES_PASSED"/>, <see cref="IGL.GL_PRIMITIVES_GENERATED" />, <see cref="IGL.GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN" />, <see cref="IGL.GL_TIME_ELAPSED" />, or <see cref="IGL.GL_TIMESTAMP"/>.</param>
    /// <param name="index">Specifies the index of the query object target.</param>
    /// <param name="pname">Specifies the symbolic name of a query object target parameter. Accepted values are <see cref="IGL.GL_CURRENT_QUERY"/>, <see cref="IGL.GL_QUERY_COUNTER_BITS"/>.</param>
    /// <param name="parameters">Returns the requested data.</param>
    public void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint* parameters) => _glGetQueryIndexediv(target, index, pname, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a query object target.
    /// </summary>
    /// <param name="target">Specifies the target of the query object. The symbolic constant must be <see cref="IGL.GL_SAMPLES_PASSED"/>, <see cref="IGL.GL_ANY_SAMPLES_PASSED"/>, <see cref="IGL.GL_PRIMITIVES_GENERATED" />, <see cref="IGL.GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN" />, <see cref="IGL.GL_TIME_ELAPSED" />, or <see cref="IGL.GL_TIMESTAMP"/>.</param>
    /// <param name="index">Specifies the index of the query object target.</param>
    /// <param name="pname">Specifies the symbolic name of a query object target parameter. Accepted values are <see cref="IGL.GL_CURRENT_QUERY"/>, <see cref="IGL.GL_QUERY_COUNTER_BITS"/>.</param>
    /// <param name="parameters">Returns the requested data.</param>
    public void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, ref GLint[] parameters) { fixed (GLint* p =
 &parameters[0]) _glGetQueryIndexediv(target, index, pname, p); }
#endif

#endif

    // OpenGL 4.1

#if OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLRELEASESHADERCOMPILERPROC();
    private PFNGLRELEASESHADERCOMPILERPROC _glReleaseShaderCompiler;
    /// <summary>
    /// Release resources consumed by the shader compiler.
    /// </summary>
    public void glReleaseShaderCompiler() => _glReleaseShaderCompiler();

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLSHADERBINARYPROC(GLsizei count, GLuint* shaders, GLenum binaryformat, void* binary, GLsizei length);
    private PFNGLSHADERBINARYPROC _glShaderBinary;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Loads pre-compiled shader binaries.
    /// </summary>
    /// <param name="count">Specifies the number of shader handles contained in the array whose address is given in shaders.</param>
    /// <param name="shaders">Specifies an array of shader handles into which to load pre-compiled shader binaries.</param>
    /// <param name="binaryformat">Specifies the format of the shader binary data contained in binary.</param>
    /// <param name="binary">Specifies an array of bytes containing pre-compiled shader binaries.</param>
    /// <param name="length">Specifies the number of bytes in the array of bytes pointed to by binary.</param>
    public void glShaderBinary(GLsizei count, GLuint* shaders, GLenum binaryformat, void* binary, GLsizei length) => _glShaderBinary(count, shaders, binaryformat, binary, length);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Loads pre-compiled shader binaries.
    /// </summary>
    /// <param name="shaders">Specifies an array of shader handles into which to load pre-compiled shader binaries.</param>
    /// <param name="binaryformat">Specifies the format of the shader binary data contained in binary.</param>
    /// <param name="binary">Specifies an array of bytes containing pre-compiled shader binaries.</param>
    public void glShaderBinary(GLuint[] shaders, GLenum binaryformat, byte[] binary)
    {
        GLsizei count = shaders.Length;
        fixed (GLuint* pShaders = &shaders[0])
        fixed (byte* pBinary = &binary[0])
        {
            _glShaderBinary(count, pShaders, binaryformat, pBinary, binary.Length);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETSHADERPRECISIONFORMATPROC(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
    private PFNGLGETSHADERPRECISIONFORMATPROC _glGetShaderPrecisionFormat;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the range and precision for numeric formats supported by the shader compiler.
    /// </summary>
    /// <param name="shaderType">Specifies the type of shader, <see cref="IGL.GL_VERTEX_SHADER"/> or <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="precisionType">Specifies the numeric format whose precision to query.</param>
    /// <param name="range">Returns the range of variable.</param>
    /// <param name="precision">Returns the precision of variable.</param>
    public void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint* range, GLint* precision) => _glGetShaderPrecisionFormat(shaderType, precisionType, range, precision);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the range and precision for numeric formats supported by the shader compiler.
    /// </summary>
    /// <param name="shaderType">Specifies the type of shader, <see cref="IGL.GL_VERTEX_SHADER"/> or <see cref="IGL.GL_FRAGMENT_SHADER"/>.</param>
    /// <param name="precisionType">Specifies the numeric format whose precision to query.</param>
    /// <param name="range">Returns the range of variable.</param>
    /// <param name="precision">Returns the precision of variable.</param>
    public void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, ref GLint[] range, ref GLint precision)
    {
        range = new GLint[2];
        fixed (GLint* pRange = &range[0])
        fixed (GLint* pPrecision = &precision)
        {
            _glGetShaderPrecisionFormat(shaderType, precisionType, pRange, pPrecision);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDEPTHRANGEFPROC(GLfloat n, GLfloat f);
    private PFNGLDEPTHRANGEFPROC _glDepthRangef;
    /// <summary>
    /// Specify mapping of depth values from normalized device coordinates to window coordinates.
    /// </summary>
    /// <param name="n">Specifies the near value for the depth range.</param>
    /// <param name="f">Specifies the far value for the depth range.</param>
    public void glDepthRangef(GLfloat n, GLfloat f) => _glDepthRangef(n, f);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARDEPTHFPROC(GLfloat d);
    private PFNGLCLEARDEPTHFPROC _glClearDepthf;
    /// <summary>
    /// Specify the clear value for the depth buffer.
    /// </summary>
    /// <param name="d">Specifies the depth value used when the depth buffer is cleared. The initial value is 1.</param>
    public void glClearDepthf(GLfloat d) => _glClearDepthf(d);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETPROGRAMBINARYPROC(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary);
    private PFNGLGETPROGRAMBINARYPROC _glGetProgramBinary;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Returns a binary representation of the compiled and linked executable for a program object.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose executable binary is to be returned.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is specified by <paramref name="binary"/>.</param>
    /// <param name="length">Returns the number of bytes actually written into <paramref name="binary"/>.</param>
    /// <param name="binaryFormat">Returns the format of the program binary.</param>
    /// <param name="binary">Returns the program binary.</param>
    public void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary) => _glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Returns a binary representation of the compiled and linked executable for a program object.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose executable binary is to be returned.</param>
    /// <param name="bufSize">Specifies the maximum amount of bytes that may be returned.</param>
    /// <param name="binaryFormat">Returns the format of the program binary.</param>
    /// <returns>Returns the program binary as bytes.</returns>
    public byte[] glGetProgramBinary(GLuint program, GLsizei bufSize, out GLenum binaryFormat)
    {
        byte[] binary = new byte[bufSize];
        GLsizei length;
        fixed (byte* pBinary = &binary[0])
        fixed (GLenum* pBinaryFormat = &binaryFormat)
        {
            _glGetProgramBinary(program, bufSize, &length, pBinaryFormat, pBinary);
        }
        Array.Resize(ref binary, length);
        return binary;
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMBINARYPROC(GLuint program, GLenum binaryFormat, void* binary, GLsizei length);
    private PFNGLPROGRAMBINARYPROC _glProgramBinary;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Loads a program binary.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose executable binary is to be replaced.</param>
    /// <param name="binaryFormat">Specifies the format of the binary data in <paramref name="binary"/>.</param>
    /// <param name="binary">Specifies a pointer to a buffer containing the executable binary data that will be loaded into <paramref name="program"/>.</param>
    /// <param name="length">Specifies the number of bytes contained in <paramref name="binary"/>.</param>
    public void glProgramBinary(GLuint program, GLenum binaryFormat, void* binary, GLsizei length) => _glProgramBinary(program, binaryFormat, binary, length);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Loads a program binary.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose executable binary is to be replaced.</param>
    /// <param name="binaryFormat">Specifies the format of the binary data in <paramref name="binary"/>.</param>
    /// <param name="binary">Specifies a buffer containing the executable binary data that will be loaded into <paramref name="program"/>.</param>
    public void glProgramBinary(GLuint program, GLenum binaryFormat, byte[] binary)
    {
        fixed (byte* pBinary = &binary[0])
        {
            _glProgramBinary(program, binaryFormat, pBinary, binary.Length);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMPARAMETERIPROC(GLuint program, GLenum pname, GLint value);
    private PFNGLPROGRAMPARAMETERIPROC _glProgramParameteri;
    /// <summary>
    /// Specify a parameter for a program object
    /// </summary>
    /// <param name="program">Specifies the program object to be modified.</param>
    /// <param name="pname">Specifies the name of the parameter to modify.</param>
    /// <param name="value">Specifies the new value for <paramref name="pname"/>.</param>
    public void glProgramParameteri(GLuint program, GLenum pname, GLint value) => _glProgramParameteri(program, pname, value);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLUSEPROGRAMSTAGESPROC(GLuint pipeline, GLbitfield stages, GLuint program);
    private PFNGLUSEPROGRAMSTAGESPROC _glUseProgramStages;
    /// <summary>
    /// Bind stages of a program object to a program pipeline.
    /// </summary>
    /// <param name="pipeline">Specifies the name of the program pipeline object to which to bind the program object.</param>
    /// <param name="stages">Specifies a set of program stages.</param>
    /// <param name="program">Specifies the name of a program object.</param>
    public void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program) => _glUseProgramStages(pipeline, stages, program);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLACTIVESHADERPROGRAMPROC(GLuint pipeline, GLuint program);
    private PFNGLACTIVESHADERPROGRAMPROC _glActiveShaderProgram;
    /// <summary>
    /// Set the active program object for a program pipeline object.
    /// </summary>
    /// <param name="pipeline">Specifies the name of a program pipeline object whose active program object is to be set.</param>
    /// <param name="program">Specifies the name of a program object to set as the active program object of <paramref name="pipeline"/>.</param>
    public void glActiveShaderProgram(GLuint pipeline, GLuint program) => _glActiveShaderProgram(pipeline, program);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLuint PFNGLCREATESHADERPROGRAMVPROC(GLenum type, GLsizei count, GLchar** strings);
    private PFNGLCREATESHADERPROGRAMVPROC _glCreateShaderProgramv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Create a stand-alone program from an array of null-terminated source code strings.
    /// </summary>
    /// <param name="type">Specifies the type of shader to be created.</param>
    /// <param name="count">Specifies the number of elements in the array <paramref name="strings"/>.</param>
    /// <param name="strings">Specifies an array of pointers to strings containing the source code to be loaded into the shader.</param>
    public GLuint glCreateShaderProgramv(GLenum type, GLsizei count, GLchar** strings) => _glCreateShaderProgramv(type, count, strings);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Create a stand-alone program from an array of null-terminated source code strings.
    /// </summary>
    /// <param name="type">Specifies the type of shader to be created.</param>
    /// <param name="strings">Specifies an array of strings containing the source code to be loaded into the shader.</param>
    public GLuint glCreateShaderProgramv(GLenum type, string[] strings)
    {
        // https://stackoverflow.com/questions/27777226/how-to-use-glcreateshaderprogram

        GLchar[][] stringsBytes = new GLchar[strings.Length][];
        for (int i = 0; i < strings.Length; i++)
        {
            stringsBytes[i] = Encoding.UTF8.GetBytes(strings[i]);
        }

        GLchar*[] stringsPtrs = new GLchar*[strings.Length];
        for (int i = 0; i < strings.Length; i++)
        {
            fixed (GLchar* pString = &stringsBytes[i][0])
            {
                stringsPtrs[i] = pString;
            }
        }

        fixed (GLchar** pStrings = &stringsPtrs[0])
        {
            return _glCreateShaderProgramv(type, strings.Length, pStrings);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDPROGRAMPIPELINEPROC(GLuint pipeline);
    private PFNGLBINDPROGRAMPIPELINEPROC _glBindProgramPipeline;
    /// <summary>
    /// Bind a program pipeline to the current context
    /// </summary>
    /// <param name="pipeline">Specifies the name of a program pipeline object to bind to the current context.</param>
    public void glBindProgramPipeline(GLuint pipeline) => _glBindProgramPipeline(pipeline);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDELETEPROGRAMPIPELINESPROC(GLsizei n, GLuint* pipelines);
    private PFNGLDELETEPROGRAMPIPELINESPROC _glDeleteProgramPipelines;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Delete program pipelines
    /// </summary>
    /// <param name="n">Specifies the number of program pipeline objects to be deleted.</param>
    /// <param name="pipelines">Specifies an array of <paramref name="n"/> values, containing the names of the program pipeline objects to be deleted.</param>
    public void glDeleteProgramPipelines(GLsizei n, GLuint* pipelines) => _glDeleteProgramPipelines(n, pipelines);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Delete program pipelines
    /// </summary>
    /// <param name="pipelines">Specifies an array of program pipeline objects to be deleted.</param>
    public void glDeleteProgramPipelines(params GLuint[] pipelines) { fixed (GLuint* pPipelines =
 &pipelines[0]) { _glDeleteProgramPipelines(pipelines.Length, pPipelines); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGENPROGRAMPIPELINESPROC(GLsizei n, GLuint* pipelines);
    private PFNGLGENPROGRAMPIPELINESPROC _glGenProgramPipelines;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate program pipeline object names
    /// </summary>
    /// <param name="n">Specifies the number of program pipeline object names to generate.</param>
    /// <param name="pipelines">Specifies an array in which the generated program pipeline object names are stored.</param>
    public void glGenProgramPipelines(GLsizei n, GLuint* pipelines) => _glGenProgramPipelines(n, pipelines);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate program pipeline object names
    /// </summary>
    /// <param name="n">Specifies the number of program pipeline object names to generate.</param>
    /// <returns>Array of <paramref name="n"/> generated program pipeline object names.</returns>
    public GLuint[] glGenProgramPipelines(GLsizei n) { GLuint[] pipelines = new GLuint[n]; fixed (GLuint* pPipelines =
 &pipelines[0]) { _glGenProgramPipelines(n, pPipelines); } return pipelines; }
    /// <summary>
    /// Generate a single program pipeline object name
    /// </summary>
    /// <returns>Generated program pipeline object name.</returns>
    public GLuint glGenProgramPipeline() => glGenProgramPipelines(1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLboolean PFNGLISPROGRAMPIPELINEPROC(GLuint pipeline);
    private PFNGLISPROGRAMPIPELINEPROC _glIsProgramPipeline;
    /// <summary>
    /// Determine if a name corresponds to a program pipeline object
    /// </summary>
    /// <param name="pipeline">Specifies a value that may be the name of a program pipeline object.</param>
    /// <returns><see langword="true"/>, if <paramref name="pipeline"/> is the name of a program pipeline object. Otherwise, <see langword="false"/>.</returns>
    public GLboolean glIsProgramPipeline(GLuint pipeline) => _glIsProgramPipeline(pipeline);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETPROGRAMPIPELINEIVPROC(GLuint pipeline, GLenum pname, GLint* param);
    private PFNGLGETPROGRAMPIPELINEIVPROC _glGetProgramPipelineiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return a parameter from a program pipeline object
    /// </summary>
    /// <param name="pipeline">Specifies the name of a program pipeline object from which to retrieve <paramref name="pname"/>.</param>
    /// <param name="pname">Specifies the parameter to retrieve from the program pipeline object named <paramref name="pipeline"/>.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of the retrieved parameter.</param>
    public void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint* param) => _glGetProgramPipelineiv(pipeline, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return a parameter from a program pipeline object
    /// </summary>
    /// <param name="pipeline">Specifies the name of a program pipeline object from which to retrieve <paramref name="pname"/>.</param>
    /// <param name="pname">Specifies the parameter to retrieve from the program pipeline object named <paramref name="pipeline"/>.</param>
    /// <param name="param">Specifies an array to receive the value of the retrieved parameter.</param>
    public void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, ref GLint[] param) { fixed (GLint* pParam =
 &param[0]) { _glGetProgramPipelineiv(pipeline, pname, pParam); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM1IPROC(GLuint program, GLint location, GLint v0);
    private PFNGLPROGRAMUNIFORM1IPROC _glProgramUniform1i;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the new value to be used for the specified uniform variable.</param>
    public void glProgramUniform1i(GLuint program, GLint location, GLint v0) => _glProgramUniform1i(program, location, v0);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM1IVPROC(GLuint program, GLint location, GLsizei count, GLint* value);
    private PFNGLPROGRAMUNIFORM1IVPROC _glProgramUniform1iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, GLint* value) => _glProgramUniform1iv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform1iv(GLuint program, GLint location, GLint[] value) { fixed (GLint* pValue =
 &value[0]) { _glProgramUniform1iv(program, location, value.Length, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM1FPROC(GLuint program, GLint location, GLfloat v0);
    private PFNGLPROGRAMUNIFORM1FPROC _glProgramUniform1f;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the new value to be used for the specified uniform variable.</param>
    public void glProgramUniform1f(GLuint program, GLint location, GLfloat v0) => _glProgramUniform1f(program, location, v0);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM1FVPROC(GLuint program, GLint location, GLsizei count, GLfloat* value);
    private PFNGLPROGRAMUNIFORM1FVPROC _glProgramUniform1fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, GLfloat* value) => _glProgramUniform1fv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform1fv(GLuint program, GLint location, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniform1fv(program, location, value.Length, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM1DPROC(GLuint program, GLint location, GLdouble v0);
    private PFNGLPROGRAMUNIFORM1DPROC _glProgramUniform1d;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the new value to be used for the specified uniform variable.</param>
    public void glProgramUniform1d(GLuint program, GLint location, GLdouble v0) => _glProgramUniform1d(program, location, v0);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM1DVPROC(GLuint program, GLint location, GLsizei count, GLdouble* value);
    private PFNGLPROGRAMUNIFORM1DVPROC _glProgramUniform1dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform1dv(GLuint program, GLint location, GLsizei count, GLdouble* value) => _glProgramUniform1dv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform1dv(GLuint program, GLint location, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniform1dv(program, location, value.Length, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM1UIPROC(GLuint program, GLint location, GLuint v0);
    private PFNGLPROGRAMUNIFORM1UIPROC _glProgramUniform1ui;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the new value to be used for the specified uniform variable.</param>
    public void glProgramUniform1ui(GLuint program, GLint location, GLuint v0) => _glProgramUniform1ui(program, location, v0);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM1UIVPROC(GLuint program, GLint location, GLsizei count, GLuint* value);
    private PFNGLPROGRAMUNIFORM1UIVPROC _glProgramUniform1uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, GLuint* value) => _glProgramUniform1uiv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>

    public void glProgramUniform1uiv(GLuint program, GLint location, GLuint[] value) { fixed (GLuint* pValue =
 &value[0]) { _glProgramUniform1uiv(program, location, value.Length, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM2IPROC(GLuint program, GLint location, GLint v0, GLint v1);
    private PFNGLPROGRAMUNIFORM2IPROC _glProgramUniform2i;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    public void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1) => _glProgramUniform2i(program, location, v0, v1);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM2IVPROC(GLuint program, GLint location, GLsizei count, GLint* value);
    private PFNGLPROGRAMUNIFORM2IVPROC _glProgramUniform2iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, GLint* value) => _glProgramUniform2iv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform2iv(GLuint program, GLint location, GLint[] value) { fixed (GLint* pValue =
 &value[0]) { _glProgramUniform2iv(program, location, value.Length / 2, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM2FPROC(GLuint program, GLint location, GLfloat v0, GLfloat v1);
    private PFNGLPROGRAMUNIFORM2FPROC _glProgramUniform2f;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    public void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1) => _glProgramUniform2f(program, location, v0, v1);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM2FVPROC(GLuint program, GLint location, GLsizei count, GLfloat* value);
    private PFNGLPROGRAMUNIFORM2FVPROC _glProgramUniform2fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, GLfloat* value) => _glProgramUniform2fv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform2fv(GLuint program, GLint location, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniform2fv(program, location, value.Length / 2, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM2DPROC(GLuint program, GLint location, GLdouble v0, GLdouble v1);
    private PFNGLPROGRAMUNIFORM2DPROC _glProgramUniform2d;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    public void glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1) => _glProgramUniform2d(program, location, v0, v1);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM2DVPROC(GLuint program, GLint location, GLsizei count, GLdouble* value);
    private PFNGLPROGRAMUNIFORM2DVPROC _glProgramUniform2dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform2dv(GLuint program, GLint location, GLsizei count, GLdouble* value) => _glProgramUniform2dv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform2dv(GLuint program, GLint location, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniform2dv(program, location, value.Length / 2, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM2UIPROC(GLuint program, GLint location, GLuint v0, GLuint v1);
    private PFNGLPROGRAMUNIFORM2UIPROC _glProgramUniform2ui;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    public void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1) => _glProgramUniform2ui(program, location, v0, v1);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM2UIVPROC(GLuint program, GLint location, GLsizei count, GLuint* value);
    private PFNGLPROGRAMUNIFORM2UIVPROC _glProgramUniform2uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, GLuint* value) => _glProgramUniform2uiv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform2uiv(GLuint program, GLint location, GLuint[] value) { fixed (GLuint* pValue =
 &value[0]) { _glProgramUniform2uiv(program, location, value.Length / 2, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM3IPROC(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
    private PFNGLPROGRAMUNIFORM3IPROC _glProgramUniform3i;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    /// <param name="v2">Specifies the third new value to be used for the specified uniform variable.</param>
    public void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) => _glProgramUniform3i(program, location, v0, v1, v2);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM3IVPROC(GLuint program, GLint location, GLsizei count, GLint* value);
    private PFNGLPROGRAMUNIFORM3IVPROC _glProgramUniform3iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, GLint* value) => _glProgramUniform3iv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform3iv(GLuint program, GLint location, GLint[] value) { fixed (GLint* pValue =
 &value[0]) { _glProgramUniform3iv(program, location, value.Length / 3, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM3FPROC(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
    private PFNGLPROGRAMUNIFORM3FPROC _glProgramUniform3f;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    /// <param name="v2">Specifies the third new value to be used for the specified uniform variable.</param>
    public void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) => _glProgramUniform3f(program, location, v0, v1, v2);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM3FVPROC(GLuint program, GLint location, GLsizei count, GLfloat* value);
    private PFNGLPROGRAMUNIFORM3FVPROC _glProgramUniform3fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, GLfloat* value) => _glProgramUniform3fv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform3fv(GLuint program, GLint location, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniform3fv(program, location, value.Length / 3, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM3DPROC(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
    private PFNGLPROGRAMUNIFORM3DPROC _glProgramUniform3d;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    /// <param name="v2">Specifies the third new value to be used for the specified uniform variable.</param>
    public void glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) => _glProgramUniform3d(program, location, v0, v1, v2);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM3DVPROC(GLuint program, GLint location, GLsizei count, GLdouble* value);
    private PFNGLPROGRAMUNIFORM3DVPROC _glProgramUniform3dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform3dv(GLuint program, GLint location, GLsizei count, GLdouble* value) => _glProgramUniform3dv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform3dv(GLuint program, GLint location, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniform3dv(program, location, value.Length / 3, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM3UIPROC(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
    private PFNGLPROGRAMUNIFORM3UIPROC _glProgramUniform3ui;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    /// <param name="v2">Specifies the third new value to be used for the specified uniform variable.</param>
    public void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) => _glProgramUniform3ui(program, location, v0, v1, v2);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM3UIVPROC(GLuint program, GLint location, GLsizei count, GLuint* value);
    private PFNGLPROGRAMUNIFORM3UIVPROC _glProgramUniform3uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, GLuint* value) => _glProgramUniform3uiv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform3uiv(GLuint program, GLint location, GLuint[] value) { fixed (GLuint* pValue =
 &value[0]) { _glProgramUniform3uiv(program, location, value.Length / 3, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM4IPROC(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
    private PFNGLPROGRAMUNIFORM4IPROC _glProgramUniform4i;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    /// <param name="v2">Specifies the third new value to be used for the specified uniform variable.</param>
    /// <param name="v3">Specifies the fourth new value to be used for the specified uniform variable.</param>
    public void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) => _glProgramUniform4i(program, location, v0, v1, v2, v3);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM4IVPROC(GLuint program, GLint location, GLsizei count, GLint* value);
    private PFNGLPROGRAMUNIFORM4IVPROC _glProgramUniform4iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, GLint* value) => _glProgramUniform4iv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform4iv(GLuint program, GLint location, GLint[] value) { fixed (GLint* pValue =
 &value[0]) { _glProgramUniform4iv(program, location, value.Length / 4, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM4FPROC(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
    private PFNGLPROGRAMUNIFORM4FPROC _glProgramUniform4f;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    /// <param name="v2">Specifies the third new value to be used for the specified uniform variable.</param>
    /// <param name="v3">Specifies the fourth new value to be used for the specified uniform variable.</param>
    public void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) => _glProgramUniform4f(program, location, v0, v1, v2, v3);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM4FVPROC(GLuint program, GLint location, GLsizei count, GLfloat* value);
    private PFNGLPROGRAMUNIFORM4FVPROC _glProgramUniform4fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, GLfloat* value) => _glProgramUniform4fv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform4fv(GLuint program, GLint location, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniform4fv(program, location, value.Length / 4, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM4DPROC(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
    private PFNGLPROGRAMUNIFORM4DPROC _glProgramUniform4d;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    /// <param name="v2">Specifies the third new value to be used for the specified uniform variable.</param>
    /// <param name="v3">Specifies the fourth new value to be used for the specified uniform variable.</param>
    public void glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) => _glProgramUniform4d(program, location, v0, v1, v2, v3);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM4DVPROC(GLuint program, GLint location, GLsizei count, GLdouble* value);
    private PFNGLPROGRAMUNIFORM4DVPROC _glProgramUniform4dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform4dv(GLuint program, GLint location, GLsizei count, GLdouble* value) => _glProgramUniform4dv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform4dv(GLuint program, GLint location, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniform4dv(program, location, value.Length / 4, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM4UIPROC(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
    private PFNGLPROGRAMUNIFORM4UIPROC _glProgramUniform4ui;
    /// <summary>
    /// Specify the value of a uniform variable for a specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="v0">Specifies the first new value to be used for the specified uniform variable.</param>
    /// <param name="v1">Specifies the second new value to be used for the specified uniform variable.</param>
    /// <param name="v2">Specifies the third new value to be used for the specified uniform variable.</param>
    /// <param name="v3">Specifies the fourth new value to be used for the specified uniform variable.</param>
    public void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) => _glProgramUniform4ui(program, location, v0, v1, v2, v3);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORM4UIVPROC(GLuint program, GLint location, GLsizei count, GLuint* value);
    private PFNGLPROGRAMUNIFORM4UIVPROC _glProgramUniform4uiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, GLuint* value) => _glProgramUniform4uiv(program, location, count, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniform4uiv(GLuint program, GLint location, GLuint[] value) { fixed (GLuint* pValue =
 &value[0]) { _glProgramUniform4uiv(program, location, value.Length / 4, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX2FVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value);
    private PFNGLPROGRAMUNIFORMMATRIX2FVPROC _glProgramUniformMatrix2fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value) => _glProgramUniformMatrix2fv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2fv(GLuint program, GLint location, GLboolean transpose, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniformMatrix2fv(program, location, value.Length / 4, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX3FVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value);
    private PFNGLPROGRAMUNIFORMMATRIX3FVPROC _glProgramUniformMatrix3fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value) => _glProgramUniformMatrix3fv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3fv(GLuint program, GLint location, GLboolean transpose, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniformMatrix3fv(program, location, value.Length / 9, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX4FVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value);
    private PFNGLPROGRAMUNIFORMMATRIX4FVPROC _glProgramUniformMatrix4fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value) => _glProgramUniformMatrix4fv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4fv(GLuint program, GLint location, GLboolean transpose, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniformMatrix4fv(program, location, value.Length / 16, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX2DVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLPROGRAMUNIFORMMATRIX2DVPROC _glProgramUniformMatrix2dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value) => _glProgramUniformMatrix2dv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2dv(GLuint program, GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniformMatrix2dv(program, location, value.Length / 4, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX3DVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLPROGRAMUNIFORMMATRIX3DVPROC _glProgramUniformMatrix3dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value) => _glProgramUniformMatrix3dv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3dv(GLuint program, GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniformMatrix3dv(program, location, value.Length / 9, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX4DVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLPROGRAMUNIFORMMATRIX4DVPROC _glProgramUniformMatrix4dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value) => _glProgramUniformMatrix4dv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4dv(GLuint program, GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniformMatrix4dv(program, location, value.Length / 16, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value);
    private PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC _glProgramUniformMatrix2x3fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value) => _glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLboolean transpose, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniformMatrix2x3fv(program, location, value.Length / 6, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value);
    private PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC _glProgramUniformMatrix3x2fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value) => _glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLboolean transpose, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniformMatrix3x2fv(program, location, value.Length / 6, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value);
    private PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC _glProgramUniformMatrix2x4fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value) => _glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLboolean transpose, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniformMatrix2x4fv(program, location, value.Length / 8, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value);
    private PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC _glProgramUniformMatrix4x2fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value) => _glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLboolean transpose, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniformMatrix4x2fv(program, location, value.Length / 8, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value);
    private PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC _glProgramUniformMatrix3x4fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value) => _glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLboolean transpose, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniformMatrix3x4fv(program, location, value.Length / 12, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value);
    private PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC _glProgramUniformMatrix4x3fv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLfloat* value) => _glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLboolean transpose, GLfloat[] value) { fixed (GLfloat* pValue =
 &value[0]) { _glProgramUniformMatrix4x3fv(program, location, value.Length / 12, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC _glProgramUniformMatrix2x3dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value) => _glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniformMatrix2x3dv(program, location, value.Length / 6, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC _glProgramUniformMatrix3x2dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value) => _glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniformMatrix3x2dv(program, location, value.Length / 6, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC _glProgramUniformMatrix2x4dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value) => _glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniformMatrix2x4dv(program, location, value.Length / 8, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC _glProgramUniformMatrix4x2dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value) => _glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniformMatrix4x2dv(program, location, value.Length / 8, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC _glProgramUniformMatrix3x4dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value) => _glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniformMatrix3x4dv(program, location, value.Length / 12, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value);
    private PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC _glProgramUniformMatrix4x3dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="count">Specifies the number of elements that are to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies a pointer to an array of <paramref name="count"/> values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value) => _glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a uniform variable for the current program object
    /// </summary>
    /// <param name="program">Specifies the program object containing the uniform variable to be modified.</param>
    /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
    /// <param name="transpose">Specifies whether to transpose the matrix as the values are loaded into the uniform variable.</param>
    /// <param name="value">Specifies an array of values that will be used to update the specified uniform variable.</param>
    public void glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLboolean transpose, GLdouble[] value) { fixed (GLdouble* pValue =
 &value[0]) { _glProgramUniformMatrix4x3dv(program, location, value.Length / 12, transpose, pValue); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVALIDATEPROGRAMPIPELINEPROC(GLuint pipeline);
    private PFNGLVALIDATEPROGRAMPIPELINEPROC _glValidateProgramPipeline;
    /// <summary>
    /// Validate a program pipeline object
    /// </summary>
    /// <param name="pipeline">Specifies the name of a program pipeline object to validate.</param>
    public void glValidateProgramPipeline(GLuint pipeline) => _glValidateProgramPipeline(pipeline);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETPROGRAMPIPELINEINFOLOGPROC(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
    private PFNGLGETPROGRAMPIPELINEINFOLOGPROC _glGetProgramPipelineInfoLog;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the information log for a program pipeline object
    /// </summary>
    /// <param name="pipeline">Specifies the name of a program pipeline object whose information log is to be queried.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given by <paramref name="infoLog"/>.</param>
    /// <param name="length">Returns the number of characters written into the buffer indicated by <paramref name="infoLog"/> (excluding the null terminator) if a value other than NULL is passed.</param>
    /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
    public void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) => _glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the information log for a program pipeline object
    /// </summary>
    /// <param name="pipeline">Specifies the name of a program pipeline object whose information log is to be queried.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given by <paramref name="infoLog"/>.</param>
    /// <returns>The information log for the specified program pipeline object.</returns>
    public string glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize)
    {
        GLchar[] infoLog = new GLchar[bufSize];
        GLsizei length;
        fixed (GLchar* pInfoLog = &infoLog[0])
        {
            _glGetProgramPipelineInfoLog(pipeline, bufSize, &length, pInfoLog);
            return new string((sbyte*)pInfoLog, 0, length, Encoding.UTF8);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBL1DPROC(GLuint index, GLdouble x);
    private PFNGLVERTEXATTRIBL1DPROC _glVertexAttribL1d;
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the new value for the generic vertex attribute.</param>
    public void glVertexAttribL1d(GLuint index, GLdouble x) => _glVertexAttribL1d(index, x);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBL2DPROC(GLuint index, GLdouble x, GLdouble y);
    private PFNGLVERTEXATTRIBL2DPROC _glVertexAttribL2d;
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first new value for the generic vertex attribute.</param>
    /// <param name="y">Specifies the second new value for the generic vertex attribute.</param>
    public void glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y) => _glVertexAttribL2d(index, x, y);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBL3DPROC(GLuint index, GLdouble x, GLdouble y, GLdouble z);
    private PFNGLVERTEXATTRIBL3DPROC _glVertexAttribL3d;
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first new value for the generic vertex attribute.</param>
    /// <param name="y">Specifies the second new value for the generic vertex attribute.</param>
    /// <param name="z">Specifies the third new value for the generic vertex attribute.</param>
    public void glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) => _glVertexAttribL3d(index, x, y, z);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBL4DPROC(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
    private PFNGLVERTEXATTRIBL4DPROC _glVertexAttribL4d;
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="x">Specifies the first new value for the generic vertex attribute.</param>
    /// <param name="y">Specifies the second new value for the generic vertex attribute.</param>
    /// <param name="z">Specifies the third new value for the generic vertex attribute.</param>
    /// <param name="w">Specifies the fourth new value for the generic vertex attribute.</param>
    public void glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) => _glVertexAttribL4d(index, x, y, z, w);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBL1DVPROC(GLuint index, GLdouble* v);
    private PFNGLVERTEXATTRIBL1DVPROC _glVertexAttribL1dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of a single double-precision floating-point value that will be used to update the generic vertex attribute.</param>
    public void glVertexAttribL1dv(GLuint index, GLdouble* v) => _glVertexAttribL1dv(index, v);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array of a single double-precision floating-point value that will be used to update the generic vertex attribute.</param>
    public void glVertexAttribL1dv(GLuint index, GLdouble[] v) { fixed (GLdouble* pV = &v[0]) { _glVertexAttribL1dv(index, pV); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBL2DVPROC(GLuint index, GLdouble* v);
    private PFNGLVERTEXATTRIBL2DVPROC _glVertexAttribL2dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of a two-element array that will be used to update the generic vertex attribute.</param>
    public void glVertexAttribL2dv(GLuint index, GLdouble* v) => _glVertexAttribL2dv(index, v);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that will be used to update the generic vertex attribute.</param>
    public void glVertexAttribL2dv(GLuint index, GLdouble[] v) { fixed (GLdouble* pV = &v[0]) { _glVertexAttribL2dv(index, pV); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBL3DVPROC(GLuint index, GLdouble* v);
    private PFNGLVERTEXATTRIBL3DVPROC _glVertexAttribL3dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of a three-element array that will be used to update the generic vertex attribute.</param>
    public void glVertexAttribL3dv(GLuint index, GLdouble* v) => _glVertexAttribL3dv(index, v);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that will be used to update the generic vertex attribute.</param>
    public void glVertexAttribL3dv(GLuint index, GLdouble[] v) { fixed (GLdouble* pV = &v[0]) { _glVertexAttribL3dv(index, pV); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBL4DVPROC(GLuint index, GLdouble* v);
    private PFNGLVERTEXATTRIBL4DVPROC _glVertexAttribL4dv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies the address of a four-element array that will be used to update the generic vertex attribute.</param>
    public void glVertexAttribL4dv(GLuint index, GLdouble* v) => _glVertexAttribL4dv(index, v);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="v">Specifies an array that will be used to update the generic vertex attribute.</param>
    public void glVertexAttribL4dv(GLuint index, GLdouble[] v) { fixed (GLdouble* pV = &v[0]) { _glVertexAttribL4dv(index, pV); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBLPOINTERPROC(GLuint index, GLint size, GLenum type, GLsizei stride, void* pointer);
    private PFNGLVERTEXATTRIBLPOINTERPROC _glVertexAttribLPointer;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Define an array of generic vertex attribute data
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.</param>
    /// <param name="type">Specifies the data type of each component in the array. The symbolic constants <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_SHORT"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_DOUBLE"/>.</param>
    /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
    /// <param name="pointer">Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.</param>
    public void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, void* pointer) => _glVertexAttribLPointer(index, size, type, stride, pointer);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Define an array of generic vertex attribute data
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.</param>
    /// <param name="type">Specifies the data type of each component in the array. The symbolic constants <see cref="IGL.GL_BYTE"/>, <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_SHORT"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, <see cref="IGL.GL_INT"/>, <see cref="IGL.GL_UNSIGNED_INT"/>, <see cref="IGL.GL_DOUBLE"/>.</param>
    /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
    /// <param name="pointer">Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.</param>
    public void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, GLsizei pointer) => _glVertexAttribLPointer(index, size, type, stride, (void*)pointer);
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETVERTEXATTRIBLDVPROC(GLuint index, GLenum pname, GLdouble* parameters);
    private PFNGLGETVERTEXATTRIBLDVPROC _glGetVertexAttribLdv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute.</param>
    /// <param name="pname">Specifies the symbolic name of the generic vertex attribute parameter to be queried. The following symbolic names are accepted: <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>, <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>.</param>
    /// <param name="parameters">Returns the requested data.</param>
    public void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble* parameters) => _glGetVertexAttribLdv(index, pname, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the value of a generic vertex attribute
    /// </summary>
    /// <param name="index">Specifies the index of the generic vertex attribute.</param>
    /// <param name="pname">Specifies the symbolic name of the generic vertex attribute parameter to be queried. The following symbolic names are accepted: <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_ENABLED"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_SIZE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_STRIDE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_TYPE"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_INTEGER"/>, <see cref="IGL.GL_VERTEX_ATTRIB_ARRAY_DIVISOR"/>, <see cref="IGL.GL_CURRENT_VERTEX_ATTRIB"/>.</param>
    /// <param name="parameters">Returns the requested data.</param>
    public void glGetVertexAttribLdv(GLuint index, GLenum pname, ref GLdouble[] parameters) { fixed (GLdouble* pP =
 &parameters[0]) { _glGetVertexAttribLdv(index, pname, pP); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVIEWPORTARRAYVPROC(GLuint first, GLsizei count, GLfloat* v);
    private PFNGLVIEWPORTARRAYVPROC _glViewportArrayv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the viewport transformation parameters for multiple viewports
    /// </summary>
    /// <param name="first">Specifies the index of the first viewport to set.</param>
    /// <param name="count">Specifies the number of viewports to set.</param>
    /// <param name="v">Specifies the address of an array containing the left, bottom, width, and height of each viewport, respectively. The parameters of each viewport, left, bottom, width, and height, are stored in array order. The initial value is (0,0,0,0).</param>
    public void glViewportArrayv(GLuint first, GLsizei count, GLfloat* v) => _glViewportArrayv(first, count, v);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the viewport transformation parameters for multiple viewports
    /// </summary>
    /// <param name="first">Specifies the index of the first viewport to set.</param>
    /// <param name="count">Specifies the number of viewports to set.</param>
    /// <param name="v">Specifies the address of an array containing the left, bottom, width, and height of each viewport, respectively. The parameters of each viewport, left, bottom, width, and height, are stored in array order. The initial value is (0,0,0,0).</param>
    public void glViewportArrayv(GLuint first, GLsizei count, params GLfloat[] v) { fixed (GLfloat* pV =
 &v[0]) { _glViewportArrayv(first, count, pV); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVIEWPORTINDEXEDFPROC(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
    private PFNGLVIEWPORTINDEXEDFPROC _glViewportIndexedf;
    /// <summary>
    /// Specify the viewport transformation parameters for a specified viewport
    /// </summary>
    /// <param name="index">Specifies the index of the viewport to be modified.</param>
    /// <param name="x">Specify the left viewport coordinate.</param>
    /// <param name="y">Specify the bottom viewport coordinate.</param>
    /// <param name="w">Specify the viewport width.</param>
    /// <param name="h">Specify the viewport height.</param>
    public void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) => _glViewportIndexedf(index, x, y, w, h);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVIEWPORTINDEXEDFVPROC(GLuint index, GLfloat* v);
    private PFNGLVIEWPORTINDEXEDFVPROC _glViewportIndexedfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the viewport transformation parameters for a specified viewport
    /// </summary>
    /// <param name="index">Specifies the index of the viewport to be modified.</param>
    /// <param name="v">Specifies the address of an array containing the left, bottom, width, and height of the viewport rectangle, in that order. The initial value is (0,0,0,0).</param>
    public void glViewportIndexedfv(GLuint index, GLfloat* v) => _glViewportIndexedfv(index, v);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the viewport transformation parameters for a specified viewport
    /// </summary>
    /// <param name="index">Specifies the index of the viewport to be modified.</param>
    /// <param name="v">Specifies the address of an array containing the left, bottom, width, and height of the viewport rectangle, in that order. The initial value is (0,0,0,0).</param>
    public void glViewportIndexedfv(GLuint index, params GLfloat[] v) { fixed (GLfloat* pV = &v[0]) { _glViewportIndexedfv(index, pV); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLSCISSORARRAYVPROC(GLuint first, GLsizei count, GLint* v);
    private PFNGLSCISSORARRAYVPROC _glScissorArrayv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Define the scissor box for multiple viewports
    /// </summary>
    /// <param name="first">Specifies the index of the first scissor box to set.</param>
    /// <param name="count">Specifies the number of scissor boxes to set.</param>
    /// <param name="v">Specifies the address of an array containing the left, bottom, width, and height of each scissor box, respectively. The parameters of each scissor box, left, bottom, width, and height, are stored in array order. The initial value is (0,0,0,0).</param>
    public void glScissorArrayv(GLuint first, GLsizei count, GLint* v) => _glScissorArrayv(first, count, v);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Define the scissor box for multiple viewports
    /// </summary>
    /// <param name="first">Specifies the index of the first scissor box to set.</param>
    /// <param name="count">Specifies the number of scissor boxes to set.</param>
    /// <param name="v">Specifies the address of an array containing the left, bottom, width, and height of each scissor box, respectively. The parameters of each scissor box, left, bottom, width, and height, are stored in array order. The initial value is (0,0,0,0).</param>
    public void glScissorArrayv(GLuint first, GLsizei count, params GLint[] v) { fixed (GLint* pV = &v[0]) { _glScissorArrayv(first, count, pV); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLSCISSORINDEXEDPROC(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
    private PFNGLSCISSORINDEXEDPROC _glScissorIndexed;
    /// <summary>
    /// Define the scissor box for a specified viewport
    /// </summary>
    /// <param name="index">Specifies the index of the viewport whose scissor box to modify.</param>
    /// <param name="left">Specify the left scissor box coordinate.</param>
    /// <param name="bottom">Specify the bottom scissor box coordinate.</param>
    /// <param name="width">Specify the scissor box width.</param>
    /// <param name="height">Specify the scissor box height.</param>
    public void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) => _glScissorIndexed(index, left, bottom, width, height);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLSCISSORINDEXEDVPROC(GLuint index, GLint* v);
    private PFNGLSCISSORINDEXEDVPROC _glScissorIndexedv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Define the scissor box for a specified viewport
    /// </summary>
    /// <param name="index">Specifies the index of the viewport whose scissor box to modify.</param>
    /// <param name="v">Specifies the address of an array containing the left, bottom, width, and height of the scissor box. The initial value is (0,0,0,0).</param>
    public void glScissorIndexedv(GLuint index, GLint* v) => _glScissorIndexedv(index, v);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Define the scissor box for a specified viewport
    /// </summary>
    /// <param name="index">Specifies the index of the viewport whose scissor box to modify.</param>
    /// <param name="v">Specifies the address of an array containing the left, bottom, width, and height of the scissor box. The initial value is (0,0,0,0).</param>
    public void glScissorIndexedv(GLuint index, params GLint[] v) { fixed (GLint* pV = &v[0]) { _glScissorIndexedv(index, pV); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDEPTHRANGEARRAYVPROC(GLuint first, GLsizei count, GLdouble* v);
    private PFNGLDEPTHRANGEARRAYVPROC _glDepthRangeArrayv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
    /// </summary>
    /// <param name="first">Specifies the index of the first viewport whose depth range to update.</param>
    /// <param name="count">Specifies the number of viewports whose depth range to update.</param>
    /// <param name="v">Specifies the address of an array containing the near and far values for each viewport, respectively. The parameters of each viewport, near and far, are stored in array order. The initial value is (0,1).</param>
    public void glDepthRangeArrayv(GLuint first, GLsizei count, GLdouble* v) => _glDepthRangeArrayv(first, count, v);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
    /// </summary>
    /// <param name="first">Specifies the index of the first viewport whose depth range to update.</param>
    /// <param name="count">Specifies the number of viewports whose depth range to update.</param>
    /// <param name="v">Specifies an array containing the near and far values for each viewport, respectively. The parameters of each viewport, near and far, are stored in array order. The initial value is (0,1).</param>
    public void glDepthRangeArrayv(GLuint first, GLsizei count, params GLdouble[] v) { fixed (GLdouble* pV =
 &v[0]) { _glDepthRangeArrayv(first, count, pV); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDEPTHRANGEINDEXEDPROC(GLuint index, GLdouble n, GLdouble f);
    private PFNGLDEPTHRANGEINDEXEDPROC _glDepthRangeIndexed;
    /// <summary>
    /// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
    /// </summary>
    /// <param name="index">Specifies the index of the viewport whose depth range to update.</param>
    /// <param name="n">Specifies the near value for the depth range for the specified viewport. n must be between 0.0 and 1.0, inclusive. The initial value is 0.0.</param>
    /// <param name="f">Specifies the far value for the depth range for the specified viewport. f must be between 0.0 and 1.0, inclusive. The initial value is 1.0.</param>
    public void glDepthRangeIndexed(GLuint index, GLdouble n, GLdouble f) => _glDepthRangeIndexed(index, n, f);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETFLOATI_VPROC(GLenum target, GLuint index, GLfloat* data);
    private PFNGLGETFLOATI_VPROC _glGetFloati_v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the float value(s) of a selected state parameter for a specified indexed state target
    /// </summary>
    /// <param name="target">Specifies the state to query.</param>
    /// <param name="index">Specifies the index of the element being queried.</param>
    /// <param name="data">Returns the requested data.</param>
    public void glGetFloati_v(GLenum target, GLuint index, GLfloat* data) => _glGetFloati_v(target, index, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the float value(s) of a selected state parameter for a specified indexed state target
    /// </summary>
    /// <param name="target">Specifies the state to query.</param>
    /// <param name="index">Specifies the index of the element being queried.</param>
    /// <param name="data">Returns the requested data.</param>
    public void glGetFloati_v(GLenum target, GLuint index, ref GLfloat[] data) { fixed (GLfloat* pData =
 &data[0]) { _glGetFloati_v(target, index, pData); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETDOUBLEI_VPROC(GLenum target, GLuint index, GLdouble* data);
    private PFNGLGETDOUBLEI_VPROC _glGetDoublei_v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the double value(s) of a selected state parameter for a specified indexed state target
    /// </summary>
    /// <param name="target">Specifies the state to query.</param>
    /// <param name="index">Specifies the index of the element being queried.</param>
    /// <param name="data">Returns the requested data.</param>
    public void glGetDoublei_v(GLenum target, GLuint index, GLdouble* data) => _glGetDoublei_v(target, index, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the double value(s) of a selected state parameter for a specified indexed state target
    /// </summary>
    /// <param name="target">Specifies the state to query.</param>
    /// <param name="index">Specifies the index of the element being queried.</param>
    /// <param name="data">Returns the requested data.</param>
    public void glGetDoublei_v(GLenum target, GLuint index, ref GLdouble[] data) { fixed (GLdouble* pData =
 &data[0]) { _glGetDoublei_v(target, index, pData); } }
#endif

#endif

    // OpenGL 4.2

#if OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
    private PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC _glDrawArraysInstancedBaseInstance;
    /// <summary>
    /// Draw multiple instances of a range of elements with offset applied to instanced attributes
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="first">Specifies the starting index in the enabled arrays.</param>
    /// <param name="count">Specifies the number of indices to be rendered.</param>
    /// <param name="instancecount">Specifies the number of instances of the specified range of indices to be rendered.</param>
    /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
    public void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) => _glDrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC(GLenum mode, GLsizei count, GLenum type, void* indices, GLsizei instancecount, GLuint baseinstance);
    private PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC _glDrawElementsInstancedBaseInstance;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Draw multiple instances of a set of elements with offset applied to instanced attributes
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">Specifies the type of the values in indices. Must be one of <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.</param>
    /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
    /// <param name="instancecount">Specifies the number of instances of the specified range of indices to be rendered.</param>
    /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
    public void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, void* indices, GLsizei instancecount, GLuint baseinstance) => _glDrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Draw multiple instances of a set of elements with offset applied to instanced attributes
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">Specifies the type of the values in indices. Must be one of <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.</param>
    /// <param name="indices">Specifies an array where the indices are stored.</param>
    /// <param name="instancecount">Specifies the number of instances of the specified range of indices to be rendered.</param>
    /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
    public void glDrawElementsInstancedBaseInstance<T>(GLenum mode, GLsizei count, GLenum type, T[] indices, GLsizei instancecount, GLuint baseinstance) where T : unmanaged, IUnsignedNumber<T> { fixed (void* p
 = &indices[0]) { _glDrawElementsInstancedBaseInstance(mode, count, type, p, instancecount, baseinstance); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC(GLenum mode, GLsizei count, GLenum type, void* indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
    private PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC _glDrawElementsInstancedBaseVertexBaseInstance;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Draw multiple instances of a set of elements with offset applied to instanced attributes and a per-element offset
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">Specifies the type of the values in indices. Must be one of <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.</param>
    /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
    /// <param name="instancecount">Specifies the number of instances of the specified range of indices to be rendered.</param>
    /// <param name="basevertex">Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.</param>
    /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
    public void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, void* indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) => _glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Draw multiple instances of a set of elements with offset applied to instanced attributes and a per-element offset
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="count">Specifies the number of elements to be rendered.</param>
    /// <param name="type">Specifies the type of the values in indices. Must be one of <see cref="IGL.GL_UNSIGNED_BYTE"/>, <see cref="IGL.GL_UNSIGNED_SHORT"/>, or <see cref="IGL.GL_UNSIGNED_INT"/>.</param>
    /// <param name="indices">Specifies an array where the indices are stored.</param>
    /// <param name="instancecount">Specifies the number of instances of the specified range of indices to be rendered.</param>
    /// <param name="basevertex">Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.</param>
    /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
    public void glDrawElementsInstancedBaseVertexBaseInstance<T>(GLenum mode, GLsizei count, GLenum type, T[] indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) where T : unmanaged, IUnsignedNumber<T> { fixed (void* p
 = &indices[0]) { _glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, p, instancecount, basevertex, baseinstance); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETINTERNALFORMATIVPROC(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* @params);
    private PFNGLGETINTERNALFORMATIVPROC _glGetInternalformativ;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return information about implementation-dependent support for internal formats
    /// </summary>
    /// <param name="target">Specifies whether the information is being requested about a texture, renderbuffer, or framebuffer object.</param>
    /// <param name="internalformat">Specifies the internal format about which to retrieve information.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given in params.</param>
    /// <param name="params">Specifies the address of a buffer into which to place the returned data.</param>
    public void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* @params) => _glGetInternalformativ(target, internalformat, pname, bufSize, @params);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return information about implementation-dependent support for internal formats
    /// </summary>
    /// <param name="target">Specifies whether the information is being requested about a texture, renderbuffer, or framebuffer object.</param>
    /// <param name="internalformat">Specifies the internal format about which to retrieve information.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given in params.</param>
    /// <param name="params">Specifies the address of a buffer into which to place the returned data.</param>
    public void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, ref GLint[] @params) { fixed (GLint* p =
 &@params[0]) { _glGetInternalformativ(target, internalformat, pname, bufSize, p); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC(GLuint program, GLuint bufferIndex, GLenum pname, GLint* @params);
    private PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC _glGetActiveAtomicCounterBufferiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Query the properties of an active atomic counter buffer
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose active atomic counter buffer to query.</param>
    /// <param name="bufferIndex">Specifies the index of the active atomic counter buffer whose properties to query.</param>
    /// <param name="pname">Specifies the property of the active atomic counter buffer to query.</param>
    /// <param name="params">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint* @params) => _glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, @params);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Query the properties of an active atomic counter buffer
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose active atomic counter buffer to query.</param>
    /// <param name="bufferIndex">Specifies the index of the active atomic counter buffer whose properties to query.</param>
    /// <param name="pname">Specifies the property of the active atomic counter buffer to query.</param>
    /// <param name="params">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, ref GLint[] @params) { fixed (GLint* p =
 &@params[0]) { _glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, p); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDIMAGETEXTUREPROC(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
    private PFNGLBINDIMAGETEXTUREPROC _glBindImageTexture;
    /// <summary>
    /// Bind an image texture to an image unit
    /// </summary>
    /// <param name="unit">Specifies the index of the image unit to which to bind the texture.</param>
    /// <param name="texture">Specifies the name of a texture to bind to the specified image unit.</param>
    /// <param name="level">Specifies the mipmap level of the texture to bind.</param>
    /// <param name="layered">Specifies whether a layered texture binding is to be established.</param>
    /// <param name="layer">Specifies the layer of a layered texture to bind.</param>
    /// <param name="access">Specifies the type of access that will be performed on the image.</param>
    /// <param name="format">Specifies the format that the elements of the image will be treated as for the purposes of formatted stores.</param>
    public void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) => _glBindImageTexture(unit, texture, level, layered, layer, access, format);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLMEMORYBARRIERPROC(GLbitfield barriers);
    private PFNGLMEMORYBARRIERPROC _glMemoryBarrier;
    /// <summary>
    /// Specify the memory access semantics to be enforced prior to executing a set of GL commands that includes shader writes
    /// </summary>
    /// <param name="barriers">Specifies the barriers that are to be applied.</param>
    public void glMemoryBarrier(GLbitfield barriers) => _glMemoryBarrier(barriers);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXSTORAGE1DPROC(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
    private PFNGLTEXSTORAGE1DPROC _glTexStorage1D;
    /// <summary>
    /// Specify storage for a one-dimensional texture
    /// </summary>
    /// <param name="target">Specifies the target of the operation.</param>
    /// <param name="levels">Specifies the number of levels of detail in the texture.</param>
    /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the texture, in texels.</param>
    public void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) => _glTexStorage1D(target, levels, internalformat, width);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXSTORAGE2DPROC(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
    private PFNGLTEXSTORAGE2DPROC _glTexStorage2D;
    /// <summary>
    /// Specify storage for a two-dimensional texture
    /// </summary>
    /// <param name="target">Specifies the target of the operation.</param>
    /// <param name="levels">Specifies the number of levels of detail in the texture.</param>
    /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the texture, in texels.</param>
    /// <param name="height">Specifies the height of the texture, in texels.</param>
    public void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) => _glTexStorage2D(target, levels, internalformat, width, height);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXSTORAGE3DPROC(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
    private PFNGLTEXSTORAGE3DPROC _glTexStorage3D;
    /// <summary>
    /// Specify storage for a three-dimensional texture
    /// </summary>
    /// <param name="target">Specifies the target of the operation.</param>
    /// <param name="levels">Specifies the number of levels of detail in the texture.</param>
    /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the texture, in texels.</param>
    /// <param name="height">Specifies the height of the texture, in texels.</param>
    /// <param name="depth">Specifies the depth of the texture, in texels.</param>
    public void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) => _glTexStorage3D(target, levels, internalformat, width, height, depth);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC(GLenum mode, GLuint id, GLsizei instancecount);
    private PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC _glDrawTransformFeedbackInstanced;
    /// <summary>
    /// Render primitives from array data previously placed in a transform feedback buffer
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="id">Specifies the name of a transform feedback object from which to retrieve the vertex attributes.</param>
    /// <param name="instancecount">Specifies the number of instances of the specified range of vertices to render.</param>
    public void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount) => _glDrawTransformFeedbackInstanced(mode, id, instancecount);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
    private PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC _glDrawTransformFeedbackStreamInstanced;
    /// <summary>
    /// Render primitives from array data previously placed in a transform feedback buffer
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="id">Specifies the name of a transform feedback object from which to retrieve the vertex attributes.</param>
    /// <param name="stream">Specifies the transform feedback stream from which to retrieve the vertex attributes.</param>
    /// <param name="instancecount">Specifies the number of instances of the specified range of vertices to render.</param>
    public void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount) => _glDrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount);

#endif

    // OpenGL 4.3

#if OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETPOINTERVPROC(GLenum pname, void** @params);
    private PFNGLGETPOINTERVPROC _glGetPointerv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the address of the specified pointer.
    /// </summary>
    /// <param name="pname">Specifies the pointer to be returned. Must be one of <see cref="IGL.GL_DEBUG_CALLBACK_FUNCTION" /> or <see cref="IGL.GL_DEBUG_CALLBACK_USER_PARAM" />.</param>
    /// <param name="params">Returns the address of the specified pointer.</param>
    public void glGetPointerv(GLenum pname, void** @params) => _glGetPointerv(pname, @params);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the address of the specified pointer.
    /// </summary>
    /// <param name="pname">Specifies the pointer to be returned. Must be one of <see cref="IGL.GL_DEBUG_CALLBACK_FUNCTION" /> or <see cref="IGL.GL_DEBUG_CALLBACK_USER_PARAM" />.</param>
    /// <param name="params">A <see langword="ref" /> to an array of <see cref="IntPtr" />s to receive the address of the specified pointer.</param>
    public void glGetPointerv(GLenum pname, ref IntPtr[] @params)
    {
        int length = @params.Length;

        void* ptr = @params[0].ToPointer();
        void** p = &ptr;
        _glGetPointerv(pname, p);

        for (int i = 0; i < length; i++)
        {
            @params[i] = new IntPtr(*p);
            p++;
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARBUFFERDATAPROC(GLenum target, GLenum internalformat, GLenum format, GLenum type, void* data);
    private PFNGLCLEARBUFFERDATAPROC _glClearBufferData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear a buffer object to a specified value.
    /// </summary>
    /// <param name="target">Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER" />, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER" />, <see cref="IGL.GL_COPY_READ_BUFFER" />, <see cref="IGL.GL_COPY_WRITE_BUFFER" />, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER" />, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER" />, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER" />, <see cref="IGL.GL_PIXEL_PACK_BUFFER" />, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER" />, <see cref="IGL.GL_QUERY_BUFFER" />, <see cref="IGL.GL_SHADER_STORAGE_BUFFER" />, <see cref="IGL.GL_TEXTURE_BUFFER" />, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER" />, or <see cref="IGL.GL_UNIFORM_BUFFER" />.</param>
    /// <param name="internalformat">Specifies the internal format of the buffer object.</param>
    /// <param name="format">Specifies the format of the data in the buffer object.</param>
    /// <param name="type">Specifies the data type of the data in the buffer object.</param>
    /// <param name="data">Specifies a pointer to the location where the clear value is stored.</param>
    public void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, void* data) => _glClearBufferData(target, internalformat, format, type, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear a buffer object to a specified value.
    /// </summary>
    /// <typeparam name="T">The type of the data to clear the buffer with.</typeparam>
    /// <param name="target">Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER" />, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER" />, <see cref="IGL.GL_COPY_READ_BUFFER" />, <see cref="IGL.GL_COPY_WRITE_BUFFER" />, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER" />, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER" />, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER" />, <see cref="IGL.GL_PIXEL_PACK_BUFFER" />, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER" />, <see cref="IGL.GL_QUERY_BUFFER" />, <see cref="IGL.GL_SHADER_STORAGE_BUFFER" />, <see cref="IGL.GL_TEXTURE_BUFFER" />, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER" />, or <see cref="IGL.GL_UNIFORM_BUFFER" />.</param>
    /// <param name="internalformat">Specifies the internal format of the buffer object.</param>
    /// <param name="format">Specifies the format of the data in the buffer object.</param>
    /// <param name="type">Specifies the data type of the data in the buffer object.</param>
    /// <param name="data">Specifies the value to clear the buffer with.</param>
    public void glClearBufferData<T>(GLenum target, GLenum internalformat, GLenum format, GLenum type, T[] data) where T : unmanaged { fixed (T* t =
 &data[0]) _glClearBufferData(target, internalformat, format, type, t); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARBUFFERSUBDATAPROC(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, void* data);
    private PFNGLCLEARBUFFERSUBDATAPROC _glClearBufferSubData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear a region within a buffer object to a specified value.
    /// </summary>
    /// <param name="target">Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER" />, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER" />, <see cref="IGL.GL_COPY_READ_BUFFER" />, <see cref="IGL.GL_COPY_WRITE_BUFFER" />, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER" />, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER" />, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER" />, <see cref="IGL.GL_PIXEL_PACK_BUFFER" />, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER" />, <see cref="IGL.GL_QUERY_BUFFER" />, <see cref="IGL.GL_SHADER_STORAGE_BUFFER" />, <see cref="IGL.GL_TEXTURE_BUFFER" />, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER" />, or <see cref="IGL.GL_UNIFORM_BUFFER" />.</param>
    /// <param name="internalformat">Specifies the internal format of the buffer object.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.</param>
    /// <param name="size">Specifies the size in bytes of the region in the buffer object's data store to be cleared.</param>
    /// <param name="format">Specifies the format of the data in the buffer object.</param>
    /// <param name="type">Specifies the data type of the data in the buffer object.</param>
    /// <param name="data">Specifies a pointer to the location where the clear value is stored.</param>
    public void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, void* data) => _glClearBufferSubData(target, internalformat, offset, size, format, type, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear a region within a buffer object to a specified value.
    /// </summary>
    /// <typeparam name="T">The type of the data to clear the buffer with.</typeparam>
    /// <param name="target">Specifies the target buffer object. The symbolic constant must be <see cref="IGL.GL_ARRAY_BUFFER" />, <see cref="IGL.GL_ATOMIC_COUNTER_BUFFER" />, <see cref="IGL.GL_COPY_READ_BUFFER" />, <see cref="IGL.GL_COPY_WRITE_BUFFER" />, <see cref="IGL.GL_DRAW_INDIRECT_BUFFER" />, <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER" />, <see cref="IGL.GL_ELEMENT_ARRAY_BUFFER" />, <see cref="IGL.GL_PIXEL_PACK_BUFFER" />, <see cref="IGL.GL_PIXEL_UNPACK_BUFFER" />, <see cref="IGL.GL_QUERY_BUFFER" />, <see cref="IGL.GL_SHADER_STORAGE_BUFFER" />, <see cref="IGL.GL_TEXTURE_BUFFER" />, <see cref="IGL.GL_TRANSFORM_FEEDBACK_BUFFER" />, or <see cref="IGL.GL_UNIFORM_BUFFER" />.</param>
    /// <param name="internalformat">Specifies the internal format of the buffer object.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.</param>
    /// <param name="size">Specifies the size in bytes of the region in the buffer object's data store to be cleared.</param>
    /// <param name="format">Specifies the format of the data in the buffer object.</param>
    /// <param name="type">Specifies the data type of the data in the buffer object.</param>
    /// <param name="data">Specifies the value to clear the buffer with.</param>
    public void glClearBufferSubData<T>(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, T[] data) where T : unmanaged { fixed (T* t
 = &data[0]) _glClearBufferSubData(target, internalformat, offset, size, format, type, t); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDISPATCHCOMPUTEPROC(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
    private PFNGLDISPATCHCOMPUTEPROC _glDispatchCompute;
    /// <summary>
    /// Launch one or more compute work groups.
    /// </summary>
    /// <param name="num_groups_x">Specify the number of work groups to be launched in the X dimension.</param>
    /// <param name="num_groups_y">Specify the number of work groups to be launched in the Y dimension.</param>
    /// <param name="num_groups_z">Specify the number of work groups to be launched in the Z dimension.</param>
    public void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) => _glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDISPATCHCOMPUTEINDIRECTPROC(void* indirect);
    private PFNGLDISPATCHCOMPUTEINDIRECTPROC _glDispatchComputeIndirect;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Launch one or more compute work groups using parameters stored in a buffer object.
    /// </summary>
    /// <param name="indirect">Specifies the offset into the buffer object bound to the <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER" /> target at which the dispatch parameters are stored.</param>
    public void glDispatchComputeIndirect(void* indirect) => _glDispatchComputeIndirect(indirect);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    public struct DispatchIndirectCommand
    {
        public uint num_groups_x;
        public uint num_groups_y;
        public uint num_groups_z;
    }
    /// <summary>
    /// Launch one or more compute work groups using parameters stored in a buffer object.
    /// </summary>
    /// <param name="indirect">Specifies the offset into the buffer object bound to the <see cref="IGL.GL_DISPATCH_INDIRECT_BUFFER" /> target at which the dispatch parameters are stored.</param>
    public void glDispatchComputeIndirect(DispatchIndirectCommand indirect) => _glDispatchComputeIndirect(&indirect);
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCOPYIMAGESUBDATAPROC(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
    private PFNGLCOPYIMAGESUBDATAPROC _glCopyImageSubData;
    /// <summary>
    /// Copy a region of a source texture object to a region of a destination texture object.
    /// </summary>
    /// <param name="srcName">Specifies the name of a source texture object from which to copy.</param>
    /// <param name="srcTarget">Specifies the target of the source texture object.</param>
    /// <param name="srcLevel">Specifies the level-of-detail number of the source texture object.</param>
    /// <param name="srcX">Specifies the X coordinate of the left edge of the source region to copy.</param>
    /// <param name="srcY">Specifies the Y coordinate of the bottom edge of the source region to copy.</param>
    /// <param name="srcZ">Specifies the Z coordinate of the left edge of the source region to copy.</param>
    /// <param name="dstName">Specifies the name of a destination texture object to which to copy.</param>
    /// <param name="dstTarget">Specifies the target of the destination texture object.</param>
    /// <param name="dstLevel">Specifies the level-of-detail number of the destination texture object.</param>
    /// <param name="dstX">Specifies the X coordinate of the left edge of the destination region.</param>
    /// <param name="dstY">Specifies the Y coordinate of the bottom edge of the destination region.</param>
    /// <param name="dstZ">Specifies the Z coordinate of the left edge of the destination region.</param>
    /// <param name="srcWidth">Specifies the width of the region to be copied.</param>
    /// <param name="srcHeight">Specifies the height of the region to be copied.</param>
    /// <param name="srcDepth">Specifies the depth of the region to be copied.</param>
    public void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) => _glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLFRAMEBUFFERPARAMETERIPROC(GLenum target, GLenum pname, GLint param);
    private PFNGLFRAMEBUFFERPARAMETERIPROC _glFramebufferParameteri;
    /// <summary>
    /// Specify integer framebuffer parameter.
    /// </summary>
    /// <param name="target">Specifies the target of the operation. The symbolic constant must be <see cref="IGL.GL_DRAW_FRAMEBUFFER" />.</param>
    /// <param name="pname">Specifies the parameter to modify.</param>
    /// <param name="param">Specifies the new value for <paramref name="pname" />.</param>
    public void glFramebufferParameteri(GLenum target, GLenum pname, GLint param) => _glFramebufferParameteri(target, pname, param);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETFRAMEBUFFERPARAMETERIVPROC(GLenum target, GLenum pname, GLint* parameters);
    private PFNGLGETFRAMEBUFFERPARAMETERIVPROC _glGetFramebufferParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a framebuffer object target.
    /// </summary>
    /// <param name="target">Specifies the framebuffer target. The symbolic constant must be <see cref="IGL.GL_DRAW_FRAMEBUFFER" />.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="parameters">Specifies the address of a variable to receive the value of <paramref name="pname" />.</param>
    public void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint* parameters) => _glGetFramebufferParameteriv(target, pname, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a framebuffer object target.
    /// </summary>
    /// <param name="target">Specifies the framebuffer target. The symbolic constant must be <see cref="IGL.GL_DRAW_FRAMEBUFFER" />.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="parameters">Specifies the address of a variable to receive the value of <paramref name="pname" />.</param>
    public void glGetFramebufferParameteriv(GLenum target, GLenum pname, ref GLint[] parameters) { fixed (GLint* p_parameters =
 &parameters[0]) _glGetFramebufferParameteriv(target, pname, p_parameters); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETINTERNALFORMATI64VPROC(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64* @params);
    private PFNGLGETINTERNALFORMATI64VPROC _glGetInternalformati64v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a framebuffer object target.
    /// </summary>
    /// <param name="target">Specifies the framebuffer target. The symbolic constant must be <see cref="IGL.GL_DRAW_FRAMEBUFFER" />.</param>
    /// <param name="internalformat">Specifies the internal format whose parameters to query.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="count">Specifies the number of parameters to query.</param>
    /// <param name="params">Specifies the address of a variable to receive the value of <paramref name="pname" />.</param>
    public void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64* @params) => _glGetInternalformati64v(target, internalformat, pname, count, @params);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a framebuffer object target.
    /// </summary>
    /// <param name="target">Specifies the framebuffer target. The symbolic constant must be <see cref="IGL.GL_DRAW_FRAMEBUFFER" />.</param>
    /// <param name="internalformat">Specifies the internal format whose parameters to query.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="count">Specifies the number of parameters to query.</param>
    /// <param name="params">Specifies an array to receive the value of <paramref name="pname" />.</param>
    public void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, ref GLint64[] @params) { fixed (GLint64* p_params
 = &@params[0]) _glGetInternalformati64v(target, internalformat, pname, count, p_params); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLINVALIDATETEXSUBIMAGEPROC(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
    private PFNGLINVALIDATETEXSUBIMAGEPROC _glInvalidateTexSubImage;
    /// <summary>
    /// Invalidate the content of a texture image.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture.</param>
    /// <param name="level">Specifies the level of the texture image.</param>
    /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
    /// <param name="yoffset">Specifies the texel offset within the texture array.</param>
    /// <param name="zoffset">Specifies the texel offset within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>    
    public void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) => _glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLINVALIDATETEXIMAGEPROC(GLuint texture, GLint level);
    private PFNGLINVALIDATETEXIMAGEPROC _glInvalidateTexImage;
    /// <summary>
    /// Invalidate the content of a texture image.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture.</param>
    /// <param name="level">Specifies the level of the texture image.</param>
    public void glInvalidateTexImage(GLuint texture, GLint level) => _glInvalidateTexImage(texture, level);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLINVALIDATEBUFFERSUBDATAPROC(GLuint buffer, GLintptr offset, GLsizeiptr length);
    private PFNGLINVALIDATEBUFFERSUBDATAPROC _glInvalidateBufferSubData;
    /// <summary>
    /// Invalidate the content of a buffer object's data store.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to invalidate.</param>
    /// <param name="offset">Specifies the offset within the buffer of the start of the range to be invalidated.</param>
    /// <param name="length">Specifies the length of the range to be invalidated.</param>
    public void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length) => _glInvalidateBufferSubData(buffer, offset, length);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLINVALIDATEBUFFERDATAPROC(GLuint buffer);
    private PFNGLINVALIDATEBUFFERDATAPROC _glInvalidateBufferData;
    /// <summary>
    /// Invalidate the content of a buffer object's data store.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to invalidate.</param>
    public void glInvalidateBufferData(GLuint buffer) => _glInvalidateBufferData(buffer);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLINVALIDATEFRAMEBUFFERPROC(GLenum target, GLsizei numAttachments, GLenum* attachments);
    private PFNGLINVALIDATEFRAMEBUFFERPROC _glInvalidateFramebuffer;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Invalidate the content of a framebuffer's attachments.
    /// </summary>
    /// <param name="target">Specifies the target of the operation. The symbolic constant must be <see cref="IGL.GL_DRAW_FRAMEBUFFER" />.</param>
    /// <param name="numAttachments">Specifies the number of attachments to invalidate.</param>
    /// <param name="attachments">Specifies an array of attachment points.</param>
    public void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, GLenum* attachments) => _glInvalidateFramebuffer(target, numAttachments, attachments);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Invalidate the content of a framebuffer's attachments.
    /// </summary>
    /// <param name="target">Specifies the target of the operation. The symbolic constant must be <see cref="IGL.GL_DRAW_FRAMEBUFFER" />.</param>
    /// <param name="numAttachments">Specifies the number of attachments to invalidate.</param>
    /// <param name="attachments">Specifies an array of attachment points.</param>
    public void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, GLenum[] attachments) { fixed (GLenum* p_attachments =
 &attachments[0]) _glInvalidateFramebuffer(target, numAttachments, p_attachments); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLINVALIDATESUBFRAMEBUFFERPROC(GLenum target, GLsizei numAttachments, GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
    private PFNGLINVALIDATESUBFRAMEBUFFERPROC _glInvalidateSubFramebuffer;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Invalidate the content of a region of a framebuffer's attachments.
    /// </summary>
    /// <param name="target">Specifies the target of the operation. The symbolic constant must be <see cref="IGL.GL_DRAW_FRAMEBUFFER" />.</param>
    /// <param name="numAttachments">Specifies the number of attachments to invalidate.</param>
    /// <param name="attachments">Specifies an array of attachment points.</param>
    /// <param name="x">Specifies the left pixel coordinate of the region.</param>
    /// <param name="y">Specifies the lower pixel coordinate of the region.</param>
    /// <param name="width">Specifies the width of the region.</param>
    /// <param name="height">Specifies the height of the region.</param>
    public void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height) => _glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Invalidate the content of a region of a framebuffer's attachments.
    /// </summary>
    /// <param name="target">Specifies the target of the operation. The symbolic constant must be <see cref="IGL.GL_DRAW_FRAMEBUFFER" />.</param>
    /// <param name="numAttachments">Specifies the number of attachments to invalidate.</param>
    /// <param name="attachments">Specifies an array of attachment points.</param>
    /// <param name="x">Specifies the left pixel coordinate of the region.</param>
    /// <param name="y">Specifies the lower pixel coordinate of the region.</param>
    /// <param name="width">Specifies the width of the region.</param>
    /// <param name="height">Specifies the height of the region.</param>
    public void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, GLenum[] attachments, GLint x, GLint y, GLsizei width, GLsizei height) { fixed (GLenum* p_attachments
 = &attachments[0]) _glInvalidateSubFramebuffer(target, numAttachments, p_attachments, x, y, width, height); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLMULTIDRAWARRAYSINDIRECTPROC(GLenum mode, void* indirect, GLsizei drawcount, GLsizei stride);
    private PFNGLMULTIDRAWARRAYSINDIRECTPROC _glMultiDrawArraysIndirect;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render multiple sets of primitives from array data, taking parameters from memory.
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="indirect">Specifies the address of an array of structures containing the draw parameters.</param>
    /// <param name="drawcount">Specifies the number of elements in the array of draw parameter structures.</param>
    /// <param name="stride">Specifies the distance in basic machine units between elements of the draw parameter array.</param>
    public void glMultiDrawArraysIndirect(GLenum mode, void* indirect, GLsizei drawcount, GLsizei stride) => _glMultiDrawArraysIndirect(mode, indirect, drawcount, stride);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render multiple sets of primitives from array data, taking parameters from memory.
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="indirect">Specifies the address of an array of structures containing the draw parameters.</param>
    /// <param name="drawcount">Specifies the number of elements in the array of draw parameter structures.</param>
    /// <param name="stride">Specifies the distance in basic machine units between elements of the draw parameter array.</param>
    public void glMultiDrawArraysIndirect(GLenum mode, DrawArraysIndirectCommand indirect, GLsizei drawcount, GLsizei stride) => _glMultiDrawArraysIndirect(mode, (void*)&indirect, drawcount, stride);
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLMULTIDRAWELEMENTSINDIRECTPROC(GLenum mode, GLenum type, void* indirect, GLsizei drawcount, GLsizei stride);
    private PFNGLMULTIDRAWELEMENTSINDIRECTPROC _glMultiDrawElementsIndirect;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render multiple sets of primitives by specifying indices of array data elements.
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="type">Specifies the type of the values in <paramref name="indirect" />.</param>
    /// <param name="indirect">Specifies the address of an array of structures containing the draw parameters.</param>
    /// <param name="drawcount">Specifies the number of elements in the array of draw parameter structures.</param>
    /// <param name="stride">Specifies the distance in basic machine units between elements of the draw parameter array.</param>
    public void glMultiDrawElementsIndirect(GLenum mode, GLenum type, void* indirect, GLsizei drawcount, GLsizei stride) => _glMultiDrawElementsIndirect(mode, type, indirect, drawcount, stride);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render multiple sets of primitives by specifying indices of array data elements.
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="type">Specifies the type of the values in <paramref name="indirect" />.</param>
    /// <param name="indirect">Specifies the address of an array of structures containing the draw parameters.</param>
    /// <param name="drawcount">Specifies the number of elements in the array of draw parameter structures.</param>
    /// <param name="stride">Specifies the distance in basic machine units between elements of the draw parameter array.</param>
    public void glMultiDrawElementsIndirect(GLenum mode, GLenum type, DrawElementsIndirectCommand indirect, GLsizei drawcount, GLsizei stride) => _glMultiDrawElementsIndirect(mode, type, (void*)&indirect, drawcount, stride);
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETPROGRAMINTERFACEIVPROC(GLuint program, GLenum programInterface, GLenum pname, GLint* parameters);
    private PFNGLGETPROGRAMINTERFACEIVPROC _glGetProgramInterfaceiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve properties of an interface in a program object.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose properties to query.</param>
    /// <param name="programInterface">Specifies the interface within program to query.</param>
    /// <param name="pname">Specifies the name of the parameter to query.</param>
    /// <param name="parameters">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint* parameters) => _glGetProgramInterfaceiv(program, programInterface, pname, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve properties of an interface in a program object.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose properties to query.</param>
    /// <param name="programInterface">Specifies the interface within program to query.</param>
    /// <param name="pname">Specifies the name of the parameter to query.</param>
    /// <param name="parameters">Specifies an array to receive the value of the queried parameter.</param>
    public void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, ref GLint[] parameters) { fixed (GLint* p_parameters =
 &parameters[0]) _glGetProgramInterfaceiv(program, programInterface, pname, p_parameters); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLuint PFNGLGETPROGRAMRESOURCEINDEXPROC(GLuint program, GLenum programInterface, GLchar* name);
    private PFNGLGETPROGRAMRESOURCEINDEXPROC _glGetProgramResourceIndex;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the index of a named resource within a program.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose resource to query.</param>
    /// <param name="programInterface">Specifies the interface within program that contains the named resource.</param>
    /// <param name="name">Specifies the name of the resource whose index to retrieve.</param>
    /// <returns>The index of the named resource within the specified program interface.</returns>
    public GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, GLchar* name) => _glGetProgramResourceIndex(program, programInterface, name);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the index of a named resource within a program.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose resource to query.</param>
    /// <param name="programInterface">Specifies the interface within program that contains the named resource.</param>
    /// <param name="name">Specifies the name of the resource whose index to retrieve.</param>
    /// <returns>The index of the named resource within the specified program interface.</returns>
    public GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, string name)
    {
        GLchar[] nameBytes = Encoding.UTF8.GetBytes(name);
        fixed (GLchar* p_name = &nameBytes[0])
        {
            return _glGetProgramResourceIndex(program, programInterface, p_name);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETPROGRAMRESOURCENAMEPROC(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name);
    private PFNGLGETPROGRAMRESOURCENAMEPROC _glGetProgramResourceName;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the name string of a named resource within a program.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose resource to query.</param>
    /// <param name="programInterface">Specifies the interface within program that contains the named resource.</param>
    /// <param name="index">Specifies the index of the named resource within the specified program interface.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given by <paramref name="name" />.</param>
    /// <param name="length">Specifies the address of a variable to receive the number of characters that were or would have been written to the buffer addressed by <paramref name="name" />.</param>
    /// <param name="name">Specifies the address of a buffer into which to place the name string of the named resource.</param>
    public void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name) => _glGetProgramResourceName(program, programInterface, index, bufSize, length, name);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the name string of a named resource within a program.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose resource to query.</param>
    /// <param name="programInterface">Specifies the interface within program that contains the named resource.</param>
    /// <param name="index">Specifies the index of the named resource within the specified program interface.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given by <paramref name="name" />.</param>
    /// <returns>The name string of the named resource.</returns>
    public string glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize)
    {
        GLchar[] name = new GLchar[bufSize];
        GLsizei length;
        fixed (GLchar* p_name = &name[0])
        {
            _glGetProgramResourceName(program, programInterface, index, bufSize, &length, p_name);
            return new string((sbyte*)p_name, 0, length, Encoding.UTF8);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETPROGRAMRESOURCEIVPROC(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, GLenum* props, GLsizei bufSize, GLsizei* length, GLint* @params);
    private PFNGLGETPROGRAMRESOURCEIVPROC _glGetProgramResourceiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve properties of an active resource within a program object.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose resource to query.</param>
    /// <param name="programInterface">Specifies the interface within program that contains the named resource.</param>
    /// <param name="index">Specifies the index of the named resource within the specified program interface.</param>
    /// <param name="propCount">Specifies the number of properties being queried.</param>
    /// <param name="props">Specifies an array of properties to query.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given by <paramref name="length" />.</param>
    /// <param name="length">Specifies the address of a variable to receive the number of integers placed in <paramref name="params" />.</param>
    /// <param name="params">Specifies the address of an array into which to place the returned data.</param>
    public void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, GLenum* props, GLsizei bufSize, GLsizei* length, GLint* @params) => _glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, @params);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve properties of an active resource within a program object.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose resource to query.</param>
    /// <param name="programInterface">Specifies the interface within program that contains the named resource.</param>
    /// <param name="index">Specifies the index of the named resource within the specified program interface.</param>
    /// <param name="props">Specifies an array of properties to query.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given by <paramref name="length" />.</param>
    /// <param name="length">Specifies the address of a variable to receive the number of integers placed in <paramref name="params" />.</param>
    public void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLenum[] props, GLsizei bufSize, ref GLint[] @params)
    {
        fixed (GLenum* p_props = &props[0])
        fixed (GLint* p_params = &@params[0])
        {
            GLsizei length;
            _glGetProgramResourceiv(program, programInterface, index, props.Length, p_props, bufSize, &length, p_params);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLint PFNGLGETPROGRAMRESOURCELOCATIONPROC(GLuint program, GLenum programInterface, GLchar* name);
    private PFNGLGETPROGRAMRESOURCELOCATIONPROC _glGetProgramResourceLocation;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the location of a named resource within a program.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose resource to query.</param>
    /// <param name="programInterface">Specifies the interface within program that contains the named resource.</param>
    /// <param name="name">Specifies the name of the resource whose index to query.</param>
    /// <returns>The location of the named resource.</returns>
    public GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, GLchar* name) => _glGetProgramResourceLocation(program, programInterface, name);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the location of a named resource within a program.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose resource to query.</param>
    /// <param name="programInterface">Specifies the interface within program that contains the named resource.</param>
    /// <param name="name">Specifies the name of the resource whose index to query.</param>
    /// <returns>The location of the named resource.</returns>
    public GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, string name)
    {
        GLchar[] nameBytes = Encoding.UTF8.GetBytes(name);
        fixed (GLchar* p_name = &nameBytes[0])
        {
            return _glGetProgramResourceLocation(program, programInterface, p_name);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLint PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC(GLuint program, GLenum programInterface, GLchar* name);
    private PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC _glGetProgramResourceLocationIndex;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the index of a named resource within a program.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose resource to query.</param>
    /// <param name="programInterface">Specifies the interface within program that contains the named resource.</param>
    /// <param name="name">Specifies the name of the resource whose index to query.</param>
    /// <returns>The index of the named resource.</returns>
    public GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, GLchar* name) => _glGetProgramResourceLocationIndex(program, programInterface, name);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the index of a named resource within a program.
    /// </summary>
    /// <param name="program">Specifies the name of a program object whose resource to query.</param>
    /// <param name="programInterface">Specifies the interface within program that contains the named resource.</param>
    /// <param name="name">Specifies the name of the resource whose index to query.</param>
    /// <returns>The index of the named resource.</returns>
    public GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, string name)
    {
        GLchar[] nameBytes = Encoding.UTF8.GetBytes(name);
        fixed (GLchar* p_name = &nameBytes[0])
        {
            return _glGetProgramResourceLocationIndex(program, programInterface, p_name);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLSHADERSTORAGEBLOCKBINDINGPROC(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
    private PFNGLSHADERSTORAGEBLOCKBINDINGPROC _glShaderStorageBlockBinding;
    /// <summary>
    /// Bind a shader storage block to an indexed shader storage interface.
    /// </summary>
    /// <param name="program">Specifies the name of a program object containing the active shader storage block whose binding to assign.</param>
    /// <param name="storageBlockIndex">Specifies the index of the shader storage block within program whose binding to assign.</param>
    /// <param name="storageBlockBinding">Specifies the binding point to which to bind the shader storage block with index <paramref name="storageBlockIndex" /> within program.</param>
    public void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) => _glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXBUFFERRANGEPROC(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
    private PFNGLTEXBUFFERRANGEPROC _glTexBufferRange;
    /// <summary>
    /// Bind a range of a buffer's data store to a texture.
    /// </summary>
    /// <param name="target">Specifies the target to which to bind the texture.</param>
    /// <param name="internalformat">Specifies the internal format of the data in the store belonging to buffer.</param>
    /// <param name="buffer">Specifies the name of the buffer object whose storage to attach to the active buffer texture.</param>
    /// <param name="offset">Specifies the offset of the start of the range of the buffer's data store to attach.</param>
    /// <param name="size">Specifies the size of the range of the buffer's data store to attach.</param>
    public void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) => _glTexBufferRange(target, internalformat, buffer, offset, size);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXSTORAGE2DMULTISAMPLEPROC(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
    private PFNGLTEXSTORAGE2DMULTISAMPLEPROC _glTexStorage2DMultisample;
    /// <summary>
    /// Establish the data storage, format, dimensions, and number of samples of a multisample texture's image.
    /// </summary>
    /// <param name="target">Specifies the target of the operation.</param>
    /// <param name="samples">Specifies the number of samples in the multisample texture's image.</param>
    /// <param name="internalformat">Specifies the internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the multisample texture's image, in texels.</param>
    /// <param name="height">Specifies the height of the multisample texture's image, in texels.</param>
    /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</param>
    public void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) => _glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXSTORAGE3DMULTISAMPLEPROC(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
    private PFNGLTEXSTORAGE3DMULTISAMPLEPROC _glTexStorage3DMultisample;
    /// <summary>
    /// Establish the data storage, format, dimensions, and number of samples of a multisample texture's image.
    /// </summary>
    /// <param name="target">Specifies the target of the operation.</param>
    /// <param name="samples">Specifies the number of samples in the multisample texture's image.</param>
    /// <param name="internalformat">Specifies the internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the multisample texture's image, in texels.</param>
    /// <param name="height">Specifies the height of the multisample texture's image, in texels.</param>
    /// <param name="depth">Specifies the depth of the multisample texture's image, in layers.</param>
    /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</param>
    public void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) => _glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTUREVIEWPROC(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
    private PFNGLTEXTUREVIEWPROC _glTextureView;
    /// <summary>
    /// Create a texture view.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to create a view of.</param>
    /// <param name="target">Specifies the target of the texture object to create a view of.</param>
    /// <param name="origtexture">Specifies the name of a texture object that <paramref name="texture" /> is to share storage with.</param>
    /// <param name="internalformat">Specifies the internal format to use for the view's image.</param>
    /// <param name="minlevel">Specifies the lowest level of detail of the view's image.</param>
    /// <param name="numlevels">Specifies the number of levels of detail to include in the view's image.</param>
    /// <param name="minlayer">Specifies the index of the first layer to include in the view's image.</param>
    /// <param name="numlayers">Specifies the number of layers to include in the view's image.</param>
    public void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) => _glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDVERTEXBUFFERPROC(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
    private PFNGLBINDVERTEXBUFFERPROC _glBindVertexBuffer;
    /// <summary>
    /// Bind a buffer to a vertex buffer bind point.
    /// </summary>
    /// <param name="bindingindex">Specifies the index of the vertex buffer binding point to which to bind the buffer.</param>
    /// <param name="buffer">Specifies the name of the buffer object to bind to the vertex buffer binding point.</param>
    /// <param name="offset">Specifies the offset of the first element of the buffer bound to the vertex buffer binding point.</param>
    /// <param name="stride">Specifies the distance between elements within the buffer.</param>
    public void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) => _glBindVertexBuffer(bindingindex, buffer, offset, stride);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBFORMATPROC(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
    private PFNGLVERTEXATTRIBFORMATPROC _glVertexAttribFormat;
    /// <summary>
    /// Specify the organization of vertex arrays.
    /// </summary>
    /// <param name="attribindex">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.</param>
    /// <param name="type">Specifies the type of data stored in the array.</param>
    /// <param name="normalized">Specifies whether fixed-point data values should be normalized (<see langword="true"/>) or converted directly as fixed-point values (<see langword="false"/>) when they are accessed.</param>
    /// <param name="relativeoffset">Specifies the offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the <see cref="IGL.GL_ARRAY_BUFFER"/> target. The initial value is 0.</param>
    public void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) => _glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBIFORMATPROC(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
    private PFNGLVERTEXATTRIBIFORMATPROC _glVertexAttribIFormat;
    /// <summary>
    /// Specify the organization of vertex arrays.
    /// </summary>
    /// <param name="attribindex">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.</param>
    /// <param name="type">Specifies the type of data stored in the array.</param>
    /// <param name="relativeoffset">Specifies the offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the <see cref="IGL.GL_ARRAY_BUFFER"/> target. The initial value is 0.</param>
    public void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) => _glVertexAttribIFormat(attribindex, size, type, relativeoffset);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBLFORMATPROC(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
    private PFNGLVERTEXATTRIBLFORMATPROC _glVertexAttribLFormat;
    /// <summary>
    /// Specify the organization of vertex arrays.
    /// </summary>
    /// <param name="attribindex">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.</param>
    /// <param name="type">Specifies the type of data stored in the array.</param>
    /// <param name="relativeoffset">Specifies the offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the <see cref="IGL.GL_ARRAY_BUFFER"/> target. The initial value is 0.</param>
    public void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) => _glVertexAttribLFormat(attribindex, size, type, relativeoffset);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXATTRIBBINDINGPROC(GLuint attribindex, GLuint bindingindex);
    private PFNGLVERTEXATTRIBBINDINGPROC _glVertexAttribBinding;
    /// <summary>
    /// Bind a generic vertex attribute to a buffer binding.
    /// </summary>
    /// <param name="attribindex">Specifies the index of the generic vertex attribute to be bound.</param>
    /// <param name="bindingindex">Specifies the index of the binding whose bound buffer object is to be used for attribute array.</param>
    public void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex) => _glVertexAttribBinding(attribindex, bindingindex);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXBINDINGDIVISORPROC(GLuint bindingindex, GLuint divisor);
    private PFNGLVERTEXBINDINGDIVISORPROC _glVertexBindingDivisor;
    /// <summary>
    /// Modify the rate at which generic vertex attributes advance during instanced rendering.
    /// </summary>
    /// <param name="bindingindex">Specifies the index of the vertex buffer binding whose divisor to modify.</param>
    /// <param name="divisor">Specifies the new value for the instance step rate.</param>
    public void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor) => _glVertexBindingDivisor(bindingindex, divisor);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDEBUGMESSAGECONTROLPROC(GLenum source, GLenum type, GLenum severity, GLsizei count, GLuint* ids, GLboolean enabled);
    private PFNGLDEBUGMESSAGECONTROLPROC _glDebugMessageControl;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Control the reporting of debug messages.
    /// </summary>
    /// <param name="source">Specifies the source of debug messages to enable or disable.</param>
    /// <param name="type">Specifies the type of debug messages to enable or disable.</param>
    /// <param name="severity">Specifies the severity of debug messages to enable or disable.</param>
    /// <param name="count">Specifies the length of the array ids.</param>
    /// <param name="ids">Specifies an array containing the ids of the messages to enable or disable.</param>
    /// <param name="enabled">Specifies whether the selected debug messages are enabled or disabled.</param>
    public void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, GLuint* ids, GLboolean enabled) => _glDebugMessageControl(source, type, severity, count, ids, enabled);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Control the reporting of debug messages.
    /// </summary>
    /// <param name="source">Specifies the source of debug messages to enable or disable.</param>
    /// <param name="type">Specifies the type of debug messages to enable or disable.</param>
    /// <param name="severity">Specifies the severity of debug messages to enable or disable.</param>
    /// <param name="ids">Specifies an array containing the ids of the messages to enable or disable.</param>
    /// <param name="enabled">Specifies whether the selected debug messages are enabled or disabled.</param>
    public void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLuint[] ids, GLboolean enabled) { fixed (GLuint* p_ids =
 ids) { _glDebugMessageControl(source, type, severity, ids.Length, p_ids, enabled); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDEBUGMESSAGEINSERTPROC(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, GLchar* buf);
    private PFNGLDEBUGMESSAGEINSERTPROC _glDebugMessageInsert;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Inject an application-supplied message into the debug message queue.
    /// </summary>
    /// <param name="source">Specifies the source of the debug message.</param>
    /// <param name="type">Specifies the type of the debug message.</param>
    /// <param name="id">Specifies the user-supplied identifier of the message to be inserted.</param>
    /// <param name="severity">Specifies the severity of the debug message.</param>
    /// <param name="length">Specifies the length of the character string whose address is given in <paramref name="buf"/>.</param>
    /// <param name="buf">Specifies an array containing the message to be inserted.</param>
    public void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, GLchar* buf) => _glDebugMessageInsert(source, type, id, severity, length, buf);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Inject an application-supplied message into the debug message queue.
    /// </summary>
    /// <param name="source">Specifies the source of the debug message.</param>
    /// <param name="type">Specifies the type of the debug message.</param>
    /// <param name="id">Specifies the user-supplied identifier of the message to be inserted.</param>
    /// <param name="severity">Specifies the severity of the debug message.</param>
    /// <param name="buf">Specifies the message to be inserted.</param>
    public void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, string buf)
    {
        GLchar[] bufBytes = Encoding.UTF8.GetBytes(buf);
        fixed (GLchar* p_bufBytes = bufBytes) { _glDebugMessageInsert(source, type, id, severity, bufBytes.Length, p_bufBytes); }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GLDEBUGPROC(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, GLchar* message, void* userParam);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDEBUGMESSAGECALLBACKPROC(GLDEBUGPROC callback, void* userParam);
    private PFNGLDEBUGMESSAGECALLBACKPROC _glDebugMessageCallback;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a callback to receive debugging messages from the GL.
    /// </summary>
    /// <param name="callback">Specifies the callback function that will be called when a debug message is generated.</param>
    /// <param name="userParam">Specifies a user-defined value that will be passed to the callback function when it is called.</param>
    public void glDebugMessageCallback(GLDEBUGPROC callback, void* userParam) => _glDebugMessageCallback(callback, userParam);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    public delegate void GLDEBUGPROCSAFE(GLenum source, GLenum type, GLuint id, GLenum severity, string message, void* userParam);
    /// <summary>
    /// Specify a callback to receive debugging messages from the GL.
    /// </summary>
    /// <param name="callback">Specifies the callback function that will be called when a debug message is generated.</param>
    /// <param name="userParam">Specifies a user-defined value that will be passed to the callback function when it is called.</param>
    public void glDebugMessageCallback(GLDEBUGPROCSAFE callback, void* userParam)
    {
        GLDEBUGPROC callbackUnsafe = (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, GLchar* message, void* userParam) =>
        {
            string messageString = new string((sbyte*)message, 0, length, Encoding.UTF8);
            callback(source, type, id, severity, messageString, userParam);
        };
        _glDebugMessageCallback(callbackUnsafe, userParam);
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLuint PFNGLGETDEBUGMESSAGELOGPROC(GLuint count, GLsizei bufsize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
    private PFNGLGETDEBUGMESSAGELOGPROC _glGetDebugMessageLog;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve messages from the debug message log.
    /// </summary>
    /// <param name="count">Specifies the number of debug messages to retrieve from the log.</param>
    /// <param name="bufsize">Specifies the size of the buffer whose address is given in <paramref name="messageLog"/>.</param>
    /// <param name="sources">Specifies an array into which the sources of the retrieved messages will be written.</param>
    /// <param name="types">Specifies an array into which the types of the retrieved messages will be written.</param>
    /// <param name="ids">Specifies an array into which the ids of the retrieved messages will be written.</param>
    /// <param name="severities">Specifies an array into which the severities of the retrieved messages will be written.</param>
    /// <param name="lengths">Specifies an array into which the lengths of the received messages will be written.</param>
    /// <param name="messageLog">Specifies an array into which the messages will be written.</param>
    public GLuint glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) => _glGetDebugMessageLog(count, bufsize, sources, types, ids, severities, lengths, messageLog);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve messages from the debug message log.
    /// </summary>
    /// <param name="count">Specifies the number of debug messages to retrieve from the log.</param>
    /// <param name="bufsize">Specifies the size of the buffer whose address is given in <paramref name="messageLog"/>.</param>
    /// <param name="sources">Specifies an array into which the sources of the retrieved messages will be written.</param>
    /// <param name="types">Specifies an array into which the types of the retrieved messages will be written.</param>
    /// <param name="ids">Specifies an array into which the ids of the retrieved messages will be written.</param>
    /// <param name="severities">Specifies an array into which the severities of the retrieved messages will be written.</param>
    /// <param name="messageLog">Specifies an array into which the messages will be written.</param>
    public GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, out GLenum[] sources, out GLenum[] types, out GLuint[] ids, out GLenum[] severities, out string[] messageLog)
    {
        sources = new GLenum[count];
        types = new GLenum[count];
        ids = new GLuint[count];
        severities = new GLenum[count];

        GLchar[] messageLogBytes = new GLchar[bufSize];
        GLsizei[] lengths = new GLsizei[count];
        fixed (GLenum* p_sources = &sources[0])
        fixed (GLenum* p_types = &types[0])
        fixed (GLuint* p_ids = &ids[0])
        fixed (GLenum* p_severities = &severities[0])
        fixed (GLsizei* p_lengths = &lengths[0])
        fixed (GLchar* p_messageLogBytes = &messageLogBytes[0])
        {
            GLchar* pstart = p_messageLogBytes;
            GLuint ret = _glGetDebugMessageLog(count, bufSize, p_sources, p_types, p_ids, p_severities, p_lengths, p_messageLogBytes);
            messageLog = new string[count];
            for (int i = 0; i < count; i++)
            {
                messageLog[i] = new string((sbyte*)pstart, 0, lengths[i], Encoding.UTF8);
                pstart += lengths[i];
            }

            Array.Resize(ref sources, (int)ret);
            Array.Resize(ref types, (int)ret);
            Array.Resize(ref ids, (int)ret);
            Array.Resize(ref severities, (int)ret);
            Array.Resize(ref messageLog, (int)ret);

            return ret;
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPUSHDEBUGGROUPPROC(GLenum source, GLuint id, GLsizei length, GLchar* message);
    private PFNGLPUSHDEBUGGROUPPROC _glPushDebugGroup;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Push a named debug group into the debug message group stack.
    /// </summary>
    /// <param name="source">Specifies the source of the debug message.</param>
    /// <param name="id">Specifies the user-supplied identifier of the message group.</param>
    /// <param name="length">Specifies the length of the message.</param>
    /// <param name="message">Specifies a string containing the message.</param>
    public void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, GLchar* message) => _glPushDebugGroup(source, id, length, message);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Push a named debug group into the debug message group stack.
    /// </summary>
    /// <param name="source">Specifies the source of the debug message.</param>
    /// <param name="id">Specifies the user-supplied identifier of the message group.</param>
    /// <param name="message">Specifies a string containing the message.</param>
    public void glPushDebugGroup(GLenum source, GLuint id, string message)
    {
        GLchar[] messageBytes = Encoding.UTF8.GetBytes(message);
        fixed (GLchar* p_messageBytes = messageBytes) { _glPushDebugGroup(source, id, messageBytes.Length, p_messageBytes); }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPOPDEBUGGROUPPROC();
    private PFNGLPOPDEBUGGROUPPROC _glPopDebugGroup;
    /// <summary>
    /// Pop the active debug group.
    /// </summary>
    public void glPopDebugGroup() => _glPopDebugGroup();

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLOBJECTLABELPROC(GLenum identifier, GLuint name, GLsizei length, GLchar* label);
    private PFNGLOBJECTLABELPROC _glObjectLabel;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set the label of an object.
    /// </summary>
    /// <param name="identifier">Specifies the type of object whose label to set.</param>
    /// <param name="name">Specifies the name of the object whose label to set.</param>
    /// <param name="length">Specifies the length of the label to be used for the object.</param>
    /// <param name="label">Specifies a string containing the label to assign to the object.</param>
    public void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, GLchar* label) => _glObjectLabel(identifier, name, length, label);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set the label of an object.
    /// </summary>
    /// <param name="identifier">Specifies the type of object whose label to set.</param>
    /// <param name="name">Specifies the name of the object whose label to set.</param>
    /// <param name="label">Specifies a string containing the label to assign to the object.</param>
    public void glObjectLabel(GLenum identifier, GLuint name, string label)
    {
        GLchar[] labelBytes = Encoding.UTF8.GetBytes(label);
        fixed (GLchar* p_labelBytes = labelBytes) { _glObjectLabel(identifier, name, labelBytes.Length, p_labelBytes); }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETOBJECTLABELPROC(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label);
    private PFNGLGETOBJECTLABELPROC _glGetObjectLabel;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the label of an object.
    /// </summary>
    /// <param name="identifier">Specifies the type of object whose label to retrieve.</param>
    /// <param name="name">Specifies the name of the object whose label to retrieve.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is in label.</param>
    /// <param name="length">Specifies the address of a variable to receive the length of the object label.</param>
    /// <param name="label">Specifies the address of a buffer into which to place the object label.</param>
    public void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label) => _glGetObjectLabel(identifier, name, bufSize, length, label);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the label of an object.
    /// </summary>
    /// <param name="identifier">Specifies the type of object whose label to retrieve.</param>
    /// <param name="name">Specifies the name of the object whose label to retrieve.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is in label.</param>
    /// <returns>The object label.</returns>
    public string glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize)
    {
        GLchar[] labelBytes = new GLchar[bufSize];
        GLsizei length;
        fixed (GLchar* p_labelBytes = labelBytes)
        {
            _glGetObjectLabel(identifier, name, bufSize, &length, p_labelBytes);
            return new string((sbyte*)p_labelBytes, 0, length, Encoding.UTF8);
        }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLOBJECTPTRLABELPROC(void* ptr, GLsizei length, GLchar* label);
    private PFNGLOBJECTPTRLABELPROC _glObjectPtrLabel;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set the label of an object pointer.
    /// </summary>
    /// <param name="ptr">Specifies the object pointer whose label to set.</param>
    /// <param name="length">Specifies the length of the label to be used for the object.</param>
    /// <param name="label">Specifies a string containing the label to assign to the object.</param>
    public void glObjectPtrLabel(void* ptr, GLsizei length, GLchar* label) => _glObjectPtrLabel(ptr, length, label);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set the label of an object pointer.
    /// </summary>
    /// <param name="ptr">Specifies the object pointer whose label to set.</param>
    /// <param name="label">Specifies a string containing the label to assign to the object.</param>
    public void glObjectPtrLabel(IntPtr ptr, string label)
    {
        GLchar[] labelBytes = Encoding.UTF8.GetBytes(label);
        fixed (GLchar* p_labelBytes = labelBytes) { _glObjectPtrLabel(ptr.ToPointer(), labelBytes.Length, p_labelBytes); }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETOBJECTPTRLABELPROC(void* ptr, GLsizei bufSize, GLsizei* length, GLchar* label);
    private PFNGLGETOBJECTPTRLABELPROC _glGetObjectPtrLabel;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Retrieve the label of an object pointer.
    /// </summary>
    /// <param name="ptr">Specifies the object pointer whose label to retrieve.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is in label.</param>
    /// <param name="length">Specifies the address of a variable to receive the length of the object label.</param>
    /// <param name="label">Specifies the address of a buffer into which to place the object label.</param>
    public void glGetObjectPtrLabel(void* ptr, GLsizei bufSize, GLsizei* length, GLchar* label) => _glGetObjectPtrLabel(ptr, bufSize, length, label);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Retrieve the label of an object pointer.
    /// </summary>
    /// <param name="ptr">Specifies the object pointer whose label to retrieve.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is in label.</param>
    /// <returns>The object label.</returns>
    public string glGetObjectPtrLabel(IntPtr ptr, GLsizei bufSize)
    {
        GLchar[] labelBytes = new GLchar[bufSize];
        GLsizei length;
        fixed (GLchar* p_labelBytes = labelBytes)
        {
            _glGetObjectPtrLabel(ptr.ToPointer(), bufSize, &length, p_labelBytes);
            return new string((sbyte*)p_labelBytes, 0, length, Encoding.UTF8);
        }
    }
#endif

#endif

    // OpenGL 4.4

#if OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBUFFERSTORAGEPROC(GLenum target, GLsizeiptr size, void* data, GLbitfield flags);
    private PFNGLBUFFERSTORAGEPROC _glBufferStorage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Create and initialize a buffer object's data store.
    /// </summary>
    /// <param name="target">Specifies the target to which the buffer object is bound.</param>
    /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
    /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
    /// <param name="flags">Specifies flags indicating the intended usage of the buffer object's data store.</param>
    public void glBufferStorage(GLenum target, GLsizeiptr size, void* data, GLbitfield flags) => _glBufferStorage(target, size, data, flags);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Create and initialize a buffer object's data store.
    /// </summary>
    /// <typeparam name="T">The type of the data to be copied into the data store.</typeparam>
    /// <param name="target">Specifies the target to which the buffer object is bound.</param>
    /// <param name="data">Specifies data that will be copied into the data store for initialization.</param>
    /// <param name="flags">Specifies flags indicating the intended usage of the buffer object's data store.</param>
    public void glBufferStorage<T>(GLenum target, T[] data, GLbitfield flags) where T : unmanaged { fixed (void* p_data =
 &data[0]) { _glBufferStorage(target, data.Length * sizeof(T), p_data, flags); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARTEXIMAGEPROC(GLuint texture, GLint level, GLenum format, GLenum type, void* data);
    private PFNGLCLEARTEXIMAGEPROC _glClearTexImage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear image in a texture.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="data">Specifies a pointer to the image data in memory.</param>
    public void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, void* data) => _glClearTexImage(texture, level, format, type, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear image in a texture.
    /// </summary>
    /// <typeparam name="T">The type of the data to be copied into the data store.</typeparam>
    /// <param name="texture">Specifies the name of the texture.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="data">Specifies the image data.</param>
    public void glClearTexImage<T>(GLuint texture, GLint level, GLenum format, GLenum type, T[] data) where T : unmanaged { fixed (T* t =
 &data[0]) _glClearTexImage(texture, level, format, type, t); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARTEXSUBIMAGEPROC(GLuint texture, GLint level, GLint xOffset, GLint yOffset, GLint zOffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* data);
    private PFNGLCLEARTEXSUBIMAGEPROC _glClearTexSubImage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear a region of a texture image.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xOffset">Specifies the x coordinate of the texel offset within the texture array.</param>
    /// <param name="yOffset">Specifies the y coordinate of the texel offset within the texture array.</param>
    /// <param name="zOffset">Specifies the z coordinate of the texel offset within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="data">Specifies a pointer to the image data in memory.</param>
    public void glClearTexSubImage(GLuint texture, GLint level, GLint xOffset, GLint yOffset, GLint zOffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* data) => _glClearTexSubImage(texture, level, xOffset, yOffset, zOffset, width, height, depth, format, type, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear a region of a texture image.
    /// </summary>
    /// <typeparam name="T">The type of the data to be copied into the data store.</typeparam>
    /// <param name="texture">Specifies the name of the texture.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xOffset">Specifies the x coordinate of the texel offset within the texture array.</param>
    /// <param name="yOffset">Specifies the y coordinate of the texel offset within the texture array.</param>
    /// <param name="zOffset">Specifies the z coordinate of the texel offset within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="data">Specifies the image data.</param>
    public void glClearTexSubImage<T>(GLuint texture, GLint level, GLint xOffset, GLint yOffset, GLint zOffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, T[] data) where T : unmanaged { fixed (T* t
 = &data[0]) _glClearTexSubImage(texture, level, xOffset, yOffset, zOffset, width, height, depth, format, type, t); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDBUFFERSBASEPROC(GLenum target, GLuint first, GLsizei count, GLuint* buffers);
    private PFNGLBINDBUFFERSBASEPROC _glBindBuffersBase;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Bind a range of buffer objects to a binding point.
    /// </summary>
    /// <param name="target">Specifies the target to which the buffers are bound.</param>
    /// <param name="first">Specifies the index of the first binding point to which to bind buffers.</param>
    /// <param name="count">Specifies the number of buffers to bind.</param>
    /// <param name="buffers">Specifies an array of buffer objects whose names to bind.</param>
    public void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, GLuint* buffers) => _glBindBuffersBase(target, first, count, buffers);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Bind a range of buffer objects to a binding point.
    /// </summary>
    /// <param name="target">Specifies the target to which the buffers are bound.</param>
    /// <param name="first">Specifies the index of the first binding point to which to bind buffers.</param>
    /// <param name="buffers">Specifies an array of buffer objects whose names to bind.</param>
    public void glBindBuffersBase(GLenum target, GLuint first, GLuint[] buffers) { fixed (GLuint* p_buffers =
 &buffers[0]) { _glBindBuffersBase(target, first, buffers.Length, p_buffers); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDBUFFERSRANGEPROC(GLenum target, GLuint first, GLsizei count, GLuint* buffers, GLintptr* offsets, GLsizeiptr* sizes);
    private PFNGLBINDBUFFERSRANGEPROC _glBindBuffersRange;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Bind a range of buffer objects to a binding point.
    /// </summary>
    /// <param name="target">Specifies the target to which the buffers are bound.</param>
    /// <param name="first">Specifies the index of the first binding point to which to bind buffers.</param>
    /// <param name="count">Specifies the number of buffers to bind.</param>
    /// <param name="buffers">Specifies an array of buffer objects whose names to bind.</param>
    /// <param name="offsets">Specifies an array of offsets into the buffer objects.</param>
    /// <param name="sizes">Specifies an array of sizes of the buffer object regions.</param>
    public void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, GLuint* buffers, GLintptr* offsets, GLsizeiptr* sizes) => _glBindBuffersRange(target, first, count, buffers, offsets, sizes);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Bind a range of buffer objects to a binding point.
    /// </summary>
    /// <param name="target">Specifies the target to which the buffers are bound.</param>
    /// <param name="first">Specifies the index of the first binding point to which to bind buffers.</param>
    /// <param name="buffers">Specifies an array of buffer objects whose names to bind.</param>
    /// <param name="offsets">Specifies an array of offsets into the buffer objects.</param>
    /// <param name="sizes">Specifies an array of sizes of the buffer object regions.</param>
    public void glBindBuffersRange(GLenum target, GLuint first, GLuint[] buffers, GLintptr[] offsets, GLsizeiptr[] sizes) { fixed (GLuint* p_buffers =
 &buffers[0]) { fixed (GLintptr* p_offsets = &offsets[0]) { fixed (GLsizeiptr* p_sizes =
 &sizes[0]) { _glBindBuffersRange(target, first, buffers.Length, p_buffers, p_offsets, p_sizes); } } } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDTEXTURESPROC(GLuint first, GLsizei count, GLuint* textures);
    private PFNGLBINDTEXTURESPROC _glBindTextures;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Bind an array of textures to a set of consecutive texture units.
    /// </summary>
    /// <param name="first">Specifies the index of the first texture unit to which to bind textures.</param>
    /// <param name="count">Specifies the number of textures to bind.</param>
    /// <param name="textures">Specifies an array of textures whose names to bind.</param>
    public void glBindTextures(GLuint first, GLsizei count, GLuint* textures) => _glBindTextures(first, count, textures);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Bind an array of textures to a set of consecutive texture units.
    /// </summary>
    /// <param name="first">Specifies the index of the first texture unit to which to bind textures.</param>
    /// <param name="textures">Specifies an array of textures whose names to bind.</param>
    public void glBindTextures(GLuint first, GLuint[] textures) { fixed (GLuint* p_textures =
 &textures[0]) { _glBindTextures(first, textures.Length, p_textures); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDSAMPLERSPROC(GLuint first, GLsizei count, GLuint* samplers);
    private PFNGLBINDSAMPLERSPROC _glBindSamplers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Bind an array of samplers to a set of consecutive texture units.
    /// </summary>
    /// <param name="first">Specifies the index of the first texture unit to which to bind samplers.</param>
    /// <param name="count">Specifies the number of samplers to bind.</param>
    /// <param name="samplers">Specifies an array of samplers whose names to bind.</param>
    public void glBindSamplers(GLuint first, GLsizei count, GLuint* samplers) => _glBindSamplers(first, count, samplers);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Bind an array of samplers to a set of consecutive texture units.
    /// </summary>
    /// <param name="first">Specifies the index of the first texture unit to which to bind samplers.</param>
    /// <param name="samplers">Specifies an array of samplers whose names to bind.</param>
    public void glBindSamplers(GLuint first, GLuint[] samplers) { fixed (GLuint* p_samplers =
 &samplers[0]) { _glBindSamplers(first, samplers.Length, p_samplers); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDIMAGETEXTURESPROC(GLuint first, GLsizei count, GLuint* textures);
    private PFNGLBINDIMAGETEXTURESPROC _glBindImageTextures;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Bind an array of textures to a set of consecutive image units.
    /// </summary>
    /// <param name="first">Specifies the index of the first image unit to which to bind textures.</param>
    /// <param name="count">Specifies the number of textures to bind.</param>
    /// <param name="textures">Specifies an array of textures whose names to bind.</param>
    public void glBindImageTextures(GLuint first, GLsizei count, GLuint* textures) => _glBindImageTextures(first, count, textures);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Bind an array of textures to a set of consecutive image units.
    /// </summary>
    /// <param name="first">Specifies the index of the first image unit to which to bind textures.</param>
    /// <param name="textures">Specifies an array of textures whose names to bind.</param>
    public void glBindImageTextures(GLuint first, GLuint[] textures) { fixed (GLuint* p_textures =
 &textures[0]) { _glBindImageTextures(first, textures.Length, p_textures); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDVERTEXBUFFERSPROC(GLuint first, GLsizei count, GLuint* buffers, GLintptr* offsets, GLsizei* strides);
    private PFNGLBINDVERTEXBUFFERSPROC _glBindVertexBuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Bind an array of buffer objects to a sequence of consecutive vertex buffer binding points.
    /// </summary>
    /// <param name="first">Specifies the index of the first vertex buffer binding point to which to bind buffer.</param>
    /// <param name="count">Specifies the number of buffer binding points to which to bind buffers.</param>
    /// <param name="buffers">Specifies an array of buffer objects whose names to bind.</param>
    /// <param name="offsets">Specifies an array of offsets into each buffer object being bound.</param>
    /// <param name="strides">Specifies an array of stride values.</param>
    public void glBindVertexBuffers(GLuint first, GLsizei count, GLuint* buffers, GLintptr* offsets, GLsizei* strides) => _glBindVertexBuffers(first, count, buffers, offsets, strides);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Bind an array of buffer objects to a sequence of consecutive vertex buffer binding points.
    /// </summary>
    /// <param name="first">Specifies the index of the first vertex buffer binding point to which to bind buffer.</param>
    /// <param name="buffers">Specifies an array of buffer objects whose names to bind.</param>
    /// <param name="offsets">Specifies an array of offsets into each buffer object being bound.</param>
    /// <param name="strides">Specifies an array of stride values.</param>
    public void glBindVertexBuffers(GLuint first, GLuint[] buffers, GLintptr[] offsets, GLsizei[] strides) { fixed (GLuint* p_buffers =
 &buffers[0]) { fixed (GLintptr* p_offsets = &offsets[0]) { fixed (GLsizei* p_strides =
 &strides[0]) { _glBindVertexBuffers(first, buffers.Length, p_buffers, p_offsets, p_strides); } } } }
#endif

#endif

    // OpenGL 4.5

#if OGL_V_4_5 || OGL_V_4_6
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLIPCONTROLPROC(GLenum origin, GLenum depth);
    private PFNGLCLIPCONTROLPROC _glClipControl;
    /// <summary>
    /// Controls the clipping behavior.
    /// </summary>
    /// <param name="origin">Specifies whether the clip volume's depth extent is given by the near and far clip distances stored in the depth range, or whether the clip volume's depth extent should be [-1, 1], regardless of the depth range.</param>
    /// <param name="depth">Specifies whether vertex post-clipping x, y, and z coordinates are clipped to the clip volume based on their w component.</param>
    public void glClipControl(GLenum origin, GLenum depth) => _glClipControl(origin, depth);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCREATETRANSFORMFEEDBACKSPROC(GLsizei n, GLuint* ids);
    private PFNGLCREATETRANSFORMFEEDBACKSPROC _glCreateTransformFeedbacks;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate transform feedback object names.
    /// </summary>
    /// <param name="n">Specifies the number of transform feedback object names to generate.</param>
    /// <param name="ids">Specifies an array in which the generated transform feedback object names are stored.</param>
    public void glCreateTransformFeedbacks(GLsizei n, GLuint* ids) => _glCreateTransformFeedbacks(n, ids);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate transform feedback object names.
    /// </summary>
    /// <param name="n">Specifies the number of transform feedback object names to generate.</param>
    /// <returns>An array in which the generated transform feedback object names are stored.</returns>
    public GLuint[] glCreateTransformFeedbacks(GLsizei n) { GLuint[] ids = new GLuint[n]; fixed (GLuint* p_ids =
 &ids[0]) { _glCreateTransformFeedbacks(n, p_ids); } return ids; }
    /// <summary>
    /// Generate a single transform feedback object name.
    /// </summary>
    /// <returns>The generated transform feedback object name.</returns>
    public GLuint glCreateTransformFeedbacks() => glCreateTransformFeedbacks(1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC(GLuint xfb, GLuint index, GLuint buffer);
    private PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC _glTransformFeedbackBufferBase;
    /// <summary>
    /// Bind a buffer object to an indexed transform feedback buffer target.
    /// </summary>
    /// <param name="xfb">Specifies the name of a transform feedback object.</param>
    /// <param name="index">Specifies the index of the transform feedback buffer object whose binding to modify.</param>
    /// <param name="buffer">Specifies the name of the buffer object to bind to the target.</param>
    public void glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer) => _glTransformFeedbackBufferBase(xfb, index, buffer);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
    private PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC _glTransformFeedbackBufferRange;
    /// <summary>
    /// Bind a range of a buffer object to an indexed transform feedback buffer target.
    /// </summary>
    /// <param name="xfb">Specifies the name of a transform feedback object.</param>
    /// <param name="index">Specifies the index of the transform feedback buffer object whose binding to modify.</param>
    /// <param name="buffer">Specifies the name of the buffer object to bind to the target.</param>
    /// <param name="offset">Specifies the starting offset in basic machine units into the buffer object buffer.</param>
    /// <param name="size">Specifies the amount of data in machine units that can be read from the buffer object while used as an indexed transform feedback buffer.</param>
    public void glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) => _glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTRANSFORMFEEDBACKIVPROC(GLuint xfb, GLenum pname, GLint* param);
    private PFNGLGETTRANSFORMFEEDBACKIVPROC _glGetTransformFeedbackiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a transform feedback object.
    /// </summary>
    /// <param name="xfb">Specifies the name of a transform feedback object.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint* param) => _glGetTransformFeedbackiv(xfb, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a transform feedback object.
    /// </summary>
    /// <param name="xfb">Specifies the name of a transform feedback object.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="param">Specifies an array in which to place the returned data.</param>
    public void glGetTransformFeedbackiv(GLuint xfb, GLenum pname, ref GLint[] param) { fixed (GLint* p_param =
 &param[0]) { _glGetTransformFeedbackiv(xfb, pname, p_param); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTRANSFORMFEEDBACKI_VPROC(GLuint xfb, GLenum pname, GLuint index, GLint* param);
    private PFNGLGETTRANSFORMFEEDBACKI_VPROC _glGetTransformFeedbacki_v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a transform feedback object.
    /// </summary>
    /// <param name="xfb">Specifies the name of a transform feedback object.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="index">Specifies the index of the transform feedback buffer object whose binding to query.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint* param) => _glGetTransformFeedbacki_v(xfb, pname, index, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a transform feedback object.
    /// </summary>
    /// <param name="xfb">Specifies the name of a transform feedback object.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="index">Specifies the index of the transform feedback buffer object whose binding to query.</param>
    /// <param name="param">Specifies an array in which to place the returned data.</param>
    public void glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, ref GLint[] param) { fixed (GLint* p_param =
 &param[0]) { _glGetTransformFeedbacki_v(xfb, pname, index, p_param); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTRANSFORMFEEDBACKI64_VPROC(GLuint xfb, GLenum pname, GLuint index, GLint64* param);
    private PFNGLGETTRANSFORMFEEDBACKI64_VPROC _glGetTransformFeedbacki64_v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a transform feedback object.
    /// </summary>
    /// <param name="xfb">Specifies the name of a transform feedback object.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="index">Specifies the index of the transform feedback buffer object whose binding to query.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64* param) => _glGetTransformFeedbacki64_v(xfb, pname, index, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a transform feedback object.
    /// </summary>
    /// <param name="xfb">Specifies the name of a transform feedback object.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="index">Specifies the index of the transform feedback buffer object whose binding to query.</param>
    /// <param name="param">Specifies an array in which to place the returned data.</param>
    public void glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, ref GLint64[] param) { fixed (GLint64* p_param =
 &param[0]) { _glGetTransformFeedbacki64_v(xfb, pname, index, p_param); } }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCREATEBUFFERSPROC(GLsizei n, GLuint* buffers);
    private PFNGLCREATEBUFFERSPROC _glCreateBuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate buffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of buffer object names to generate.</param>
    /// <param name="buffers">Specifies an array in which to place the generated buffer object names.</param>
    public void glCreateBuffers(GLsizei n, GLuint* buffers) => _glCreateBuffers(n, buffers);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate buffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of buffer object names to generate.</param>
    /// <returns>An array containing the generated buffer object names.</returns>
    public GLuint[] glCreateBuffers(GLsizei n) { GLuint[] buffers = new GLuint[n]; fixed (GLuint* p_buffers =
 &buffers[0]) { _glCreateBuffers(n, p_buffers); } return buffers; }
    /// <summary>
    /// Generate a single buffer object name.
    /// </summary>
    /// <returns>The generated buffer object name.</returns>
    public GLuint glCreateBuffer() => glCreateBuffers(1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDBUFFERSTORAGEPROC(GLuint buffer, GLsizeiptr size, void* data, GLbitfield flags);
    private PFNGLNAMEDBUFFERSTORAGEPROC _glNamedBufferStorage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Create and initialize a buffer object's data store.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to create.</param>
    /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
    /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
    /// <param name="flags">Specifies flags indicating the intended usage of the buffer's data store.</param>
    public void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, void* data, GLbitfield flags) => _glNamedBufferStorage(buffer, size, data, flags);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Create and initialize a buffer object's data store.
    /// </summary>
    /// <typeparam name="T">The type of the data to copy into the buffer.</typeparam>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to create.</param>
    /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
    /// <param name="data">Specifies an array containing the data to copy into the buffer.</param>
    /// <param name="flags">Specifies flags indicating the intended usage of the buffer's data store.</param>
    public void glNamedBufferStorage<T>(GLuint buffer, GLsizeiptr size, T[] data, GLbitfield flags) where T : unmanaged
    {
        fixed (T* p_data = &data[0]) { _glNamedBufferStorage(buffer, size, p_data, flags); }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDBUFFERDATAPROC(GLuint buffer, GLsizeiptr size, void* data, GLenum usage);
    private PFNGLNAMEDBUFFERDATAPROC _glNamedBufferData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Create and initialize a buffer object's data store.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to create.</param>
    /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
    /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
    /// <param name="usage">Specifies the expected usage pattern of the data store.</param>
    public void glNamedBufferData(GLuint buffer, GLsizeiptr size, void* data, GLenum usage) => _glNamedBufferData(buffer, size, data, usage);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Create and initialize a buffer object's data store.
    /// </summary>
    /// <typeparam name="T">The type of the data to copy into the buffer.</typeparam>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to create.</param>
    /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
    /// <param name="data">Specifies an array containing the data to copy into the buffer.</param>
    /// <param name="usage">Specifies the expected usage pattern of the data store.</param>
    public void glNamedBufferData<T>(GLuint buffer, GLsizeiptr size, T[] data, GLenum usage) where T : unmanaged
    {
        fixed (T* p_data = &data[0]) { _glNamedBufferData(buffer, size, p_data, usage); }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDBUFFERSUBDATAPROC(GLuint buffer, GLintptr offset, GLsizeiptr size, void* data);
    private PFNGLNAMEDBUFFERSUBDATAPROC _glNamedBufferSubData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Update a subset of a buffer object's data store.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store is to be updated.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.</param>
    /// <param name="size">Specifies the size in bytes of the data store region being replaced.</param>
    /// <param name="data">Specifies a pointer to the new data that will be copied into the data store.</param>
    public void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void* data) => _glNamedBufferSubData(buffer, offset, size, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Update a subset of a buffer object's data store.
    /// </summary>
    /// <typeparam name="T">The type of the data to copy into the buffer.</typeparam>
    /// <param name="buffer">Specifies the name of the buffer object whose data store is to be updated.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.</param>
    /// <param name="size">Specifies the size in bytes of the data store region being replaced.</param>
    /// <param name="data">Specifies an array containing the new data that will be copied into the data store.</param>
    public void glNamedBufferSubData<T>(GLuint buffer, GLintptr offset, GLsizeiptr size, T[] data) where T : unmanaged
    {
        fixed (T* p_data = &data[0]) { _glNamedBufferSubData(buffer, offset, size, p_data); }
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCOPYNAMEDBUFFERSUBDATAPROC(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
    private PFNGLCOPYNAMEDBUFFERSUBDATAPROC _glCopyNamedBufferSubData;
    /// <summary>
    /// Copy part of the data store of a buffer object to the data store of another buffer object.
    /// </summary>
    /// <param name="readBuffer">Specifies the name of the buffer object from which to read data.</param>
    /// <param name="writeBuffer">Specifies the name of the buffer object to which to write data.</param>
    /// <param name="readOffset">Specifies the offset into the data store of readBuffer at which to start reading data, measured in bytes.</param>
    /// <param name="writeOffset">Specifies the offset into the data store of writeBuffer at which to start writing data, measured in bytes.</param>
    /// <param name="size">Specifies the size in bytes of the data to be copied from readBuffer to writeBuffer.</param>
    public void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) => _glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARNAMEDBUFFERDATAPROC(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, void* data);
    private PFNGLCLEARNAMEDBUFFERDATAPROC _glClearNamedBufferData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear all or part of a buffer object's data store to the fixed value.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to clear.</param>
    /// <param name="internalformat">Specifies the internal format of the buffer's data store.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="data">Specifies a pointer to the data that will be used to clear the buffer's data store.</param>
    public void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, void* data) => _glClearNamedBufferData(buffer, internalformat, format, type, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear all or part of a buffer object's data store to the fixed value.
    /// </summary>
    /// <typeparam name="T">The type of the data to copy into the buffer.</typeparam>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to clear.</param>
    /// <param name="internalformat">Specifies the internal format of the buffer's data store.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="data">Specifies an array containing the data that will be used to clear the buffer's data store.</param>
    public void glClearNamedBufferData<T>(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, T[] data) where T : unmanaged { fixed (T* t =
 &data[0]) _glClearNamedBufferData(buffer, internalformat, format, type, t); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARNAMEDBUFFERSUBDATAPROC(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, void* data);
    private PFNGLCLEARNAMEDBUFFERSUBDATAPROC _glClearNamedBufferSubData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear all or part of a buffer object's data store to the fixed value.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to clear.</param>
    /// <param name="internalformat">Specifies the internal format of the buffer's data store.</param>
    /// <param name="offset">Specifies the offset into the buffer's data store where clear will begin, measured in bytes.</param>
    /// <param name="size">Specifies the size in bytes of the buffer's data store region being cleared.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="data">Specifies a pointer to the data that will be used to clear the buffer's data store.</param>
    public void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, void* data) => _glClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear all or part of a buffer object's data store to the fixed value.
    /// </summary>
    /// <typeparam name="T">The type of the data to copy into the buffer.</typeparam>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to clear.</param>
    /// <param name="internalformat">Specifies the internal format of the buffer's data store.</param>
    /// <param name="offset">Specifies the offset into the buffer's data store where clear will begin, measured in bytes.</param>
    /// <param name="size">Specifies the size in bytes of the buffer's data store region being cleared.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="data">Specifies an array containing the data that will be used to clear the buffer's data store.</param>
    public void glClearNamedBufferSubData<T>(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, T[] data) where T : unmanaged { fixed (T* t
 = &data[0]) _glClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, t); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void* PFNGLMAPNAMEDBUFFERPROC(GLuint buffer, GLenum access);
    private PFNGLMAPNAMEDBUFFERPROC _glMapNamedBuffer;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Map all or part of the data store of a buffer object into the client's address space.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to map.</param>
    /// <param name="access">Specifies the access policy for the region of the buffer object's data store to be mapped.</param>
    /// <returns>Upon success, returns a pointer to the beginning of the mapped range. Otherwise, returns NULL.</returns>
    public void* glMapNamedBuffer(GLuint buffer, GLenum access) => _glMapNamedBuffer(buffer, access);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Map all or part of the data store of a buffer object into the client's address space.
    /// </summary>
    /// <typeparam name="T">The type of the data to copy into the buffer.</typeparam>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to map.</param>
    /// <param name="access">Specifies the access policy for the region of the buffer object's data store to be mapped.</param>
    /// <returns>Upon success, returns a <see cref="System.Span{T}"/> to the beginning of the mapped range.</returns>
    public System.Span<T> glMapNamedBuffer<T>(GLuint buffer, GLenum access) where T : unmanaged
    {
        GLint* size = stackalloc GLint[1];
        _glGetNamedBufferParameteriv(buffer, IGL.GL_BUFFER_SIZE, size);
        void* ptr = _glMapNamedBuffer(buffer, access);
        return new System.Span<T>(ptr, *size / sizeof(T));
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void* PFNGLMAPNAMEDBUFFERRANGEPROC(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
    private PFNGLMAPNAMEDBUFFERRANGEPROC _glMapNamedBufferRange;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Map all or part of the data store of a buffer object into the client's address space.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to map.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store where mapping will begin, measured in bytes.</param>
    /// <param name="length">Specifies the length of the buffer object's data store region being mapped, measured in bytes.</param>
    /// <param name="access">Specifies the access policy for the region of the buffer object's data store to be mapped.</param>
    /// <returns>Upon success, returns a pointer to the beginning of the mapped range. Otherwise, returns NULL.</returns>
    public void* glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) => _glMapNamedBufferRange(buffer, offset, length, access);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Map all or part of the data store of a buffer object into the client's address space.
    /// </summary>
    /// <typeparam name="T">The type of the data to copy into the buffer.</typeparam>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to map.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store where mapping will begin, measured in bytes.</param>
    /// <param name="length">Specifies the length of the buffer object's data store region being mapped, measured in bytes.</param>
    /// <param name="access">Specifies the access policy for the region of the buffer object's data store to be mapped.</param>
    /// <returns>Upon success, returns a <see cref="System.Span{T}"/> to the beginning of the mapped range.</returns>
    public System.Span<T> glMapNamedBufferRange<T>(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) where T : unmanaged
    {
        void* ptr = _glMapNamedBufferRange(buffer, offset, length, access);
        return new System.Span<T>(ptr, (int)length / sizeof(T));
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLboolean PFNGLUNMAPNAMEDBUFFERPROC(GLuint buffer);
    private PFNGLUNMAPNAMEDBUFFERPROC _glUnmapNamedBuffer;
    /// <summary>
    /// Invalidate all or part of a buffer object's data store.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to unmap.</param>
    public GLboolean glUnmapNamedBuffer(GLuint buffer) => _glUnmapNamedBuffer(buffer);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC(GLuint buffer, GLintptr offset, GLsizeiptr length);
    private PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC _glFlushMappedNamedBufferRange;
    /// <summary>
    /// Flush mapped buffer range.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose data store to flush.</param>
    /// <param name="offset">Specifies the offset within the buffer object's data store of the start of the range to flush, measured in bytes.</param>
    /// <param name="length">Specifies the length of the range within the buffer object's data store to flush, measured in bytes.</param>
    public void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length) => _glFlushMappedNamedBufferRange(buffer, offset, length);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNAMEDBUFFERPARAMETERIVPROC(GLuint buffer, GLenum pname, GLint* parameters);
    private PFNGLGETNAMEDBUFFERPARAMETERIVPROC _glGetNamedBufferParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a buffer object target.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose parameter to query.</param>
    /// <param name="pname">Specifies the symbolic name of a buffer object parameter.</param>
    /// <param name="parameters">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint* parameters) => _glGetNamedBufferParameteriv(buffer, pname, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a buffer object target.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose parameter to query.</param>
    /// <param name="pname">Specifies the symbolic name of a buffer object parameter.</param>
    /// <param name="parameters">Specifies an array to receive the value(s) of the queried parameter.</param>
    public void glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, ref GLint[] parameters) { fixed (GLint* ptr_parameters =
 &parameters[0]) _glGetNamedBufferParameteriv(buffer, pname, ptr_parameters); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNAMEDBUFFERPARAMETERI64VPROC(GLuint buffer, GLenum pname, GLint64* parameters);
    private PFNGLGETNAMEDBUFFERPARAMETERI64VPROC _glGetNamedBufferParameteri64v;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a buffer object target.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose parameter to query.</param>
    /// <param name="pname">Specifies the symbolic name of a buffer object parameter.</param>
    /// <param name="parameters">Specifies the address of a variable to receive the value of the queried parameter.</param>
    public void glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64* parameters) => _glGetNamedBufferParameteri64v(buffer, pname, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a buffer object target.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose parameter to query.</param>
    /// <param name="pname">Specifies the symbolic name of a buffer object parameter.</param>
    /// <param name="parameters">Specifies an array to receive the value(s) of the queried parameter.</param>
    public void glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, ref GLint64[] parameters) { fixed (GLint64* ptr_parameters =
 &parameters[0]) _glGetNamedBufferParameteri64v(buffer, pname, ptr_parameters); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNAMEDBUFFERPOINTERVPROC(GLuint buffer, GLenum pname, void** parameters);
    private PFNGLGETNAMEDBUFFERPOINTERVPROC _glGetNamedBufferPointerv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the pointer to a mapped buffer object's data store.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose pointer to query.</param>
    /// <param name="pname">Specifies the pointer to be returned.</param>
    /// <param name="parameters">Specifies the address of a variable to receive the pointer to the buffer object's mapped data store.</param>
    public void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void** parameters) => _glGetNamedBufferPointerv(buffer, pname, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the pointer to a mapped buffer object's data store.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object whose pointer to query.</param>
    /// <param name="pname">Specifies the pointer to be returned.</param>
    /// <param name="parameters">Specifies an array to receive the pointer to the buffer object's mapped data store.</param>
    public void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, ref IntPtr[] parameters)
    {
        void*[] ptr_parameters = new void*[parameters.Length];
        for (int i = 0; i < parameters.Length; i++)
            ptr_parameters[i] = (void*)parameters[i];
        fixed (void** ptr = &ptr_parameters[0])
            _glGetNamedBufferPointerv(buffer, pname, ptr);

        for (int i = 0; i < parameters.Length; i++)
            parameters[i] = (IntPtr)ptr_parameters[i];
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNAMEDBUFFERSUBDATAPROC(GLuint buffer, GLintptr offset, GLsizeiptr size, void* data);
    private PFNGLGETNAMEDBUFFERSUBDATAPROC _glGetNamedBufferSubData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return a subset of data from a buffer object's data store.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store from which to retrieve data, measured in bytes.</param>
    /// <param name="size">Specifies the size in bytes of the data store region being returned.</param>
    /// <param name="data">Specifies the address of a buffer to receive the returned data.</param>
    public void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void* data) => _glGetNamedBufferSubData(buffer, offset, size, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return a subset of data from a buffer object's data store.
    /// </summary>
    /// <param name="buffer">Specifies the name of the buffer object.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store from which to retrieve data, measured in bytes.</param>
    /// <param name="size">Specifies the size in bytes of the data store region being returned.</param>
    public T[] glGetNamedBufferSubData<T>(GLuint buffer, GLintptr offset, GLsizeiptr size) where T : unmanaged
    {
        T[] data = new T[size / sizeof(T)];
        fixed (T* ptr_data = &data[0])
            _glGetNamedBufferSubData(buffer, offset, size, ptr_data);
        return data;
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCREATEFRAMEBUFFERSPROC(GLsizei n, GLuint* framebuffers);
    private PFNGLCREATEFRAMEBUFFERSPROC _glCreateFramebuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate framebuffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of framebuffer object names to generate.</param>
    /// <param name="framebuffers">Specifies an array in which the generated framebuffer object names are stored.</param>
    public void glCreateFramebuffers(GLsizei n, GLuint* framebuffers) => _glCreateFramebuffers(n, framebuffers);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate framebuffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of framebuffer object names to generate.</param>
    /// <returns>Array of framebuffer object names.</returns>
    public GLuint[] glCreateFramebuffers(GLsizei n) { GLuint[] framebuffers = new GLuint[n]; fixed (GLuint* ptr_framebuffers =
 &framebuffers[0]) _glCreateFramebuffers(n, ptr_framebuffers); return framebuffers; }
    /// <summary>
    /// Generate a single framebuffer object name.
    /// </summary>
    /// <returns>Framebuffer object name.</returns>
    public GLuint glCreateFramebuffer() => glCreateFramebuffers(1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
    private PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC _glNamedFramebufferRenderbuffer;
    /// <summary>
    /// Attach a renderbuffer as a logical buffer to the specified framebuffer object.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object to which to attach the renderbuffer.</param>
    /// <param name="attachment">Specifies the attachment point of the framebuffer.</param>
    /// <param name="renderbuffertarget">Specifies the renderbuffer target of the framebuffer attachment point named by attachment.</param>
    /// <param name="renderbuffer">Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.</param>
    public void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) => _glNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC(GLuint framebuffer, GLenum pname, GLint param);
    private PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC _glNamedFramebufferParameteri;
    /// <summary>
    /// Set parameters for the specified framebuffer object.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object for which to set parameters.</param>
    /// <param name="pname">Specifies the parameter to set.</param>
    /// <param name="param">Specifies the new value for pname.</param>
    public void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param) => _glNamedFramebufferParameteri(framebuffer, pname, param);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDFRAMEBUFFERTEXTUREPROC(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
    private PFNGLNAMEDFRAMEBUFFERTEXTUREPROC _glNamedFramebufferTexture;
    /// <summary>
    /// Attach a level of a texture object as a logical buffer to the specified framebuffer object.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object to which to attach the texture.</param>
    /// <param name="attachment">Specifies the attachment point of the framebuffer.</param>
    /// <param name="texture">Specifies the name of an existing texture object of type target to attach.</param>
    /// <param name="level">Specifies the mipmap level of the texture object to attach.</param>
    public void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) => _glNamedFramebufferTexture(framebuffer, attachment, texture, level);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
    private PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC _glNamedFramebufferTextureLayer;
    /// <summary>
    /// Attach a single layer of a texture object as a logical buffer to the specified framebuffer object.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object to which to attach the texture.</param>
    /// <param name="attachment">Specifies the attachment point of the framebuffer.</param>
    /// <param name="texture">Specifies the name of an existing texture object of type target to attach.</param>
    /// <param name="level">Specifies the mipmap level of the texture object to attach.</param>
    /// <param name="layer">Specifies the layer of a 3-dimensional texture or the layer of a cube map texture.</param>
    public void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) => _glNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC(GLuint framebuffer, GLenum buf);
    private PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC _glNamedFramebufferDrawBuffer;
    /// <summary>
    /// Specify the draw buffer for the specified framebuffer object.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object for which to set the draw buffer.</param>
    /// <param name="buf">Specifies the draw buffer.</param>
    public void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf) => _glNamedFramebufferDrawBuffer(framebuffer, buf);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC(GLuint framebuffer, GLsizei n, GLenum* bufs);
    private PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC _glNamedFramebufferDrawBuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify the draw buffers for the specified framebuffer object.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object for which to set the draw buffers.</param>
    /// <param name="n">Specifies the number of buffers in bufs.</param>
    /// <param name="bufs">Specifies an array of symbolic constants specifying the buffers to be drawn into.</param>
    public void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, GLenum* bufs) => _glNamedFramebufferDrawBuffers(framebuffer, n, bufs);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify the draw buffers for the specified framebuffer object.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object for which to set the draw buffers.</param>
    /// <param name="bufs">Specifies an array of symbolic constants specifying the buffers to be drawn into.</param>
    public void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLenum[] bufs) { fixed (GLenum* ptr_bufs =
 &bufs[0]) _glNamedFramebufferDrawBuffers(framebuffer, bufs.Length, ptr_bufs); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC(GLuint framebuffer, GLenum src);
    private PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC _glNamedFramebufferReadBuffer;
    /// <summary>
    /// Specify the read buffer for the specified framebuffer object.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object for which to set the read buffer.</param>
    /// <param name="src">Specifies the read buffer.</param>
    public void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum src) => _glNamedFramebufferReadBuffer(framebuffer, src);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC(GLuint framebuffer, GLsizei numAttachments, GLenum* attachments);
    private PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC _glInvalidateNamedFramebufferData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Invalidate the content of a named framebuffer attachment.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="numAttachments">Specifies the number of attachments.</param>
    /// <param name="attachments">Specifies an array of attachment points.</param>
    public void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, GLenum* attachments) => _glInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Invalidate the content of a named framebuffer attachment.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="attachments">Specifies an array of attachment points.</param>
    public void glInvalidateNamedFramebufferData(GLuint framebuffer, GLenum[] attachments) { fixed (GLenum* ptr_attachments =
 &attachments[0]) _glInvalidateNamedFramebufferData(framebuffer, attachments.Length, ptr_attachments); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC(GLuint framebuffer, GLsizei numAttachments, GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
    private PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC _glInvalidateNamedFramebufferSubData;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Invalidate the content of a region of a named framebuffer attachment.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="numAttachments">Specifies the number of attachments.</param>
    /// <param name="attachments">Specifies an array of attachment points.</param>
    /// <param name="x">Specifies the left pixel coordinate of the region.</param>
    /// <param name="y">Specifies the lower pixel coordinate of the region.</param>
    /// <param name="width">Specifies the width of the region.</param>
    /// <param name="height">Specifies the height of the region.</param>
    public void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height) => _glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Invalidate the content of a region of a named framebuffer attachment.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="attachments">Specifies an array of attachment points.</param>
    /// <param name="x">Specifies the left pixel coordinate of the region.</param>
    /// <param name="y">Specifies the lower pixel coordinate of the region.</param>
    /// <param name="width">Specifies the width of the region.</param>
    /// <param name="height">Specifies the height of the region.</param>
    public void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLenum[] attachments, GLint x, GLint y, GLsizei width, GLsizei height) { fixed (GLenum* ptr_attachments
 = &attachments[0]) _glInvalidateNamedFramebufferSubData(framebuffer, attachments.Length, ptr_attachments, x, y, width, height); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARNAMEDFRAMEBUFFERIVPROC(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLint* value);
    private PFNGLCLEARNAMEDFRAMEBUFFERIVPROC _glClearNamedFramebufferiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear the specified buffer of a framebuffer to the specified value.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="buffer">Specifies the buffer to clear.</param>
    /// <param name="drawbuffer">Specifies the index of the draw buffer within the framebuffer.</param>
    /// <param name="value">Specifies the address of a four-element vector specifying the R, G, B, and A values used to clear the buffer.</param>
    public void glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLint* value) => _glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear the specified buffer of a framebuffer to the specified value.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="buffer">Specifies the buffer to clear.</param>
    /// <param name="drawbuffer">Specifies the index of the draw buffer within the framebuffer.</param>
    /// <param name="value">Specifies the address of a four-element vector specifying the R, G, B, and A values used to clear the buffer.</param>
    public void glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLint[] value) { fixed (GLint* ptr_value =
 &value[0]) _glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, ptr_value); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLuint* value);
    private PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC _glClearNamedFramebufferuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear the specified buffer of a framebuffer to the specified value.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="buffer">Specifies the buffer to clear.</param>
    /// <param name="drawbuffer">Specifies the index of the draw buffer within the framebuffer.</param>
    /// <param name="value">Specifies the address of a four-element vector specifying the R, G, B, and A values used to clear the buffer.</param>
    public void glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLuint* value) => _glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear the specified buffer of a framebuffer to the specified value.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="buffer">Specifies the buffer to clear.</param>
    /// <param name="drawbuffer">Specifies the index of the draw buffer within the framebuffer.</param>
    /// <param name="value">Specifies the address of a four-element vector specifying the R, G, B, and A values used to clear the buffer.</param>
    public void glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLuint[] value) { fixed (GLuint* ptr_value =
 &value[0]) _glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, ptr_value); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARNAMEDFRAMEBUFFERFVPROC(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat* value);
    private PFNGLCLEARNAMEDFRAMEBUFFERFVPROC _glClearNamedFramebufferfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Clear the specified buffer of a framebuffer to the specified value.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="buffer">Specifies the buffer to clear.</param>
    /// <param name="drawbuffer">Specifies the index of the draw buffer within the framebuffer.</param>
    /// <param name="value">Specifies the address of a four-element vector specifying the R, G, B, and A values used to clear the buffer.</param>
    public void glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat* value) => _glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Clear the specified buffer of a framebuffer to the specified value.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="buffer">Specifies the buffer to clear.</param>
    /// <param name="drawbuffer">Specifies the index of the draw buffer within the framebuffer.</param>
    /// <param name="value">Specifies the address of a four-element vector specifying the R, G, B, and A values used to clear the buffer.</param>
    public void glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat[] value) { fixed (GLfloat* ptr_value =
 &value[0]) _glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, ptr_value); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCLEARNAMEDFRAMEBUFFERFIPROC(GLuint framebuffer, GLenum buffer, GLfloat depth, GLint stencil);
    private PFNGLCLEARNAMEDFRAMEBUFFERFIPROC _glClearNamedFramebufferfi;
    /// <summary>
    /// Clear the specified buffer of a framebuffer to the specified value.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="buffer">Specifies the buffer to clear.</param>
    /// <param name="depth">Specifies the depth value used when the depth buffer is cleared. The initial value is 1.</param>
    /// <param name="stencil">Specifies the index used when the stencil buffer is cleared. The initial value is 0.</param>
    public void glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLfloat depth, GLint stencil) => _glClearNamedFramebufferfi(framebuffer, buffer, depth, stencil);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBLITNAMEDFRAMEBUFFERPROC(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
    private PFNGLBLITNAMEDFRAMEBUFFERPROC _glBlitNamedFramebuffer;
    /// <summary>
    /// Copy a block of pixels from the read framebuffer to the draw framebuffer.
    /// </summary>
    /// <param name="readFramebuffer">Specifies the name of the read framebuffer.</param>
    /// <param name="drawFramebuffer">Specifies the name of the draw framebuffer.</param>
    /// <param name="srcX0">Specifies the left source rectangle x coordinate.</param>
    /// <param name="srcY0">Specifies the bottom source rectangle y coordinate.</param>
    /// <param name="srcX1">Specifies the right source rectangle x coordinate.</param>
    /// <param name="srcY1">Specifies the top source rectangle y coordinate.</param>
    /// <param name="dstX0">Specifies the left destination rectangle x coordinate.</param>
    /// <param name="dstY0">Specifies the bottom destination rectangle y coordinate.</param>
    /// <param name="dstX1">Specifies the right destination rectangle x coordinate.</param>
    /// <param name="dstY1">Specifies the top destination rectangle y coordinate.</param>
    /// <param name="mask">Specifies the mask that indicates the buffers to be copied.</param>
    /// <param name="filter">Specifies the interpolation to be applied if the image is stretched.</param>
    public void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) => _glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLenum PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC(GLuint framebuffer, GLenum target);
    private PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC _glCheckNamedFramebufferStatus;
    /// <summary>
    /// Check the completeness status of a framebuffer.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object whose status to query.</param>
    /// <param name="target">Specifies the target to which the framebuffer is attached.</param>
    public GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target) => _glCheckNamedFramebufferStatus(framebuffer, target);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC(GLuint framebuffer, GLenum pname, GLint* param);
    private PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC _glGetNamedFramebufferParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a framebuffer object target.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of pname.</param>
    public void glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint* param) => _glGetNamedFramebufferParameteriv(framebuffer, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a framebuffer object target.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="param">Specifies an array to receive the value of pname.</param>
    public void glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, ref GLint[] param) { fixed (GLint* ptr_param =
 &param[0]) _glGetNamedFramebufferParameteriv(framebuffer, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params_);
    private PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC _glGetNamedFramebufferAttachmentParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a framebuffer attachment.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="attachment">Specifies the attachment within framebuffer.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="params_">Specifies the address of a variable to receive the value of pname.</param>
    public void glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params_) => _glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params_);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a framebuffer attachment.
    /// </summary>
    /// <param name="framebuffer">Specifies the name of the framebuffer object.</param>
    /// <param name="attachment">Specifies the attachment within framebuffer.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="params_">Specifies an array to receive the value of pname.</param>
    public void glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, ref GLint[] params_) { fixed (GLint* ptr_params_
 = &params_[0]) _glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, ptr_params_); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCREATERENDERBUFFERSPROC(GLsizei n, GLuint* renderbuffers);
    private PFNGLCREATERENDERBUFFERSPROC _glCreateRenderbuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate renderbuffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of renderbuffer object names to generate.</param>
    /// <param name="renderbuffers">Specifies an array in which the generated renderbuffer object names are stored.</param>
    public void glCreateRenderbuffers(GLsizei n, GLuint* renderbuffers) => _glCreateRenderbuffers(n, renderbuffers);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate renderbuffer object names.
    /// </summary>
    /// <param name="n">Specifies the number of renderbuffer object names to generate.</param>
    /// <returns>Array of generated renderbuffer object names.</returns>
    public GLuint[] glCreateRenderbuffers(GLsizei n) { GLuint[] renderbuffers = new GLuint[n]; fixed (GLuint* ptr_renderbuffers =
 &renderbuffers[0]) _glCreateRenderbuffers(n, ptr_renderbuffers); return renderbuffers; }
    /// <summary>
    /// Generate a single renderbuffer object name.
    /// </summary>
    /// <returns>Generated renderbuffer object name.</returns>
    public GLuint glCreateRenderbuffer() => glCreateRenderbuffers(1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDRENDERBUFFERSTORAGEPROC(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
    private PFNGLNAMEDRENDERBUFFERSTORAGEPROC _glNamedRenderbufferStorage;
    /// <summary>
    /// Establish data storage, format and dimensions of a renderbuffer object's image.
    /// </summary>
    /// <param name="renderbuffer">Specifies the name of the renderbuffer object.</param>
    /// <param name="internalformat">Specifies the internal format to be used for the renderbuffer object's image.</param>
    /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
    /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
    public void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) => _glNamedRenderbufferStorage(renderbuffer, internalformat, width, height);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
    private PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC _glNamedRenderbufferStorageMultisample;
    /// <summary>
    /// Establish data storage, format, dimensions and number of samples of a renderbuffer object's image.
    /// </summary>
    /// <param name="renderbuffer">Specifies the name of the renderbuffer object.</param>
    /// <param name="samples">Specifies the number of samples of the image.</param>
    /// <param name="internalformat">Specifies the internal format to be used for the renderbuffer object's image.</param>
    /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
    /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
    public void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) => _glNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC(GLuint renderbuffer, GLenum pname, GLint* param);
    private PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC _glGetNamedRenderbufferParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a renderbuffer object.
    /// </summary>
    /// <param name="renderbuffer">Specifies the name of the renderbuffer object.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of pname.</param>
    public void glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint* param) => _glGetNamedRenderbufferParameteriv(renderbuffer, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a renderbuffer object.
    /// </summary>
    /// <param name="renderbuffer">Specifies the name of the renderbuffer object.</param>
    /// <param name="pname">Specifies the parameter to query.</param>
    /// <param name="param">Specifies an array to receive the value of pname.</param>
    public void glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, ref GLint[] param) { fixed (GLint* ptr_param =
 &param[0]) _glGetNamedRenderbufferParameteriv(renderbuffer, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCREATETEXTURESPROC(GLenum target, GLsizei n, GLuint* textures);
    private PFNGLCREATETEXTURESPROC _glCreateTextures;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate texture names.
    /// </summary>
    /// <param name="target">Specifies the target of the texture.</param>
    /// <param name="n">Specifies the number of texture names to generate.</param>
    /// <param name="textures">Specifies an array in which the generated texture names are stored.</param>
    public void glCreateTextures(GLenum target, GLsizei n, GLuint* textures) => _glCreateTextures(target, n, textures);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate texture names.
    /// </summary>
    /// <param name="target">Specifies the target of the texture.</param>
    /// <param name="n">Specifies the number of texture names to generate.</param>
    /// <returns>Array of generated texture names.</returns>
    public GLuint[] glCreateTextures(GLenum target, GLsizei n) { GLuint[] textures = new GLuint[n]; fixed (GLuint* ptr_textures =
 &textures[0]) _glCreateTextures(target, n, ptr_textures); return textures; }
    /// <summary>
    /// Generate a single texture name.
    /// </summary>
    /// <param name="target">Specifies the target of the texture.</param>
    /// <returns>Generated texture name.</returns>
    public GLuint glCreateTexture(GLenum target) => glCreateTextures(target, 1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTUREBUFFERPROC(GLuint texture, GLenum internalformat, GLuint buffer);
    private PFNGLTEXTUREBUFFERPROC _glTextureBuffer;
    /// <summary>
    /// Attach a buffer object's data store to a buffer texture.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture to which to attach the buffer object.</param>
    /// <param name="internalformat">Specifies the internal format of the data in the store belonging to buffer.</param>
    /// <param name="buffer">Specifies the name of the buffer object whose storage to attach to the active buffer texture.</param>
    public void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer) => _glTextureBuffer(texture, internalformat, buffer);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTUREBUFFERRANGEPROC(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
    private PFNGLTEXTUREBUFFERRANGEPROC _glTextureBufferRange;
    /// <summary>
    /// Attach a range of a buffer object's data store to a buffer texture.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture to which to attach the buffer object.</param>
    /// <param name="internalformat">Specifies the internal format of the data in the store belonging to buffer.</param>
    /// <param name="buffer">Specifies the name of the buffer object whose storage to attach to the active buffer texture.</param>
    /// <param name="offset">Specifies the offset of the start of the range of the buffer's data store to attach.</param>
    /// <param name="size">Specifies the size of the range of the buffer's data store to attach.</param>
    public void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) => _glTextureBufferRange(texture, internalformat, buffer, offset, size);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTURESTORAGE1DPROC(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
    private PFNGLTEXTURESTORAGE1DPROC _glTextureStorage1D;
    /// <summary>
    /// Specify storage for a one-dimensional texture.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object for which to allocate storage.</param>
    /// <param name="levels">Specifies the number of levels of detail in the texture.</param>
    /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the texture, in texels.</param>
    public void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width) => _glTextureStorage1D(texture, levels, internalformat, width);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTURESTORAGE2DPROC(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
    private PFNGLTEXTURESTORAGE2DPROC _glTextureStorage2D;
    /// <summary>
    /// Specify storage for a two-dimensional texture.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object for which to allocate storage.</param>
    /// <param name="levels">Specifies the number of levels of detail in the texture.</param>
    /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the texture, in texels.</param>
    /// <param name="height">Specifies the height of the texture, in texels.</param>
    public void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) => _glTextureStorage2D(texture, levels, internalformat, width, height);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTURESTORAGE3DPROC(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
    private PFNGLTEXTURESTORAGE3DPROC _glTextureStorage3D;
    /// <summary>
    /// Specify storage for a three-dimensional texture.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object for which to allocate storage.</param>
    /// <param name="levels">Specifies the number of levels of detail in the texture.</param>
    /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the texture, in texels.</param>
    /// <param name="height">Specifies the height of the texture, in texels.</param>
    /// <param name="depth">Specifies the depth of the texture, in texels.</param>
    public void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) => _glTextureStorage3D(texture, levels, internalformat, width, height, depth);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
    private PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC _glTextureStorage2DMultisample;
    /// <summary>
    /// Specify storage for a two-dimensional multisample texture.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object for which to allocate storage.</param>
    /// <param name="samples">Specifies the number of samples in the texture.</param>
    /// <param name="internalformat">Specifies the internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the texture, in texels.</param>
    /// <param name="height">Specifies the height of the texture, in texels.</param>
    /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</param>
    public void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) => _glTextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
    private PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC _glTextureStorage3DMultisample;
    /// <summary>
    /// Specify storage for a three-dimensional multisample texture.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object for which to allocate storage.</param>
    /// <param name="samples">Specifies the number of samples in the texture.</param>
    /// <param name="internalformat">Specifies the internal format to be used to store texture image data.</param>
    /// <param name="width">Specifies the width of the texture, in texels.</param>
    /// <param name="height">Specifies the height of the texture, in texels.</param>
    /// <param name="depth">Specifies the depth of the texture, in texels.</param>
    /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</param>
    public void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) => _glTextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTURESUBIMAGE1DPROC(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, void* pixels);
    private PFNGLTEXTURESUBIMAGE1DPROC _glTextureSubImage1D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a one-dimensional texture subimage.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
    public void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, void* pixels) => _glTextureSubImage1D(texture, level, xoffset, width, format, type, pixels);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a one-dimensional texture subimage.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="pixels">Specifies an array containing the image data.</param>
    public void glTextureSubImage1D<T>(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, T[] pixels) where T : unmanaged { fixed (T* ptr_pixels
 = &pixels[0]) _glTextureSubImage1D(texture, level, xoffset, width, format, type, ptr_pixels); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTURESUBIMAGE2DPROC(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
    private PFNGLTEXTURESUBIMAGE2DPROC _glTextureSubImage2D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a two-dimensional texture subimage.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
    public void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels) => _glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a two-dimensional texture subimage.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="pixels">Specifies an array containing the image data.</param>
    public void glTextureSubImage2D<T>(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, T[] pixels) where T : unmanaged { fixed (T* ptr_pixels
 = &pixels[0]) _glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, ptr_pixels); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTURESUBIMAGE3DPROC(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* pixels);
    private PFNGLTEXTURESUBIMAGE3DPROC _glTextureSubImage3D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a three-dimensional texture subimage.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
    public void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* pixels) => _glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a three-dimensional texture subimage.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="pixels">Specifies an array containing the image data.</param>
    public void glTextureSubImage3D<T>(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, T[] pixels) where T : unmanaged { fixed (T* ptr_pixels
 = &pixels[0]) _glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, ptr_pixels); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, void* data);
    private PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC _glCompressedTextureSubImage1D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a one-dimensional texture subimage in a compressed format.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
    /// <param name="imageSize">Specifies the number of unsigned bytes of compressed texture data starting at address data.</param>
    /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
    public void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, void* data) => _glCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a one-dimensional texture subimage in a compressed format.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
    /// <param name="imageSize">Specifies the number of unsigned bytes of compressed texture data starting at address data.</param>
    /// <param name="data">Specifies an array containing the compressed image data.</param>
    public void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, byte[] data) { fixed (byte* ptr_data
 = &data[0]) _glCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, ptr_data); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, void* data);
    private PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC _glCompressedTextureSubImage2D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a two-dimensional texture subimage in a compressed format.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
    /// <param name="imageSize">Specifies the number of unsigned bytes of compressed texture data starting at address data.</param>
    /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
    public void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, void* data) => _glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a two-dimensional texture subimage in a compressed format.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
    /// <param name="imageSize">Specifies the number of unsigned bytes of compressed texture data starting at address data.</param>
    /// <param name="data">Specifies an array containing the compressed image data.</param>
    public void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, byte[] data) { fixed (byte* ptr_data
 = &data[0]) _glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, ptr_data); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, void* data);
    private PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC _glCompressedTextureSubImage3D;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specify a three-dimensional texture subimage in a compressed format.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
    /// <param name="imageSize">Specifies the number of unsigned bytes of compressed texture data starting at address data.</param>
    /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
    public void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, void* data) => _glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specify a three-dimensional texture subimage in a compressed format.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to be modified.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
    /// <param name="imageSize">Specifies the number of unsigned bytes of compressed texture data starting at address data.</param>
    /// <param name="data">Specifies an array containing the compressed image data.</param>
    public void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, byte[] data) { fixed (byte* ptr_data
 = &data[0]) _glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, ptr_data); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCOPYTEXTURESUBIMAGE1DPROC(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
    private PFNGLCOPYTEXTURESUBIMAGE1DPROC _glCopyTextureSubImage1D;
    /// <summary>
    /// Copy a one-dimensional texture subimage from the framebuffer to a one-dimensional texture image.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to which to copy.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="x">Specify the window coordinates of the left corners of the row of pixels to be copied.</param>
    /// <param name="y">Specify the window coordinates of the left corners of the row of pixels to be copied.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    public void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) => _glCopyTextureSubImage1D(texture, level, xoffset, x, y, width);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCOPYTEXTURESUBIMAGE2DPROC(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
    private PFNGLCOPYTEXTURESUBIMAGE2DPROC _glCopyTextureSubImage2D;
    /// <summary>
    /// Copy a two-dimensional texture subimage from the framebuffer to a two-dimensional texture image.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to which to copy.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="x">Specify the window coordinates of the left corners of the row of pixels to be copied.</param>
    /// <param name="y">Specify the window coordinates of the left corners of the row of pixels to be copied.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    public void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) => _glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCOPYTEXTURESUBIMAGE3DPROC(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
    private PFNGLCOPYTEXTURESUBIMAGE3DPROC _glCopyTextureSubImage3D;
    /// <summary>
    /// Copy a three-dimensional texture subimage from the framebuffer to a three-dimensional texture image.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object to which to copy.</param>
    /// <param name="level">Specifies the level-of-detail number.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="x">Specify the window coordinates of the left corners of the row of pixels to be copied.</param>
    /// <param name="y">Specify the window coordinates of the left corners of the row of pixels to be copied.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    public void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) => _glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTUREPARAMETERFPROC(GLuint texture, GLenum pname, GLfloat param);
    private PFNGLTEXTUREPARAMETERFPROC _glTextureParameterf;
    /// <summary>
    /// Set texture parameter.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTextureParameterf(GLuint texture, GLenum pname, GLfloat param) => _glTextureParameterf(texture, pname, param);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTUREPARAMETERFVPROC(GLuint texture, GLenum pname, GLfloat* param);
    private PFNGLTEXTUREPARAMETERFVPROC _glTextureParameterfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set texture parameter.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTextureParameterfv(GLuint texture, GLenum pname, GLfloat* param) => _glTextureParameterfv(texture, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set texture parameter.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTextureParameterfv(GLuint texture, GLenum pname, GLfloat[] param) { fixed (GLfloat* ptr_param =
 &param[0]) _glTextureParameterfv(texture, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTUREPARAMETERIPROC(GLuint texture, GLenum pname, GLint param);
    private PFNGLTEXTUREPARAMETERIPROC _glTextureParameteri;
    /// <summary>
    /// Set texture parameter.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTextureParameteri(GLuint texture, GLenum pname, GLint param) => _glTextureParameteri(texture, pname, param);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTUREPARAMETERIIVPROC(GLuint texture, GLenum pname, GLint* param);
    private PFNGLTEXTUREPARAMETERIIVPROC _glTextureParameterIiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set texture parameter.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTextureParameterIiv(GLuint texture, GLenum pname, GLint* param) => _glTextureParameterIiv(texture, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set texture parameter.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTextureParameterIiv(GLuint texture, GLenum pname, GLint[] param) { fixed (GLint* ptr_param =
 &param[0]) _glTextureParameterIiv(texture, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTUREPARAMETERIUIVPROC(GLuint texture, GLenum pname, GLuint* param);
    private PFNGLTEXTUREPARAMETERIUIVPROC _glTextureParameterIuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set texture parameter.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTextureParameterIuiv(GLuint texture, GLenum pname, GLuint* param) => _glTextureParameterIuiv(texture, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set texture parameter.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTextureParameterIuiv(GLuint texture, GLenum pname, GLuint[] param) { fixed (GLuint* ptr_param =
 &param[0]) _glTextureParameterIuiv(texture, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTUREPARAMETERIVPROC(GLuint texture, GLenum pname, GLint* param);
    private PFNGLTEXTUREPARAMETERIVPROC _glTextureParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Set texture parameter.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTextureParameteriv(GLuint texture, GLenum pname, GLint* param) => _glTextureParameteriv(texture, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Set texture parameter.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the value of pname.</param>
    public void glTextureParameteriv(GLuint texture, GLenum pname, GLint[] param) { fixed (GLint* ptr_param =
 &param[0]) _glTextureParameteriv(texture, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGENERATETEXTUREMIPMAPPROC(GLuint texture);
    private PFNGLGENERATETEXTUREMIPMAPPROC _glGenerateTextureMipmap;
    /// <summary>
    /// Generate mipmaps for a specified texture object.
    /// </summary>
    /// <param name="texture">Specifies the texture object to which to generate mipmaps.</param>
    public void glGenerateTextureMipmap(GLuint texture) => _glGenerateTextureMipmap(texture);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLBINDTEXTUREUNITPROC(GLuint unit, GLuint texture);
    private PFNGLBINDTEXTUREUNITPROC _glBindTextureUnit;
    /// <summary>
    /// Bind a named texture to a texturing target.
    /// </summary>
    /// <param name="unit">Specifies the index of the texture unit to which to bind the texture.</param>
    /// <param name="texture">Specifies the name of a texture.</param>
    public void glBindTextureUnit(GLuint unit, GLuint texture) => _glBindTextureUnit(unit, texture);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTEXTUREIMAGEPROC(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
    private PFNGLGETTEXTUREIMAGEPROC _glGetTextureImage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture image data.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture image data.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given in pixels.</param>
    /// <param name="pixels">Specifies a pointer to the buffer into which to place the returned data.</param>
    public void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels) => _glGetTextureImage(texture, level, format, type, bufSize, pixels);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture image data.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture image data.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="bufSize">Specifies the maximum number of values of type <typeparamref name="T"/> that can be returned.</param>
    /// <returns>The texture image data.</returns>
    public T[] glGetTextureImage<T>(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize) where T : unmanaged { T[] pixels =
 new T[bufSize]; fixed (T* ptr_pixels = &pixels[0]) _glGetTextureImage(texture, level, format, type, bufSize, ptr_pixels); return pixels; }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC(GLuint texture, GLint level, GLsizei bufSize, void* pixels);
    private PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC _glGetCompressedTextureImage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return the compressed texture image data.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture image data.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="bufSize">Specifies the size of the buffer whose address is given in pixels.</param>
    /// <param name="pixels">Specifies a pointer to the buffer into which to place the returned data.</param>
    public void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void* pixels) => _glGetCompressedTextureImage(texture, level, bufSize, pixels);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return the compressed texture image data.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture image data.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="bufSize">Specifies the maximum number of bytes of compressed texture image data that may be returned.</param>
    public byte[] glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize) { byte[] pixels = new byte[bufSize]; fixed (byte* ptr_pixels
 = &pixels[0]) _glGetCompressedTextureImage(texture, level, bufSize, ptr_pixels); return pixels; }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTEXTURELEVELPARAMETERFVPROC(GLuint texture, GLint level, GLenum pname, GLfloat* param);
    private PFNGLGETTEXTURELEVELPARAMETERFVPROC _glGetTextureLevelParameterfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture parameter values for a specific level of detail.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of the texture parameter specified by <paramref name="pname"/> at the level of detail specified by <paramref name="level"/>.</param>
    public void glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat* param) => _glGetTextureLevelParameterfv(texture, level, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture parameter values for a specific level of detail.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies an array to receive the value of the texture parameter specified by <paramref name="pname"/> at the level of detail specified by <paramref name="level"/>.</param>
    public void glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, ref GLfloat[] param) { fixed (GLfloat* ptr_param =
 &param[0]) _glGetTextureLevelParameterfv(texture, level, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTEXTURELEVELPARAMETERIVPROC(GLuint texture, GLint level, GLenum pname, GLint* param);
    private PFNGLGETTEXTURELEVELPARAMETERIVPROC _glGetTextureLevelParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture parameter values for a specific level of detail.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of the texture parameter specified by <paramref name="pname"/> at the level of detail specified by <paramref name="level"/>.</param>
    public void glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint* param) => _glGetTextureLevelParameteriv(texture, level, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture parameter values for a specific level of detail.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies an array to receive the value of the texture parameter specified by <paramref name="pname"/> at the level of detail specified by <paramref name="level"/>.</param>
    public void glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, ref GLint[] param) { fixed (GLint* ptr_param =
 &param[0]) _glGetTextureLevelParameteriv(texture, level, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTEXTUREPARAMETERFVPROC(GLuint texture, GLenum pname, GLfloat* param);
    private PFNGLGETTEXTUREPARAMETERFVPROC _glGetTextureParameterfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture parameter values.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of the texture parameter specified by <paramref name="pname"/>.</param>
    public void glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat* param) => _glGetTextureParameterfv(texture, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture parameter values.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies an array to receive the value of the texture parameter specified by <paramref name="pname"/>.</param>
    public void glGetTextureParameterfv(GLuint texture, GLenum pname, ref GLfloat[] param) { fixed (GLfloat* ptr_param =
 &param[0]) _glGetTextureParameterfv(texture, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTEXTUREPARAMETERIIVPROC(GLuint texture, GLenum pname, GLint* param);
    private PFNGLGETTEXTUREPARAMETERIIVPROC _glGetTextureParameterIiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture parameter values.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of the texture parameter specified by <paramref name="pname"/>.</param>
    public void glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint* param) => _glGetTextureParameterIiv(texture, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture parameter values.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies an array to receive the value of the texture parameter specified by <paramref name="pname"/>.</param>
    public void glGetTextureParameterIiv(GLuint texture, GLenum pname, ref GLint[] param) { fixed (GLint* ptr_param =
 &param[0]) _glGetTextureParameterIiv(texture, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTEXTUREPARAMETERIUIVPROC(GLuint texture, GLenum pname, GLuint* param);
    private PFNGLGETTEXTUREPARAMETERIUIVPROC _glGetTextureParameterIuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture parameter values.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of the texture parameter specified by <paramref name="pname"/>.</param>
    public void glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint* param) => _glGetTextureParameterIuiv(texture, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture parameter values.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies an array to receive the value of the texture parameter specified by <paramref name="pname"/>.</param>
    public void glGetTextureParameterIuiv(GLuint texture, GLenum pname, ref GLuint[] param) { fixed (GLuint* ptr_param =
 &param[0]) _glGetTextureParameterIuiv(texture, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTEXTUREPARAMETERIVPROC(GLuint texture, GLenum pname, GLint* param);
    private PFNGLGETTEXTUREPARAMETERIVPROC _glGetTextureParameteriv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return texture parameter values.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies the address of a variable to receive the value of the texture parameter specified by <paramref name="pname"/>.</param>
    public void glGetTextureParameteriv(GLuint texture, GLenum pname, GLint* param) => _glGetTextureParameteriv(texture, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return texture parameter values.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture parameter values.</param>
    /// <param name="pname">Specifies the symbolic name of a texture parameter.</param>
    /// <param name="param">Specifies an array to receive the value of the texture parameter specified by <paramref name="pname"/>.</param>
    public void glGetTextureParameteriv(GLuint texture, GLenum pname, ref GLint[] param) { fixed (GLint* ptr_param =
 &param[0]) _glGetTextureParameteriv(texture, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCREATEVERTEXARRAYSPROC(GLsizei n, GLuint* arrays);
    private PFNGLCREATEVERTEXARRAYSPROC _glCreateVertexArrays;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate vertex array object names.
    /// </summary>
    /// <param name="n">Specifies the number of vertex array object names to generate.</param>
    /// <param name="arrays">Specifies an array in which to place the generated vertex array object names.</param>
    public void glCreateVertexArrays(GLsizei n, GLuint* arrays) => _glCreateVertexArrays(n, arrays);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate vertex array object names.
    /// </summary>
    /// <param name="n">Specifies the number of vertex array object names to generate.</param>
    /// <returns>Array of generated vertex array object names.</returns>
    public GLuint[] glCreateVertexArrays(GLsizei n) { var arrays = new GLuint[n]; fixed (GLuint* ptr_arrays =
 &arrays[0]) _glCreateVertexArrays(n, ptr_arrays); return arrays; }
    /// <summary>
    /// Generate a single vertex array object name.
    /// </summary>
    /// <returns>Generated vertex array object name.</returns>
    public GLuint glCreateVertexArray() => glCreateVertexArrays(1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLDISABLEVERTEXARRAYATTRIBPROC(GLuint vaobj, GLuint index);
    private PFNGLDISABLEVERTEXARRAYATTRIBPROC _glDisableVertexArrayAttrib;
    /// <summary>
    /// Disable a generic vertex attribute array.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="index">Specifies the index of the generic vertex attribute to be disabled.</param>
    public void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index) => _glDisableVertexArrayAttrib(vaobj, index);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLENABLEVERTEXARRAYATTRIBPROC(GLuint vaobj, GLuint index);
    private PFNGLENABLEVERTEXARRAYATTRIBPROC _glEnableVertexArrayAttrib;
    /// <summary>
    /// Enable a generic vertex attribute array.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="index">Specifies the index of the generic vertex attribute to be enabled.</param>
    public void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index) => _glEnableVertexArrayAttrib(vaobj, index);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXARRAYELEMENTBUFFERPROC(GLuint vaobj, GLuint buffer);
    private PFNGLVERTEXARRAYELEMENTBUFFERPROC _glVertexArrayElementBuffer;
    /// <summary>
    /// Bind a buffer object to an element array buffer binding point of a vertex array object.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="buffer">Specifies the name of an existing buffer object that contains the index array data.</param>
    public void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer) => _glVertexArrayElementBuffer(vaobj, buffer);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXARRAYVERTEXBUFFERPROC(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
    private PFNGLVERTEXARRAYVERTEXBUFFERPROC _glVertexArrayVertexBuffer;
    /// <summary>
    /// Bind a buffer object to a vertex buffer binding point of a vertex array object.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="bindingindex">Specifies the index of the vertex buffer binding point to which to bind the buffer.</param>
    /// <param name="buffer">Specifies the name of an existing buffer object that contains the data store to be associated with the vertex array object.</param>
    /// <param name="offset">Specifies the offset of the first element of the buffer bound to the vertex buffer binding point.</param>
    /// <param name="stride">Specifies the distance between consecutive elements within the buffer.</param>
    public void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) => _glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXARRAYVERTEXBUFFERSPROC(GLuint vaobj, GLuint first, GLsizei count, GLuint* buffers, GLintptr* offsets, GLsizei* strides);
    private PFNGLVERTEXARRAYVERTEXBUFFERSPROC _glVertexArrayVertexBuffers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Bind an array of buffer objects to vertex buffer binding points of a vertex array object.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="first">Specifies the index of the first vertex buffer binding point to which to bind a buffer.</param>
    /// <param name="count">Specifies the number of buffers to bind.</param>
    /// <param name="buffers">Specifies an array of names of existing buffer objects that contain the data stores to be associated with the vertex array object.</param>
    /// <param name="offsets">Specifies an array of offsets into the buffer objects.</param>
    /// <param name="strides">Specifies an array of stride values.</param>
    public void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, GLuint* buffers, GLintptr* offsets, GLsizei* strides) => _glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Bind an array of buffer objects to vertex buffer binding points of a vertex array object.   
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="first">Specifies the index of the first vertex buffer binding point to which to bind a buffer.</param>
    /// <param name="buffers">Specifies an array of names of existing buffer objects that contain the data stores to be associated with the vertex array object.</param>
    /// <param name="offsets">Specifies an array of offsets into the buffer objects.</param>
    /// <param name="strides">Specifies an array of stride values.</param>
    public void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLuint[] buffers, GLintptr[] offsets, GLsizei[] strides) { fixed (GLuint* ptr_buffers
 = &buffers[0]) fixed (GLintptr* ptr_offsets = &offsets[0]) fixed (GLsizei* ptr_strides =
 &strides[0]) _glVertexArrayVertexBuffers(vaobj, first, (GLsizei)buffers.Length, ptr_buffers, ptr_offsets, ptr_strides); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXARRAYATTRIBBINDINGPROC(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
    private PFNGLVERTEXARRAYATTRIBBINDINGPROC _glVertexArrayAttribBinding;
    /// <summary>
    /// Associate a vertex attribute and a vertex buffer binding.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="attribindex">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="bindingindex">Specifies the index of the binding whose vertex buffer data is to be used by the generic vertex attribute at index attribindex.</param>
    public void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex) => _glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXARRAYATTRIBFORMATPROC(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
    private PFNGLVERTEXARRAYATTRIBFORMATPROC _glVertexArrayAttribFormat;
    /// <summary>
    /// Specify the organization of vertex arrays.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="attribindex">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="size">Specifies the number of components per attribute. Must be 1, 2, 3, 4, or GL_BGRA.</param>
    /// <param name="type">Specifies the data type of each component.</param>
    /// <param name="normalized">Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</param>
    /// <param name="relativeoffset">Specifies the offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the binding point specified by bindingindex.</param>
    public void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) => _glVertexArrayAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXARRAYATTRIBIFORMATPROC(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
    private PFNGLVERTEXARRAYATTRIBIFORMATPROC _glVertexArrayAttribIFormat;
    /// <summary>
    /// Specify the organization of vertex arrays.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="attribindex">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="size">Specifies the number of components per attribute. Must be 1, 2, 3, 4, or GL_BGRA.</param>
    /// <param name="type">Specifies the data type of each component.</param>
    /// <param name="relativeoffset">Specifies the offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the binding point specified by bindingindex.</param>
    public void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) => _glVertexArrayAttribIFormat(vaobj, attribindex, size, type, relativeoffset);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXARRAYATTRIBLFORMATPROC(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
    private PFNGLVERTEXARRAYATTRIBLFORMATPROC _glVertexArrayAttribLFormat;
    /// <summary>
    /// Specify the organization of vertex arrays.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="attribindex">Specifies the index of the generic vertex attribute to be modified.</param>
    /// <param name="size">Specifies the number of components per attribute. Must be 1, 2, 3, 4, or GL_BGRA.</param>
    /// <param name="type">Specifies the data type of each component.</param>
    /// <param name="relativeoffset">Specifies the offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the binding point specified by bindingindex.</param>
    public void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) => _glVertexArrayAttribLFormat(vaobj, attribindex, size, type, relativeoffset);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLVERTEXARRAYBINDINGDIVISORPROC(GLuint vaobj, GLuint bindingindex, GLuint divisor);
    private PFNGLVERTEXARRAYBINDINGDIVISORPROC _glVertexArrayBindingDivisor;
    /// <summary>
    /// Modify the rate at which generic vertex attributes advance during instanced rendering.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="bindingindex">Specifies the index of the binding whose divisor to modify.</param>
    /// <param name="divisor">Specifies the new value for the instance step rate.</param>
    public void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor) => _glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETVERTEXARRAYIVPROC(GLuint vaobj, GLenum pname, GLint* param);
    private PFNGLGETVERTEXARRAYIVPROC _glGetVertexArrayiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a vertex array object.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="pname">Specifies the parameter value to return.</param>
    /// <param name="param">Specifies the address of a variable to receive the parameter value.</param>
    public void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint* param) => _glGetVertexArrayiv(vaobj, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a vertex array object.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="pname">Specifies the parameter value to return.</param>
    /// <param name="param">Specifies an array to receive the parameter value.</param>
    public void glGetVertexArrayiv(GLuint vaobj, GLenum pname, ref GLint[] param) { fixed (GLint* ptr_param =
 &param[0]) _glGetVertexArrayiv(vaobj, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETVERTEXARRAYINDEXEDIVPROC(GLuint vaobj, GLuint index, GLenum pname, GLint* param);
    private PFNGLGETVERTEXARRAYINDEXEDIVPROC _glGetVertexArrayIndexediv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a vertex array object.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="index">Specifies the index of the vertex array object entry to be queried.</param>
    /// <param name="pname">Specifies the parameter value to return.</param>
    /// <param name="param">Specifies the address of a variable to receive the parameter value.</param>
    public void glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint* param) => _glGetVertexArrayIndexediv(vaobj, index, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a vertex array object.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="index">Specifies the index of the vertex array object entry to be queried.</param>
    /// <param name="pname">Specifies the parameter value to return.</param>
    /// <param name="param">Specifies an array to receive the parameter value.</param>
    public void glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, ref GLint[] param) { fixed (GLint* ptr_param =
 &param[0]) _glGetVertexArrayIndexediv(vaobj, index, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETVERTEXARRAYINDEXED64IVPROC(GLuint vaobj, GLuint index, GLenum pname, GLint64* param);
    private PFNGLGETVERTEXARRAYINDEXED64IVPROC _glGetVertexArrayIndexed64iv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return parameters of a vertex array object.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="index">Specifies the index of the vertex array object entry to be queried.</param>
    /// <param name="pname">Specifies the parameter value to return.</param>
    /// <param name="param">Specifies the address of a variable to receive the parameter value.</param>
    public void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64* param) => _glGetVertexArrayIndexed64iv(vaobj, index, pname, param);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return parameters of a vertex array object.
    /// </summary>
    /// <param name="vaobj">Specifies the name of the vertex array object.</param>
    /// <param name="index">Specifies the index of the vertex array object entry to be queried.</param>
    /// <param name="pname">Specifies the parameter value to return.</param>
    /// <param name="param">Specifies an array to receive the parameter value.</param>
    public void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, ref GLint64[] param) { fixed (GLint64* ptr_param =
 &param[0]) _glGetVertexArrayIndexed64iv(vaobj, index, pname, ptr_param); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCREATESAMPLERSPROC(GLsizei n, GLuint* samplers);
    private PFNGLCREATESAMPLERSPROC _glCreateSamplers;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate sampler object names.
    /// </summary>
    /// <param name="n">Specifies the number of sampler object names to generate.</param>
    /// <param name="samplers">Specifies an array in which the generated sampler object names are stored.</param>
    public void glCreateSamplers(GLsizei n, GLuint* samplers) => _glCreateSamplers(n, samplers);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate sampler object names.
    /// </summary>
    /// <param name="n">Specifies the number of sampler object names to generate.</param>
    /// <returns>Array of generated sampler object names.</returns>
    public GLuint[] glCreateSamplers(GLsizei n) { GLuint[] samplers = new GLuint[n]; fixed (GLuint* ptr_samplers =
 &samplers[0]) _glCreateSamplers(n, ptr_samplers); return samplers; }
    /// <summary>
    /// Generate a single sampler object name.
    /// </summary>
    /// <returns>The generated sampler object name.</returns>
    public GLuint glCreateSamplers() => glCreateSamplers(1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCREATEPROGRAMPIPELINESPROC(GLsizei n, GLuint* pipelines);
    private PFNGLCREATEPROGRAMPIPELINESPROC _glCreateProgramPipelines;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate program pipeline object names.
    /// </summary>
    /// <param name="n">Specifies the number of program pipeline object names to generate.</param>
    /// <param name="pipelines">Specifies an array in which the generated program pipeline object names are stored.</param>
    public void glCreateProgramPipelines(GLsizei n, GLuint* pipelines) => _glCreateProgramPipelines(n, pipelines);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate program pipeline object names.
    /// </summary>
    /// <param name="n">Specifies the number of program pipeline object names to generate.</param>
    /// <returns>Array of generated program pipeline object names.</returns>
    public GLuint[] glCreateProgramPipelines(GLsizei n) { GLuint[] pipelines = new GLuint[n]; fixed (GLuint* ptr_pipelines =
 &pipelines[0]) _glCreateProgramPipelines(n, ptr_pipelines); return pipelines; }
    /// <summary>
    /// Generate a single program pipeline object name.
    /// </summary>
    /// <returns>The generated program pipeline object name.</returns>
    public GLuint glCreateProgramPipeline() => glCreateProgramPipelines(1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLCREATEQUERIESPROC(GLenum target, GLsizei n, GLuint* ids);
    private PFNGLCREATEQUERIESPROC _glCreateQueries;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Generate query object names.
    /// </summary>
    /// <param name="target">Specifies the target of the query object.</param>
    /// <param name="n">Specifies the number of query object names to generate.</param>
    /// <param name="ids">Specifies an array in which the generated query object names are stored.</param>
    public void glCreateQueries(GLenum target, GLsizei n, GLuint* ids) => _glCreateQueries(target, n, ids);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Generate query object names.
    /// </summary>
    /// <param name="target">Specifies the target of the query object.</param>
    /// <param name="n">Specifies the number of query object names to generate.</param>
    /// <returns>Array of generated query object names.</returns>
    public GLuint[] glCreateQueries(GLenum target, GLsizei n) { GLuint[] ids = new GLuint[n]; fixed (GLuint* ptr_ids =
 &ids[0]) _glCreateQueries(target, n, ptr_ids); return ids; }
    /// <summary>
    /// Generate a single query object name.
    /// </summary>
    /// <param name="target">Specifies the target of the query object.</param>
    /// <returns>The generated query object name.</returns>
    public GLuint glCreateQuery(GLenum target) => glCreateQueries(target, 1)[0];
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETQUERYBUFFEROBJECTI64VPROC(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
    private PFNGLGETQUERYBUFFEROBJECTI64VPROC _glGetQueryBufferObjecti64v;
    /// <summary>
    /// Retrieve the value of a query object parameter.
    /// </summary>
    /// <param name="id">Specifies the name of a query object.</param>
    /// <param name="buffer">Specifies the name of a buffer object into which to place the returned data.</param>
    /// <param name="pname">Specifies the name of the query parameter to retrieve.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store where data will be placed.</param>
    public void glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) => _glGetQueryBufferObjecti64v(id, buffer, pname, offset);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETQUERYBUFFEROBJECTIVPROC(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
    private PFNGLGETQUERYBUFFEROBJECTIVPROC _glGetQueryBufferObjectiv;
    /// <summary>
    /// Retrieve the value of a query object parameter.
    /// </summary>
    /// <param name="id">Specifies the name of a query object.</param>
    /// <param name="buffer">Specifies the name of a buffer object into which to place the returned data.</param>
    /// <param name="pname">Specifies the name of the query parameter to retrieve.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store where data will be placed.</param>
    public void glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) => _glGetQueryBufferObjectiv(id, buffer, pname, offset);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETQUERYBUFFEROBJECTUI64VPROC(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
    private PFNGLGETQUERYBUFFEROBJECTUI64VPROC _glGetQueryBufferObjectui64v;
    /// <summary>
    /// Retrieve the value of a query object parameter.
    /// </summary>
    /// <param name="id">Specifies the name of a query object.</param>
    /// <param name="buffer">Specifies the name of a buffer object into which to place the returned data.</param>
    /// <param name="pname">Specifies the name of the query parameter to retrieve.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store where data will be placed.</param>
    public void glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) => _glGetQueryBufferObjectui64v(id, buffer, pname, offset);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETQUERYBUFFEROBJECTUIVPROC(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
    private PFNGLGETQUERYBUFFEROBJECTUIVPROC _glGetQueryBufferObjectuiv;
    /// <summary>
    /// Retrieve the value of a query object parameter.
    /// </summary>
    /// <param name="id">Specifies the name of a query object.</param>
    /// <param name="buffer">Specifies the name of a buffer object into which to place the returned data.</param>
    /// <param name="pname">Specifies the name of the query parameter to retrieve.</param>
    /// <param name="offset">Specifies the offset into the buffer object's data store where data will be placed.</param>
    public void glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) => _glGetQueryBufferObjectuiv(id, buffer, pname, offset);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLMEMORYBARRIERBYREGIONPROC(GLbitfield barriers);
    private PFNGLMEMORYBARRIERBYREGIONPROC _glMemoryBarrierByRegion;
    /// <summary>
    /// Specify the execution memory barriers to be applied.
    /// </summary>
    /// <param name="barriers">Specifies the barriers to be applied.</param>
    public void glMemoryBarrierByRegion(GLbitfield barriers) => _glMemoryBarrierByRegion(barriers);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETTEXTURESUBIMAGEPROC(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
    private PFNGLGETTEXTURESUBIMAGEPROC _glGetTextureSubImage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return a subregion of a texture image.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture data.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="bufSize">Specifies the size in basic machine units of the buffer addressed by pixels.</param>
    /// <param name="pixels">Specifies a pointer to the buffer into which to place the returned pixel data.</param>
    public void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void* pixels) => _glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return a subregion of a texture image.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture data.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="bufSize">Specifies the size in basic machine units of the buffer addressed by pixels.</param>
    /// <returns>The pixel data.</returns>
    public byte[] glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize) { byte[] pixels
 = new byte[bufSize]; fixed (void* ptr_pixels =
 &pixels[0]) _glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, ptr_pixels); return pixels; }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void* pixels);
    private PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC _glGetCompressedTextureSubImage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return a subregion of a compressed texture image.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture data.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="bufSize">Specifies the size in basic machine units of the buffer addressed by pixels.</param>
    /// <param name="pixels">Specifies a pointer to the buffer into which to place the returned pixel data.</param>
    public void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void* pixels) => _glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return a subregion of a compressed texture image.
    /// </summary>
    /// <param name="texture">Specifies the name of the texture object from which to retrieve texture data.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
    /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
    /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
    /// <param name="width">Specifies the width of the texture subimage.</param>
    /// <param name="height">Specifies the height of the texture subimage.</param>
    /// <param name="depth">Specifies the depth of the texture subimage.</param>
    /// <param name="bufSize">Specifies the size in basic machine units of the buffer addressed by pixels.</param>
    /// <returns>The pixel data.</returns>
    public byte[] glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize) { byte[] pixels
 = new byte[bufSize]; fixed (void* ptr_pixels =
 &pixels[0]) _glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, ptr_pixels); return pixels; }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate GLenum PFNGLGETGRAPHICSRESETSTATUSPROC();
    private PFNGLGETGRAPHICSRESETSTATUSPROC _glGetGraphicsResetStatus;
    /// <summary>
    /// Return the reset status of the specified reset target.
    /// </summary>
    /// <returns>The reset status of the specified reset target.</returns>
    public GLenum glGetGraphicsResetStatus() => _glGetGraphicsResetStatus();

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNCOMPRESSEDTEXIMAGEPROC(GLenum target, GLint lod, GLsizei bufSize, void* pixels);
    private PFNGLGETNCOMPRESSEDTEXIMAGEPROC _glGetnCompressedTexImage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return a compressed texture image.
    /// </summary>
    /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.</param>
    /// <param name="lod">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="bufSize">Specifies the size in basic machine units of the buffer addressed by pixels.</param>
    /// <param name="pixels">Specifies a pointer to the buffer into which to place the returned pixel data.</param>
    public void glGetnCompressedTexImage(GLenum target, GLint lod, GLsizei bufSize, void* pixels) => _glGetnCompressedTexImage(target, lod, bufSize, pixels);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return a compressed texture image.
    /// </summary>
    /// <param name="target">Specifies the target texture.</param>
    /// <param name="lod">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="bufSize">Specifies the maximum amount of bytes to return.</param>
    /// <returns>The pixel data.</returns>
    public byte[] glGetnCompressedTexImage(GLenum target, GLint lod, GLsizei bufSize) { byte[] pixels = new byte[bufSize]; fixed (void* ptr_pixels =
 &pixels[0]) _glGetnCompressedTexImage(target, lod, bufSize, ptr_pixels); return pixels; }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNTEXIMAGEPROC(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
    private PFNGLGETNTEXIMAGEPROC _glGetnTexImage;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return a texture image.
    /// </summary>
    /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="bufSize">Specifies the size in basic machine units of the buffer addressed by pixels.</param>
    /// <param name="pixels">Specifies a pointer to the buffer into which to place the returned pixel data.</param>
    public void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels) => _glGetnTexImage(target, level, format, type, bufSize, pixels);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return a texture image.
    /// </summary>
    /// <param name="target">Specifies the target texture.</param>
    /// <param name="level">Specifies the level-of-detail number of the desired image.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="bufSize">Specifies the maximum amount of bytes to return.</param>
    /// <returns>The pixel data.</returns>
    public byte[] glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize) { byte[] pixels =
 new byte[bufSize]; fixed (void* ptr_pixels = &pixels[0]) _glGetnTexImage(target, level, format, type, bufSize, ptr_pixels); return pixels; }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNUNIFORMDVPROC(GLuint program, GLint location, GLsizei bufSize, GLdouble* parameters);
    private PFNGLGETNUNIFORMDVPROC _glGetnUniformdv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return a double-precision uniform variable from the specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the uniform variable location to be queried.</param>
    /// <param name="bufSize">Specifies the maximum number of double-precision floating-point values that may be written to params.</param>
    /// <param name="parameters">Specifies the address of a variable into which the double-precision floating-point values are written.</param>
    public void glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble* parameters) => _glGetnUniformdv(program, location, bufSize, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return a double-precision uniform variable from the specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the uniform variable location to be queried.</param>
    /// <param name="bufSize">Specifies the maximum number of double-precision floating-point values that may be written to params.</param>
    /// <param name="parameters">Specifies an array into which the double-precision floating-point values are written.</param>
    public void glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, ref GLdouble[] parameters) { fixed (void* ptr_parameters =
 &parameters[0]) _glGetnUniformdv(program, location, bufSize, (GLdouble*)ptr_parameters); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNUNIFORMFVPROC(GLuint program, GLint location, GLsizei bufSize, GLfloat* parameters);
    private PFNGLGETNUNIFORMFVPROC _glGetnUniformfv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return a float uniform variable from the specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the uniform variable location to be queried.</param>
    /// <param name="bufSize">Specifies the maximum number of float values that may be written to params.</param>
    /// <param name="parameters">Specifies the address of a variable into which the float values are written.</param>
    public void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat* parameters) => _glGetnUniformfv(program, location, bufSize, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return a float uniform variable from the specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the uniform variable location to be queried.</param>
    /// <param name="bufSize">Specifies the maximum number of float values that may be written to params.</param>
    /// <param name="parameters">Specifies an array into which the float values are written.</param>
    public void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, ref GLfloat[] parameters) { fixed (void* ptr_parameters =
 &parameters[0]) _glGetnUniformfv(program, location, bufSize, (GLfloat*)ptr_parameters); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNUNIFORMIVPROC(GLuint program, GLint location, GLsizei bufSize, GLint* parameters);
    private PFNGLGETNUNIFORMIVPROC _glGetnUniformiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return an integer uniform variable from the specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the uniform variable location to be queried.</param>
    /// <param name="bufSize">Specifies the maximum number of integer values that may be written to params.</param>
    /// <param name="parameters">Specifies the address of a variable into which the integer values are written.</param>
    public void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint* parameters) => _glGetnUniformiv(program, location, bufSize, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return an integer uniform variable from the specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the uniform variable location to be queried.</param>
    /// <param name="bufSize">Specifies the maximum number of integer values that may be written to params.</param>
    /// <param name="parameters">Specifies an array into which the integer values are written.</param>
    public void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, ref GLint[] parameters) { fixed (void* ptr_parameters =
 &parameters[0]) _glGetnUniformiv(program, location, bufSize, (GLint*)ptr_parameters); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLGETNUNIFORMUIVPROC(GLuint program, GLint location, GLsizei bufSize, GLuint* parameters);
    private PFNGLGETNUNIFORMUIVPROC _glGetnUniformuiv;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Return an unsigned integer uniform variable from the specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the uniform variable location to be queried.</param>
    /// <param name="bufSize">Specifies the maximum number of unsigned integer values that may be written to params.</param>
    /// <param name="parameters">Specifies the address of a variable into which the unsigned integer values are written.</param>
    public void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint* parameters) => _glGetnUniformuiv(program, location, bufSize, parameters);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Return an unsigned integer uniform variable from the specified program object.
    /// </summary>
    /// <param name="program">Specifies the program object to be queried.</param>
    /// <param name="location">Specifies the uniform variable location to be queried.</param>
    /// <param name="bufSize">Specifies the maximum number of unsigned integer values that may be written to params.</param>
    /// <param name="parameters">Specifies an array into which the unsigned integer values are written.</param>
    public void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, ref GLuint[] parameters) { fixed (void* ptr_parameters =
 &parameters[0]) _glGetnUniformuiv(program, location, bufSize, (GLuint*)ptr_parameters); }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLREADNPIXELSPROC(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
    private PFNGLREADNPIXELSPROC _glReadnPixels;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Read a block of pixels from the frame buffer.
    /// </summary>
    /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
    /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
    /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
    /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="bufSize">Specifies the size in bytes of the buffer pointed to by data.</param>
    /// <param name="data">Returns the pixel data.</param>
    public void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) => _glReadnPixels(x, y, width, height, format, type, bufSize, data);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Read a block of pixels from the frame buffer.
    /// </summary>
    /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
    /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
    /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
    /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
    /// <param name="format">Specifies the format of the pixel data.</param>
    /// <param name="type">Specifies the data type of the pixel data.</param>
    /// <param name="bufSize">Specifies the maximum amount of bytes to be returned.</param>
    /// <returns>Returns the pixel data.</returns>
    public byte[] glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize) { byte[] data =
 new byte[bufSize]; fixed (void* ptr_data = &data[0]) _glReadnPixels(x, y, width, height, format, type, bufSize, ptr_data); return data; }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLTEXTUREBARRIERPROC();
    private PFNGLTEXTUREBARRIERPROC _glTextureBarrier;
    /// <summary>
    /// Insert a memory barrier to ensure that texture writes have completed.
    /// </summary>
    public void glTextureBarrier() => _glTextureBarrier();

#endif

    // OpenGL 4.6

#if OGL_V_4_6
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLSPECIALIZESHADERPROC(GLuint shader, GLchar* pEntryPoint, GLuint numSpecializationConstants, GLuint* pConstantIndex, GLuint* pConstantValue);
    private PFNGLSPECIALIZESHADERPROC _glSpecializeShader;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Specialize a shader.
    /// </summary>
    /// <param name="shader">Specifies the shader to be specialized.</param>
    /// <param name="pEntryPoint">Specifies the entry point name of the shader.</param>
    /// <param name="numSpecializationConstants">Specifies the number of elements in the pConstantIndex and pConstantValue arrays.</param>
    /// <param name="pConstantIndex">Specifies the index of each specialization constant to be set.</param>
    /// <param name="pConstantValue">Specifies the value of each specialization constant to be set.</param>
    public void glSpecializeShader(GLuint shader, GLchar* pEntryPoint, GLuint numSpecializationConstants, GLuint* pConstantIndex, GLuint* pConstantValue) => _glSpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Specialize a shader.
    /// </summary>
    /// <param name="shader">Specifies the shader to be specialized.</param>
    /// <param name="pEntryPoint">Specifies the entry point name of the shader.</param>
    /// <param name="numSpecializationConstants">Specifies the number of elements in the pConstantIndex and pConstantValue arrays.</param>
    /// <param name="pConstantIndex">Specifies the index of each specialization constant to be set.</param>
    /// <param name="pConstantValue">Specifies the value of each specialization constant to be set.</param>
    public void glSpecializeShader(GLuint shader, string pEntryPoint, GLuint numSpecializationConstants, GLuint[] pConstantIndex, GLuint[] pConstantValue)
    {
        GLchar[] pEntryPointBytes = Encoding.UTF8.GetBytes(pEntryPoint);
        fixed (GLchar* ptr_pEntryPoint = &pEntryPointBytes[0])
        fixed (GLuint* ptr_pConstantIndex = &pConstantIndex[0])
        fixed (GLuint* ptr_pConstantValue = &pConstantValue[0])
            _glSpecializeShader(shader, ptr_pEntryPoint, numSpecializationConstants, ptr_pConstantIndex, ptr_pConstantValue);
    }
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC(GLenum mode, void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
    private PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC _glMultiDrawArraysIndirectCount;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render multiple sets of primitives from array data, taking parameters from memory.
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="indirect">Specifies the address of an array of DrawArraysIndirectCommand structures.</param>
    /// <param name="drawcount">Specifies the address of an integer containing the maximum number of elements that will be written to the buffer.</param>
    /// <param name="maxdrawcount">Specifies the address of an integer containing the maximum number of elements that will be written to the buffer.</param>
    /// <param name="stride">Specifies the distance in basic machine units between elements of the array of indirect.</param>
    public void glMultiDrawArraysIndirectCount(GLenum mode, void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) => _glMultiDrawArraysIndirectCount(mode, indirect, drawcount, maxdrawcount, stride);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render multiple sets of primitives from array data, taking parameters from memory.
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="indirect">Specifies the address of an array of DrawArraysIndirectCommand structures.</param>
    /// <param name="drawcount">Specifies the address of an integer containing the maximum number of elements that will be written to the buffer.</param>
    /// <param name="maxdrawcount">Specifies the address of an integer containing the maximum number of elements that will be written to the buffer.</param>
    /// <param name="stride">Specifies the distance in basic machine units between elements of the array of indirect.</param>
    public void glMultiDrawArraysIndirectCount(GLenum mode, DrawArraysIndirectCommand indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) => _glMultiDrawArraysIndirectCount(mode, &indirect, drawcount, maxdrawcount, stride);
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC(GLenum mode, GLenum type, void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
    private PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC _glMultiDrawElementsIndirectCount;
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_UNSAFE
    /// <summary>
    /// Render multiple sets of primitives by specifying indices of array data elements.
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="type">Specifies the type of the values in indirect.</param>
    /// <param name="indirect">Specifies the address of an array of DrawElementsIndirectCommand structures.</param>
    /// <param name="drawcount">Specifies the address of an integer containing the maximum number of elements that will be written to the buffer.</param>
    /// <param name="maxdrawcount">Specifies the address of an integer containing the maximum number of elements that will be written to the buffer.</param>
    /// <param name="stride">Specifies the distance in basic machine units between elements of the array of indirect.</param>
    public void glMultiDrawElementsIndirectCount(GLenum mode, GLenum type, void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) => _glMultiDrawElementsIndirectCount(mode, type, indirect, drawcount, maxdrawcount, stride);
#endif
#if OGL_WRAPPER_API_BOTH || OGL_WRAPPER_API_SAFE
    /// <summary>
    /// Render multiple sets of primitives by specifying indices of array data elements.
    /// </summary>
    /// <param name="mode">Specifies what kind of primitives to render.</param>
    /// <param name="type">Specifies the type of the values in indirect.</param>
    /// <param name="indirect">Specifies the address of an array of DrawElementsIndirectCommand structures.</param>
    /// <param name="drawcount">Specifies the address of an integer containing the maximum number of elements that will be written to the buffer.</param>
    /// <param name="maxdrawcount">Specifies the address of an integer containing the maximum number of elements that will be written to the buffer.</param>
    /// <param name="stride">Specifies the distance in basic machine units between elements of the array of indirect.</param>
    public void glMultiDrawElementsIndirectCount(GLenum mode, GLenum type, DrawElementsIndirectCommand indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) => _glMultiDrawElementsIndirectCount(mode, type, &indirect, drawcount, maxdrawcount, stride);
#endif

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private delegate void PFNGLPOLYGONOFFSETCLAMPPROC(GLfloat factor, GLfloat units, GLfloat clamp);
    private PFNGLPOLYGONOFFSETCLAMPPROC _glPolygonOffsetClamp;
    /// <summary>
    /// Controls the parameters of polygon offset.
    /// </summary>
    /// <param name="factor">Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.</param>
    /// <param name="units">Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.</param>
    /// <param name="clamp">Specifies the maximum (or minimum) depth clamping value. The initial value is 0.</param>
    public void glPolygonOffsetClamp(GLfloat factor, GLfloat units, GLfloat clamp) => _glPolygonOffsetClamp(factor, units, clamp);

#endif

    /// <summary>
    /// Loads OpenGL functions using the specified loader delegate.
    /// </summary>
    public void Import( GetProcAddressHandler loader )
    {
#if OGL_V_1_0 || OGL_V_1_1 || OGL_V_1_2 || OGL_V_1_3 || OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glCullFace               = Marshal.GetDelegateForFunctionPointer< PFNGLCULLFACEPROC >( loader.Invoke( "glCullFace" ) );
        _glFrontFace              = Marshal.GetDelegateForFunctionPointer< PFNGLFRONTFACEPROC >( loader.Invoke( "glFrontFace" ) );
        _glHint                   = Marshal.GetDelegateForFunctionPointer< PFNGLHINTPROC >( loader.Invoke( "glHint" ) );
        _glLineWidth              = Marshal.GetDelegateForFunctionPointer< PFNGLLINEWIDTHPROC >( loader.Invoke( "glLineWidth" ) );
        _glPointSize              = Marshal.GetDelegateForFunctionPointer< PFNGLPOINTSIZEPROC >( loader.Invoke( "glPointSize" ) );
        _glPolygonMode            = Marshal.GetDelegateForFunctionPointer< PFNGLPOLYGONMODEPROC >( loader.Invoke( "glPolygonMode" ) );
        _glScissor                = Marshal.GetDelegateForFunctionPointer< PFNGLSCISSORPROC >( loader.Invoke( "glScissor" ) );
        _glTexParameterf          = Marshal.GetDelegateForFunctionPointer< PFNGLTEXPARAMETERFPROC >( loader.Invoke( "glTexParameterf" ) );
        _glTexParameterfv         = Marshal.GetDelegateForFunctionPointer< PFNGLTEXPARAMETERFVPROC >( loader.Invoke( "glTexParameterfv" ) );
        _glTexParameteri          = Marshal.GetDelegateForFunctionPointer< PFNGLTEXPARAMETERIPROC >( loader.Invoke( "glTexParameteri" ) );
        _glTexParameteriv         = Marshal.GetDelegateForFunctionPointer< PFNGLTEXPARAMETERIVPROC >( loader.Invoke( "glTexParameteriv" ) );
        _glTexImage1D             = Marshal.GetDelegateForFunctionPointer< PFNGLTEXIMAGE1DPROC >( loader.Invoke( "glTexImage1D" ) );
        _glTexImage2D             = Marshal.GetDelegateForFunctionPointer< PFNGLTEXIMAGE2DPROC >( loader.Invoke( "glTexImage2D" ) );
        _glDrawBuffer             = Marshal.GetDelegateForFunctionPointer< PFNGLDRAWBUFFERPROC >( loader.Invoke( "glDrawBuffer" ) );
        _glClear                  = Marshal.GetDelegateForFunctionPointer< PFNGLCLEARPROC >( loader.Invoke( "glClear" ) );
        _glClearColor             = Marshal.GetDelegateForFunctionPointer< PFNGLCLEARCOLORPROC >( loader.Invoke( "glClearColor" ) );
        _glClearStencil           = Marshal.GetDelegateForFunctionPointer< PFNGLCLEARSTENCILPROC >( loader.Invoke( "glClearStencil" ) );
        _glClearDepth             = Marshal.GetDelegateForFunctionPointer< PFNGLCLEARDEPTHPROC >( loader.Invoke( "glClearDepth" ) );
        _glStencilMask            = Marshal.GetDelegateForFunctionPointer< PFNGLSTENCILMASKPROC >( loader.Invoke( "glStencilMask" ) );
        _glColorMask              = Marshal.GetDelegateForFunctionPointer< PFNGLCOLORMASKPROC >( loader.Invoke( "glColorMask" ) );
        _glDepthMask              = Marshal.GetDelegateForFunctionPointer< PFNGLDEPTHMASKPROC >( loader.Invoke( "glDepthMask" ) );
        _glDisable                = Marshal.GetDelegateForFunctionPointer< PFNGLDISABLEPROC >( loader.Invoke( "glDisable" ) );
        _glEnable                 = Marshal.GetDelegateForFunctionPointer< PFNGLENABLEPROC >( loader.Invoke( "glEnable" ) );
        _glFinish                 = Marshal.GetDelegateForFunctionPointer< PFNGLFINISHPROC >( loader.Invoke( "glFinish" ) );
        _glFlush                  = Marshal.GetDelegateForFunctionPointer< PFNGLFLUSHPROC >( loader.Invoke( "glFlush" ) );
        _glBlendFunc              = Marshal.GetDelegateForFunctionPointer< PFNGLBLENDFUNCPROC >( loader.Invoke( "glBlendFunc" ) );
        _glLogicOp                = Marshal.GetDelegateForFunctionPointer< PFNGLLOGICOPPROC >( loader.Invoke( "glLogicOp" ) );
        _glStencilFunc            = Marshal.GetDelegateForFunctionPointer< PFNGLSTENCILFUNCPROC >( loader.Invoke( "glStencilFunc" ) );
        _glStencilOp              = Marshal.GetDelegateForFunctionPointer< PFNGLSTENCILOPPROC >( loader.Invoke( "glStencilOp" ) );
        _glDepthFunc              = Marshal.GetDelegateForFunctionPointer< PFNGLDEPTHFUNCPROC >( loader.Invoke( "glDepthFunc" ) );
        _glPixelStoref            = Marshal.GetDelegateForFunctionPointer< PFNGLPIXELSTOREFPROC >( loader.Invoke( "glPixelStoref" ) );
        _glPixelStorei            = Marshal.GetDelegateForFunctionPointer< PFNGLPIXELSTOREIPROC >( loader.Invoke( "glPixelStorei" ) );
        _glReadBuffer             = Marshal.GetDelegateForFunctionPointer< PFNGLREADBUFFERPROC >( loader.Invoke( "glReadBuffer" ) );
        _glReadPixels             = Marshal.GetDelegateForFunctionPointer< PFNGLREADPIXELSPROC >( loader.Invoke( "glReadPixels" ) );
        _glGetBooleanv            = Marshal.GetDelegateForFunctionPointer< PFNGLGETBOOLEANVPROC >( loader.Invoke( "glGetBooleanv" ) );
        _glGetDoublev             = Marshal.GetDelegateForFunctionPointer< PFNGLGETDOUBLEVPROC >( loader.Invoke( "glGetDoublev" ) );
        _glGetError               = Marshal.GetDelegateForFunctionPointer< PFNGLGETERRORPROC >( loader.Invoke( "glGetError" ) );
        _glGetFloatv              = Marshal.GetDelegateForFunctionPointer< PFNGLGETFLOATVPROC >( loader.Invoke( "glGetFloatv" ) );
        _glGetIntegerv            = Marshal.GetDelegateForFunctionPointer< PFNGLGETINTEGERVPROC >( loader.Invoke( "glGetIntegerv" ) );
        _glGetString              = Marshal.GetDelegateForFunctionPointer< PFNGLGETSTRINGPROC >( loader.Invoke( "glGetString" ) );
        _glGetTexImage            = Marshal.GetDelegateForFunctionPointer< PFNGLGETTEXIMAGEPROC >( loader.Invoke( "glGetTexImage" ) );
        _glGetTexParameterfv      = Marshal.GetDelegateForFunctionPointer< PFNGLGETTEXPARAMETERFVPROC >( loader.Invoke( "glGetTexParameterfv" ) );
        _glGetTexParameteriv      = Marshal.GetDelegateForFunctionPointer< PFNGLGETTEXPARAMETERIVPROC >( loader.Invoke( "glGetTexParameteriv" ) );
        _glGetTexLevelParameterfv = Marshal.GetDelegateForFunctionPointer< PFNGLGETTEXLEVELPARAMETERFVPROC >( loader.Invoke( "glGetTexLevelParameterfv" ) );
        _glGetTexLevelParameteriv = Marshal.GetDelegateForFunctionPointer< PFNGLGETTEXLEVELPARAMETERIVPROC >( loader.Invoke( "glGetTexLevelParameteriv" ) );
        _glIsEnabled              = Marshal.GetDelegateForFunctionPointer< PFNGLISENABLEDPROC >( loader.Invoke( "glIsEnabled" ) );
        _glDepthRange             = Marshal.GetDelegateForFunctionPointer< PFNGLDEPTHRANGEPROC >( loader.Invoke( "glDepthRange" ) );
        _glViewport               = Marshal.GetDelegateForFunctionPointer< PFNGLVIEWPORTPROC >( loader.Invoke( "glViewport" ) );
#endif
#if OGL_V_1_1 || OGL_V_1_2 || OGL_V_1_3 || OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glDrawArrays        = Marshal.GetDelegateForFunctionPointer< PFNGLDRAWARRAYSPROC >( loader.Invoke( "glDrawArrays" ) );
        _glDrawElements      = Marshal.GetDelegateForFunctionPointer< PFNGLDRAWELEMENTSPROC >( loader.Invoke( "glDrawElements" ) );
        _glPolygonOffset     = Marshal.GetDelegateForFunctionPointer< PFNGLPOLYGONOFFSETPROC >( loader.Invoke( "glPolygonOffset" ) );
        _glCopyTexImage1D    = Marshal.GetDelegateForFunctionPointer< PFNGLCOPYTEXIMAGE1DPROC >( loader.Invoke( "glCopyTexImage1D" ) );
        _glCopyTexImage2D    = Marshal.GetDelegateForFunctionPointer< PFNGLCOPYTEXIMAGE2DPROC >( loader.Invoke( "glCopyTexImage2D" ) );
        _glCopyTexSubImage1D = Marshal.GetDelegateForFunctionPointer< PFNGLCOPYTEXSUBIMAGE1DPROC >( loader.Invoke( "glCopyTexSubImage1D" ) );
        _glCopyTexSubImage2D = Marshal.GetDelegateForFunctionPointer< PFNGLCOPYTEXSUBIMAGE2DPROC >( loader.Invoke( "glCopyTexSubImage2D" ) );
        _glTexSubImage1D     = Marshal.GetDelegateForFunctionPointer< PFNGLTEXSUBIMAGE1DPROC >( loader.Invoke( "glTexSubImage1D" ) );
        _glTexSubImage2D     = Marshal.GetDelegateForFunctionPointer< PFNGLTEXSUBIMAGE2DPROC >( loader.Invoke( "glTexSubImage2D" ) );
        _glBindTexture       = Marshal.GetDelegateForFunctionPointer< PFNGLBINDTEXTUREPROC >( loader.Invoke( "glBindTexture" ) );
        _glDeleteTextures    = Marshal.GetDelegateForFunctionPointer< PFNGLDELETETEXTURESPROC >( loader.Invoke( "glDeleteTextures" ) );
        _glGenTextures       = Marshal.GetDelegateForFunctionPointer< PFNGLGENTEXTURESPROC >( loader.Invoke( "glGenTextures" ) );
        _glIsTexture         = Marshal.GetDelegateForFunctionPointer< PFNGLISTEXTUREPROC >( loader.Invoke( "glIsTexture" ) );
#endif
#if OGL_V_1_2 || OGL_V_1_3 || OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glDrawRangeElements = Marshal.GetDelegateForFunctionPointer< PFNGLDRAWRANGEELEMENTSPROC >( loader.Invoke( "glDrawRangeElements" ) );
        _glTexImage3D        = Marshal.GetDelegateForFunctionPointer< PFNGLTEXIMAGE3DPROC >( loader.Invoke( "glTexImage3D" ) );
        _glTexSubImage3D     = Marshal.GetDelegateForFunctionPointer< PFNGLTEXSUBIMAGE3DPROC >( loader.Invoke( "glTexSubImage3D" ) );
        _glCopyTexSubImage3D = Marshal.GetDelegateForFunctionPointer< PFNGLCOPYTEXSUBIMAGE3DPROC >( loader.Invoke( "glCopyTexSubImage3D" ) );
#endif
#if OGL_V_1_3 || OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glActiveTexture           = Marshal.GetDelegateForFunctionPointer< PFNGLACTIVETEXTUREPROC >( loader.Invoke( "glActiveTexture" ) );
        _glSampleCoverage          = Marshal.GetDelegateForFunctionPointer< PFNGLSAMPLECOVERAGEPROC >( loader.Invoke( "glSampleCoverage" ) );
        _glCompressedTexImage3D    = Marshal.GetDelegateForFunctionPointer< PFNGLCOMPRESSEDTEXIMAGE3DPROC >( loader.Invoke( "glCompressedTexImage3D" ) );
        _glCompressedTexImage2D    = Marshal.GetDelegateForFunctionPointer< PFNGLCOMPRESSEDTEXIMAGE2DPROC >( loader.Invoke( "glCompressedTexImage2D" ) );
        _glCompressedTexImage1D    = Marshal.GetDelegateForFunctionPointer< PFNGLCOMPRESSEDTEXIMAGE1DPROC >( loader.Invoke( "glCompressedTexImage1D" ) );
        _glCompressedTexSubImage3D = Marshal.GetDelegateForFunctionPointer< PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC >( loader.Invoke( "glCompressedTexSubImage3D" ) );
        _glCompressedTexSubImage2D = Marshal.GetDelegateForFunctionPointer< PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC >( loader.Invoke( "glCompressedTexSubImage2D" ) );
        _glCompressedTexSubImage1D = Marshal.GetDelegateForFunctionPointer< PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC >( loader.Invoke( "glCompressedTexSubImage1D" ) );
        _glGetCompressedTexImage   = Marshal.GetDelegateForFunctionPointer< PFNGLGETCOMPRESSEDTEXIMAGEPROC >( loader.Invoke( "glGetCompressedTexImage" ) );
#endif
#if OGL_V_1_4 || OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glBlendFuncSeparate = Marshal.GetDelegateForFunctionPointer< PFNGLBLENDFUNCSEPARATEPROC >( loader.Invoke( "glBlendFuncSeparate" ) );
        _glMultiDrawArrays   = Marshal.GetDelegateForFunctionPointer< PFNGLMULTIDRAWARRAYSPROC >( loader.Invoke( "glMultiDrawArrays" ) );
        _glMultiDrawElements = Marshal.GetDelegateForFunctionPointer< PFNGLMULTIDRAWELEMENTSPROC >( loader.Invoke( "glMultiDrawElements" ) );
        _glPointParameterf   = Marshal.GetDelegateForFunctionPointer< PFNGLPOINTPARAMETERFPROC >( loader.Invoke( "glPointParameterf" ) );
        _glPointParameterfv  = Marshal.GetDelegateForFunctionPointer< PFNGLPOINTPARAMETERFVPROC >( loader.Invoke( "glPointParameterfv" ) );
        _glPointParameteri   = Marshal.GetDelegateForFunctionPointer< PFNGLPOINTPARAMETERIPROC >( loader.Invoke( "glPointParameteri" ) );
        _glPointParameteriv  = Marshal.GetDelegateForFunctionPointer< PFNGLPOINTPARAMETERIVPROC >( loader.Invoke( "glPointParameteriv" ) );
        _glBlendColor        = Marshal.GetDelegateForFunctionPointer< PFNGLBLENDCOLORPROC >( loader.Invoke( "glBlendColor" ) );
        _glBlendEquation     = Marshal.GetDelegateForFunctionPointer< PFNGLBLENDEQUATIONPROC >( loader.Invoke( "glBlendEquation" ) );
#endif
#if OGL_V_1_5 || OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glGenQueries           = Marshal.GetDelegateForFunctionPointer< PFNGLGENQUERIESPROC >( loader.Invoke( "glGenQueries" ) );
        _glDeleteQueries        = Marshal.GetDelegateForFunctionPointer< PFNGLDELETEQUERIESPROC >( loader.Invoke( "glDeleteQueries" ) );
        _glIsQuery              = Marshal.GetDelegateForFunctionPointer< PFNGLISQUERYPROC >( loader.Invoke( "glIsQuery" ) );
        _glBeginQuery           = Marshal.GetDelegateForFunctionPointer< PFNGLBEGINQUERYPROC >( loader.Invoke( "glBeginQuery" ) );
        _glEndQuery             = Marshal.GetDelegateForFunctionPointer< PFNGLENDQUERYPROC >( loader.Invoke( "glEndQuery" ) );
        _glGetQueryiv           = Marshal.GetDelegateForFunctionPointer< PFNGLGETQUERYIVPROC >( loader.Invoke( "glGetQueryiv" ) );
        _glGetQueryObjectiv     = Marshal.GetDelegateForFunctionPointer< PFNGLGETQUERYOBJECTIVPROC >( loader.Invoke( "glGetQueryObjectiv" ) );
        _glGetQueryObjectuiv    = Marshal.GetDelegateForFunctionPointer< PFNGLGETQUERYOBJECTUIVPROC >( loader.Invoke( "glGetQueryObjectuiv" ) );
        _glBindBuffer           = Marshal.GetDelegateForFunctionPointer< PFNGLBINDBUFFERPROC >( loader.Invoke( "glBindBuffer" ) );
        _glDeleteBuffers        = Marshal.GetDelegateForFunctionPointer< PFNGLDELETEBUFFERSPROC >( loader.Invoke( "glDeleteBuffers" ) );
        _glGenBuffers           = Marshal.GetDelegateForFunctionPointer< PFNGLGENBUFFERSPROC >( loader.Invoke( "glGenBuffers" ) );
        _glIsBuffer             = Marshal.GetDelegateForFunctionPointer< PFNGLISBUFFERPROC >( loader.Invoke( "glIsBuffer" ) );
        _glBufferData           = Marshal.GetDelegateForFunctionPointer< PFNGLBUFFERDATAPROC >( loader.Invoke( "glBufferData" ) );
        _glBufferSubData        = Marshal.GetDelegateForFunctionPointer< PFNGLBUFFERSUBDATAPROC >( loader.Invoke( "glBufferSubData" ) );
        _glGetBufferSubData     = Marshal.GetDelegateForFunctionPointer< PFNGLGETBUFFERSUBDATAPROC >( loader.Invoke( "glGetBufferSubData" ) );
        _glMapBuffer            = Marshal.GetDelegateForFunctionPointer< PFNGLMAPBUFFERPROC >( loader.Invoke( "glMapBuffer" ) );
        _glUnmapBuffer          = Marshal.GetDelegateForFunctionPointer< PFNGLUNMAPBUFFERPROC >( loader.Invoke( "glUnmapBuffer" ) );
        _glGetBufferParameteriv = Marshal.GetDelegateForFunctionPointer< PFNGLGETBUFFERPARAMETERIVPROC >( loader.Invoke( "glGetBufferParameteriv" ) );
        _glGetBufferPointerv    = Marshal.GetDelegateForFunctionPointer< PFNGLGETBUFFERPOINTERVPROC >( loader.Invoke( "glGetBufferPointerv" ) );
#endif
#if OGL_V_2_0 || OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glBlendEquationSeparate = Marshal.GetDelegateForFunctionPointer< PFNGLBLENDEQUATIONSEPARATEPROC >( loader.Invoke( "glBlendEquationSeparate" ) );
        _glDrawBuffers           = Marshal.GetDelegateForFunctionPointer< PFNGLDRAWBUFFERSPROC >( loader.Invoke( "glDrawBuffers" ) );
        _glStencilOpSeparate     = Marshal.GetDelegateForFunctionPointer< PFNGLSTENCILOPSEPARATEPROC >( loader.Invoke( "glStencilOpSeparate" ) );
        _glStencilFuncSeparate   = Marshal.GetDelegateForFunctionPointer< PFNGLSTENCILFUNCSEPARATEPROC >( loader.Invoke( "glStencilFuncSeparate" ) );
        _glStencilMaskSeparate   = Marshal.GetDelegateForFunctionPointer< PFNGLSTENCILMASKSEPARATEPROC >( loader.Invoke( "glStencilMaskSeparate" ) );
        _glAttachShader          = Marshal.GetDelegateForFunctionPointer< PFNGLATTACHSHADERPROC >( loader.Invoke( "glAttachShader" ) );
        _glBindAttribLocation    = Marshal.GetDelegateForFunctionPointer< PFNGLBINDATTRIBLOCATIONPROC >( loader.Invoke( "glBindAttribLocation" ) );
        _glCompileShader         = Marshal.GetDelegateForFunctionPointer< PFNGLCOMPILESHADERPROC >( loader.Invoke( "glCompileShader" ) );
        _glCreateProgram         = Marshal.GetDelegateForFunctionPointer< PFNGLCREATEPROGRAMPROC >( loader.Invoke( "glCreateProgram" ) );
        _glCreateShader          = Marshal.GetDelegateForFunctionPointer< PFNGLCREATESHADERPROC >( loader.Invoke( "glCreateShader" ) );
        _glDeleteProgram         = Marshal.GetDelegateForFunctionPointer< PFNGLDELETEPROGRAMPROC >( loader.Invoke( "glDeleteProgram" ) );
        _glDeleteShader          = Marshal.GetDelegateForFunctionPointer< PFNGLDELETESHADERPROC >( loader.Invoke( "glDeleteShader" ) );
        _glDetachShader          = Marshal.GetDelegateForFunctionPointer< PFNGLDETACHSHADERPROC >( loader.Invoke( "glDetachShader" ) );

        _glDisableVertexAttribArray
            = Marshal.GetDelegateForFunctionPointer< PFNGLDISABLEVERTEXATTRIBARRAYPROC >( loader.Invoke( "glDisableVertexAttribArray" ) );

        _glEnableVertexAttribArray = Marshal.GetDelegateForFunctionPointer< PFNGLENABLEVERTEXATTRIBARRAYPROC >( loader.Invoke( "glEnableVertexAttribArray" ) );
        _glGetActiveAttrib         = Marshal.GetDelegateForFunctionPointer< PFNGLGETACTIVEATTRIBPROC >( loader.Invoke( "glGetActiveAttrib" ) );
        _glGetActiveUniform        = Marshal.GetDelegateForFunctionPointer< PFNGLGETACTIVEUNIFORMPROC >( loader.Invoke( "glGetActiveUniform" ) );
        _glGetAttachedShaders      = Marshal.GetDelegateForFunctionPointer< PFNGLGETATTACHEDSHADERSPROC >( loader.Invoke( "glGetAttachedShaders" ) );
        _glGetAttribLocation       = Marshal.GetDelegateForFunctionPointer< PFNGLGETATTRIBLOCATIONPROC >( loader.Invoke( "glGetAttribLocation" ) );
        _glGetProgramiv            = Marshal.GetDelegateForFunctionPointer< PFNGLGETPROGRAMIVPROC >( loader.Invoke( "glGetProgramiv" ) );
        _glGetProgramInfoLog       = Marshal.GetDelegateForFunctionPointer< PFNGLGETPROGRAMINFOLOGPROC >( loader.Invoke( "glGetProgramInfoLog" ) );
        _glGetShaderiv             = Marshal.GetDelegateForFunctionPointer< PFNGLGETSHADERIVPROC >( loader.Invoke( "glGetShaderiv" ) );
        _glGetShaderInfoLog        = Marshal.GetDelegateForFunctionPointer< PFNGLGETSHADERINFOLOGPROC >( loader.Invoke( "glGetShaderInfoLog" ) );
        _glGetShaderSource         = Marshal.GetDelegateForFunctionPointer< PFNGLGETSHADERSOURCEPROC >( loader.Invoke( "glGetShaderSource" ) );
        _glGetUniformLocation      = Marshal.GetDelegateForFunctionPointer< PFNGLGETUNIFORMLOCATIONPROC >( loader.Invoke( "glGetUniformLocation" ) );
        _glGetUniformfv            = Marshal.GetDelegateForFunctionPointer< PFNGLGETUNIFORMFVPROC >( loader.Invoke( "glGetUniformfv" ) );
        _glGetUniformiv            = Marshal.GetDelegateForFunctionPointer< PFNGLGETUNIFORMIVPROC >( loader.Invoke( "glGetUniformiv" ) );
        _glGetVertexAttribdv       = Marshal.GetDelegateForFunctionPointer< PFNGLGETVERTEXATTRIBDVPROC >( loader.Invoke( "glGetVertexAttribdv" ) );
        _glGetVertexAttribfv       = Marshal.GetDelegateForFunctionPointer< PFNGLGETVERTEXATTRIBFVPROC >( loader.Invoke( "glGetVertexAttribfv" ) );
        _glGetVertexAttribiv       = Marshal.GetDelegateForFunctionPointer< PFNGLGETVERTEXATTRIBIVPROC >( loader.Invoke( "glGetVertexAttribiv" ) );
        _glGetVertexAttribPointerv = Marshal.GetDelegateForFunctionPointer< PFNGLGETVERTEXATTRIBPOINTERVPROC >( loader.Invoke( "glGetVertexAttribPointerv" ) );
        _glIsProgram               = Marshal.GetDelegateForFunctionPointer< PFNGLISPROGRAMPROC >( loader.Invoke( "glIsProgram" ) );
        _glIsShader                = Marshal.GetDelegateForFunctionPointer< PFNGLISSHADERPROC >( loader.Invoke( "glIsShader" ) );
        _glLinkProgram             = Marshal.GetDelegateForFunctionPointer< PFNGLLINKPROGRAMPROC >( loader.Invoke( "glLinkProgram" ) );
        _glShaderSource            = Marshal.GetDelegateForFunctionPointer< PFNGLSHADERSOURCEPROC >( loader.Invoke( "glShaderSource" ) );
        _glUseProgram              = Marshal.GetDelegateForFunctionPointer< PFNGLUSEPROGRAMPROC >( loader.Invoke( "glUseProgram" ) );
        _glUniform1f               = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM1FPROC >( loader.Invoke( "glUniform1f" ) );
        _glUniform2f               = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM2FPROC >( loader.Invoke( "glUniform2f" ) );
        _glUniform3f               = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM3FPROC >( loader.Invoke( "glUniform3f" ) );
        _glUniform4f               = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM4FPROC >( loader.Invoke( "glUniform4f" ) );
        _glUniform1i               = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM1IPROC >( loader.Invoke( "glUniform1i" ) );
        _glUniform2i               = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM2IPROC >( loader.Invoke( "glUniform2i" ) );
        _glUniform3i               = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM3IPROC >( loader.Invoke( "glUniform3i" ) );
        _glUniform4i               = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM4IPROC >( loader.Invoke( "glUniform4i" ) );
        _glUniform1fv              = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM1FVPROC >( loader.Invoke( "glUniform1fv" ) );
        _glUniform2fv              = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM2FVPROC >( loader.Invoke( "glUniform2fv" ) );
        _glUniform3fv              = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM3FVPROC >( loader.Invoke( "glUniform3fv" ) );
        _glUniform4fv              = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM4FVPROC >( loader.Invoke( "glUniform4fv" ) );
        _glUniform1iv              = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM1IVPROC >( loader.Invoke( "glUniform1iv" ) );
        _glUniform2iv              = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM2IVPROC >( loader.Invoke( "glUniform2iv" ) );
        _glUniform3iv              = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM3IVPROC >( loader.Invoke( "glUniform3iv" ) );
        _glUniform4iv              = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM4IVPROC >( loader.Invoke( "glUniform4iv" ) );
        _glUniformMatrix2fv        = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORMMATRIX2FVPROC >( loader.Invoke( "glUniformMatrix2fv" ) );
        _glUniformMatrix3fv        = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORMMATRIX3FVPROC >( loader.Invoke( "glUniformMatrix3fv" ) );
        _glUniformMatrix4fv        = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORMMATRIX4FVPROC >( loader.Invoke( "glUniformMatrix4fv" ) );
        _glValidateProgram         = Marshal.GetDelegateForFunctionPointer< PFNGLVALIDATEPROGRAMPROC >( loader.Invoke( "glValidateProgram" ) );
        _glVertexAttrib1d          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB1DPROC >( loader.Invoke( "glVertexAttrib1d" ) );
        _glVertexAttrib1dv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB1DVPROC >( loader.Invoke( "glVertexAttrib1dv" ) );
        _glVertexAttrib1f          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB1FPROC >( loader.Invoke( "glVertexAttrib1f" ) );
        _glVertexAttrib1fv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB1FVPROC >( loader.Invoke( "glVertexAttrib1fv" ) );
        _glVertexAttrib1s          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB1SPROC >( loader.Invoke( "glVertexAttrib1s" ) );
        _glVertexAttrib1sv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB1SVPROC >( loader.Invoke( "glVertexAttrib1sv" ) );
        _glVertexAttrib2d          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB2DPROC >( loader.Invoke( "glVertexAttrib2d" ) );
        _glVertexAttrib2dv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB2DVPROC >( loader.Invoke( "glVertexAttrib2dv" ) );
        _glVertexAttrib2f          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB2FPROC >( loader.Invoke( "glVertexAttrib2f" ) );
        _glVertexAttrib2fv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB2FVPROC >( loader.Invoke( "glVertexAttrib2fv" ) );
        _glVertexAttrib2s          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB2SPROC >( loader.Invoke( "glVertexAttrib2s" ) );
        _glVertexAttrib2sv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB2SVPROC >( loader.Invoke( "glVertexAttrib2sv" ) );
        _glVertexAttrib3d          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB3DPROC >( loader.Invoke( "glVertexAttrib3d" ) );
        _glVertexAttrib3dv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB3DVPROC >( loader.Invoke( "glVertexAttrib3dv" ) );
        _glVertexAttrib3f          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB3FPROC >( loader.Invoke( "glVertexAttrib3f" ) );
        _glVertexAttrib3fv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB3FVPROC >( loader.Invoke( "glVertexAttrib3fv" ) );
        _glVertexAttrib3s          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB3SPROC >( loader.Invoke( "glVertexAttrib3s" ) );
        _glVertexAttrib3sv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB3SVPROC >( loader.Invoke( "glVertexAttrib3sv" ) );
        _glVertexAttrib4Nbv        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4NBVPROC >( loader.Invoke( "glVertexAttrib4Nbv" ) );
        _glVertexAttrib4Niv        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4NIVPROC >( loader.Invoke( "glVertexAttrib4Niv" ) );
        _glVertexAttrib4Nsv        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4NSVPROC >( loader.Invoke( "glVertexAttrib4Nsv" ) );
        _glVertexAttrib4Nub        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4NUBPROC >( loader.Invoke( "glVertexAttrib4Nub" ) );
        _glVertexAttrib4Nubv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4NUBVPROC >( loader.Invoke( "glVertexAttrib4Nubv" ) );
        _glVertexAttrib4Nuiv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4NUIVPROC >( loader.Invoke( "glVertexAttrib4Nuiv" ) );
        _glVertexAttrib4Nusv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4NUSVPROC >( loader.Invoke( "glVertexAttrib4Nusv" ) );
        _glVertexAttrib4bv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4BVPROC >( loader.Invoke( "glVertexAttrib4bv" ) );
        _glVertexAttrib4d          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4DPROC >( loader.Invoke( "glVertexAttrib4d" ) );
        _glVertexAttrib4dv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4DVPROC >( loader.Invoke( "glVertexAttrib4dv" ) );
        _glVertexAttrib4f          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4FPROC >( loader.Invoke( "glVertexAttrib4f" ) );
        _glVertexAttrib4fv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4FVPROC >( loader.Invoke( "glVertexAttrib4fv" ) );
        _glVertexAttrib4iv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4IVPROC >( loader.Invoke( "glVertexAttrib4iv" ) );
        _glVertexAttrib4s          = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4SPROC >( loader.Invoke( "glVertexAttrib4s" ) );
        _glVertexAttrib4sv         = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4SVPROC >( loader.Invoke( "glVertexAttrib4sv" ) );
        _glVertexAttrib4ubv        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4UBVPROC >( loader.Invoke( "glVertexAttrib4ubv" ) );
        _glVertexAttrib4uiv        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4UIVPROC >( loader.Invoke( "glVertexAttrib4uiv" ) );
        _glVertexAttrib4usv        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIB4USVPROC >( loader.Invoke( "glVertexAttrib4usv" ) );
        _glVertexAttribPointer     = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBPOINTERPROC >( loader.Invoke( "glVertexAttribPointer" ) );
#endif
#if OGL_V_2_1 || OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glUniformMatrix2x3fv = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORMMATRIX2X3FVPROC >( loader.Invoke( "glUniformMatrix2x3fv" ) );
        _glUniformMatrix3x2fv = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORMMATRIX3X2FVPROC >( loader.Invoke( "glUniformMatrix3x2fv" ) );
        _glUniformMatrix2x4fv = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORMMATRIX2X4FVPROC >( loader.Invoke( "glUniformMatrix2x4fv" ) );
        _glUniformMatrix4x2fv = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORMMATRIX4X2FVPROC >( loader.Invoke( "glUniformMatrix4x2fv" ) );
        _glUniformMatrix3x4fv = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORMMATRIX3X4FVPROC >( loader.Invoke( "glUniformMatrix3x4fv" ) );
        _glUniformMatrix4x3fv = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORMMATRIX4X3FVPROC >( loader.Invoke( "glUniformMatrix4x3fv" ) );
#endif
#if OGL_V_3_0 || OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glColorMaski             = Marshal.GetDelegateForFunctionPointer< PFNGLCOLORMASKIPROC >( loader.Invoke( "glColorMaski" ) );
        _glGetBooleani_v          = Marshal.GetDelegateForFunctionPointer< PFNGLGETBOOLEANI_VPROC >( loader.Invoke( "glGetBooleani_v" ) );
        _glGetIntegeri_v          = Marshal.GetDelegateForFunctionPointer< PFNGLGETINTEGERI_VPROC >( loader.Invoke( "glGetIntegeri_v" ) );
        _glEnablei                = Marshal.GetDelegateForFunctionPointer< PFNGLENABLEIPROC >( loader.Invoke( "glEnablei" ) );
        _glDisablei               = Marshal.GetDelegateForFunctionPointer< PFNGLDISABLEIPROC >( loader.Invoke( "glDisablei" ) );
        _glIsEnabledi             = Marshal.GetDelegateForFunctionPointer< PFNGLISENABLEDIPROC >( loader.Invoke( "glIsEnabledi" ) );
        _glBeginTransformFeedback = Marshal.GetDelegateForFunctionPointer< PFNGLBEGINTRANSFORMFEEDBACKPROC >( loader.Invoke( "glBeginTransformFeedback" ) );
        _glEndTransformFeedback   = Marshal.GetDelegateForFunctionPointer< PFNGLENDTRANSFORMFEEDBACKPROC >( loader.Invoke( "glEndTransformFeedback" ) );
        _glBindBufferRange        = Marshal.GetDelegateForFunctionPointer< PFNGLBINDBUFFERRANGEPROC >( loader.Invoke( "glBindBufferRange" ) );
        _glBindBufferBase         = Marshal.GetDelegateForFunctionPointer< PFNGLBINDBUFFERBASEPROC >( loader.Invoke( "glBindBufferBase" ) );

        _glTransformFeedbackVaryings
            = Marshal.GetDelegateForFunctionPointer< PFNGLTRANSFORMFEEDBACKVARYINGSPROC >( loader.Invoke( "glTransformFeedbackVaryings" ) );

        _glGetTransformFeedbackVarying =
            Marshal.GetDelegateForFunctionPointer< PFNGLGETTRANSFORMFEEDBACKVARYINGPROC >( loader.Invoke( "glGetTransformFeedbackVarying" ) );

        _glClampColor             = Marshal.GetDelegateForFunctionPointer< PFNGLCLAMPCOLORPROC >( loader.Invoke( "glClampColor" ) );
        _glBeginConditionalRender = Marshal.GetDelegateForFunctionPointer< PFNGLBEGINCONDITIONALRENDERPROC >( loader.Invoke( "glBeginConditionalRender" ) );
        _glEndConditionalRender   = Marshal.GetDelegateForFunctionPointer< PFNGLENDCONDITIONALRENDERPROC >( loader.Invoke( "glEndConditionalRender" ) );
        _glVertexAttribIPointer   = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBIPOINTERPROC >( loader.Invoke( "glVertexAttribIPointer" ) );
        _glGetVertexAttribIiv     = Marshal.GetDelegateForFunctionPointer< PFNGLGETVERTEXATTRIBIIVPROC >( loader.Invoke( "glGetVertexAttribIiv" ) );
        _glGetVertexAttribIuiv    = Marshal.GetDelegateForFunctionPointer< PFNGLGETVERTEXATTRIBIUIVPROC >( loader.Invoke( "glGetVertexAttribIuiv" ) );
        _glVertexAttribI1i        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI1IPROC >( loader.Invoke( "glVertexAttribI1i" ) );
        _glVertexAttribI2i        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI2IPROC >( loader.Invoke( "glVertexAttribI2i" ) );
        _glVertexAttribI3i        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI3IPROC >( loader.Invoke( "glVertexAttribI3i" ) );
        _glVertexAttribI4i        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI4IPROC >( loader.Invoke( "glVertexAttribI4i" ) );
        _glVertexAttribI1ui       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI1UIPROC >( loader.Invoke( "glVertexAttribI1ui" ) );
        _glVertexAttribI2ui       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI2UIPROC >( loader.Invoke( "glVertexAttribI2ui" ) );
        _glVertexAttribI3ui       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI3UIPROC >( loader.Invoke( "glVertexAttribI3ui" ) );
        _glVertexAttribI4ui       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI4UIPROC >( loader.Invoke( "glVertexAttribI4ui" ) );
        _glVertexAttribI1iv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI1IVPROC >( loader.Invoke( "glVertexAttribI1iv" ) );
        _glVertexAttribI2iv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI2IVPROC >( loader.Invoke( "glVertexAttribI2iv" ) );
        _glVertexAttribI3iv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI3IVPROC >( loader.Invoke( "glVertexAttribI3iv" ) );
        _glVertexAttribI4iv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI4IVPROC >( loader.Invoke( "glVertexAttribI4iv" ) );
        _glVertexAttribI1uiv      = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI1UIVPROC >( loader.Invoke( "glVertexAttribI1uiv" ) );
        _glVertexAttribI2uiv      = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI2UIVPROC >( loader.Invoke( "glVertexAttribI2uiv" ) );
        _glVertexAttribI3uiv      = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI3UIVPROC >( loader.Invoke( "glVertexAttribI3uiv" ) );
        _glVertexAttribI4uiv      = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI4UIVPROC >( loader.Invoke( "glVertexAttribI4uiv" ) );
        _glVertexAttribI4bv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI4BVPROC >( loader.Invoke( "glVertexAttribI4bv" ) );
        _glVertexAttribI4sv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI4SVPROC >( loader.Invoke( "glVertexAttribI4sv" ) );
        _glVertexAttribI4ubv      = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI4UBVPROC >( loader.Invoke( "glVertexAttribI4ubv" ) );
        _glVertexAttribI4usv      = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBI4USVPROC >( loader.Invoke( "glVertexAttribI4usv" ) );
        _glGetUniformuiv          = Marshal.GetDelegateForFunctionPointer< PFNGLGETUNIFORMUIVPROC >( loader.Invoke( "glGetUniformuiv" ) );
        _glBindFragDataLocation   = Marshal.GetDelegateForFunctionPointer< PFNGLBINDFRAGDATALOCATIONPROC >( loader.Invoke( "glBindFragDataLocation" ) );
        _glGetFragDataLocation    = Marshal.GetDelegateForFunctionPointer< PFNGLGETFRAGDATALOCATIONPROC >( loader.Invoke( "glGetFragDataLocation" ) );
        _glUniform1ui             = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM1UIPROC >( loader.Invoke( "glUniform1ui" ) );
        _glUniform2ui             = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM2UIPROC >( loader.Invoke( "glUniform2ui" ) );
        _glUniform3ui             = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM3UIPROC >( loader.Invoke( "glUniform3ui" ) );
        _glUniform4ui             = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM4UIPROC >( loader.Invoke( "glUniform4ui" ) );
        _glUniform1uiv            = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM1UIVPROC >( loader.Invoke( "glUniform1uiv" ) );
        _glUniform2uiv            = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM2UIVPROC >( loader.Invoke( "glUniform2uiv" ) );
        _glUniform3uiv            = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM3UIVPROC >( loader.Invoke( "glUniform3uiv" ) );
        _glUniform4uiv            = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORM4UIVPROC >( loader.Invoke( "glUniform4uiv" ) );
        _glTexParameterIiv        = Marshal.GetDelegateForFunctionPointer< PFNGLTEXPARAMETERIIVPROC >( loader.Invoke( "glTexParameterIiv" ) );
        _glTexParameterIuiv       = Marshal.GetDelegateForFunctionPointer< PFNGLTEXPARAMETERIUIVPROC >( loader.Invoke( "glTexParameterIuiv" ) );
        _glGetTexParameterIiv     = Marshal.GetDelegateForFunctionPointer< PFNGLGETTEXPARAMETERIIVPROC >( loader.Invoke( "glGetTexParameterIiv" ) );
        _glGetTexParameterIuiv    = Marshal.GetDelegateForFunctionPointer< PFNGLGETTEXPARAMETERIUIVPROC >( loader.Invoke( "glGetTexParameterIuiv" ) );
        _glClearBufferiv          = Marshal.GetDelegateForFunctionPointer< PFNGLCLEARBUFFERIVPROC >( loader.Invoke( "glClearBufferiv" ) );
        _glClearBufferuiv         = Marshal.GetDelegateForFunctionPointer< PFNGLCLEARBUFFERUIVPROC >( loader.Invoke( "glClearBufferuiv" ) );
        _glClearBufferfv          = Marshal.GetDelegateForFunctionPointer< PFNGLCLEARBUFFERFVPROC >( loader.Invoke( "glClearBufferfv" ) );
        _glClearBufferfi          = Marshal.GetDelegateForFunctionPointer< PFNGLCLEARBUFFERFIPROC >( loader.Invoke( "glClearBufferfi" ) );
        _glGetStringi             = Marshal.GetDelegateForFunctionPointer< PFNGLGETSTRINGIPROC >( loader.Invoke( "glGetStringi" ) );
        _glIsRenderbuffer         = Marshal.GetDelegateForFunctionPointer< PFNGLISRENDERBUFFERPROC >( loader.Invoke( "glIsRenderbuffer" ) );
        _glBindRenderbuffer       = Marshal.GetDelegateForFunctionPointer< PFNGLBINDRENDERBUFFERPROC >( loader.Invoke( "glBindRenderbuffer" ) );
        _glDeleteRenderbuffers    = Marshal.GetDelegateForFunctionPointer< PFNGLDELETERENDERBUFFERSPROC >( loader.Invoke( "glDeleteRenderbuffers" ) );
        _glGenRenderbuffers       = Marshal.GetDelegateForFunctionPointer< PFNGLGENRENDERBUFFERSPROC >( loader.Invoke( "glGenRenderbuffers" ) );
        _glRenderbufferStorage    = Marshal.GetDelegateForFunctionPointer< PFNGLRENDERBUFFERSTORAGEPROC >( loader.Invoke( "glRenderbufferStorage" ) );

        _glGetRenderbufferParameteriv =
            Marshal.GetDelegateForFunctionPointer< PFNGLGETRENDERBUFFERPARAMETERIVPROC >( loader.Invoke( "glGetRenderbufferParameteriv" ) );

        _glIsFramebuffer           = Marshal.GetDelegateForFunctionPointer< PFNGLISFRAMEBUFFERPROC >( loader.Invoke( "glIsFramebuffer" ) );
        _glBindFramebuffer         = Marshal.GetDelegateForFunctionPointer< PFNGLBINDFRAMEBUFFERPROC >( loader.Invoke( "glBindFramebuffer" ) );
        _glDeleteFramebuffers      = Marshal.GetDelegateForFunctionPointer< PFNGLDELETEFRAMEBUFFERSPROC >( loader.Invoke( "glDeleteFramebuffers" ) );
        _glGenFramebuffers         = Marshal.GetDelegateForFunctionPointer< PFNGLGENFRAMEBUFFERSPROC >( loader.Invoke( "glGenFramebuffers" ) );
        _glCheckFramebufferStatus  = Marshal.GetDelegateForFunctionPointer< PFNGLCHECKFRAMEBUFFERSTATUSPROC >( loader.Invoke( "glCheckFramebufferStatus" ) );
        _glFramebufferTexture1D    = Marshal.GetDelegateForFunctionPointer< PFNGLFRAMEBUFFERTEXTURE1DPROC >( loader.Invoke( "glFramebufferTexture1D" ) );
        _glFramebufferTexture2D    = Marshal.GetDelegateForFunctionPointer< PFNGLFRAMEBUFFERTEXTURE2DPROC >( loader.Invoke( "glFramebufferTexture2D" ) );
        _glFramebufferTexture3D    = Marshal.GetDelegateForFunctionPointer< PFNGLFRAMEBUFFERTEXTURE3DPROC >( loader.Invoke( "glFramebufferTexture3D" ) );
        _glFramebufferRenderbuffer = Marshal.GetDelegateForFunctionPointer< PFNGLFRAMEBUFFERRENDERBUFFERPROC >( loader.Invoke( "glFramebufferRenderbuffer" ) );

        _glGetFramebufferAttachmentParameteriv =
            Marshal.GetDelegateForFunctionPointer< PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC >( loader.Invoke( "glGetFramebufferAttachmentParameteriv" ) );

        _glGenerateMipmap  = Marshal.GetDelegateForFunctionPointer< PFNGLGENERATEMIPMAPPROC >( loader.Invoke( "glGenerateMipmap" ) );
        _glBlitFramebuffer = Marshal.GetDelegateForFunctionPointer< PFNGLBLITFRAMEBUFFERPROC >( loader.Invoke( "glBlitFramebuffer" ) );

        _glRenderbufferStorageMultisample =
            Marshal.GetDelegateForFunctionPointer< PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC >( loader.Invoke( "glRenderbufferStorageMultisample" ) );

        _glFramebufferTextureLayer = Marshal.GetDelegateForFunctionPointer< PFNGLFRAMEBUFFERTEXTURELAYERPROC >( loader.Invoke( "glFramebufferTextureLayer" ) );
        _glMapBufferRange          = Marshal.GetDelegateForFunctionPointer< PFNGLMAPBUFFERRANGEPROC >( loader.Invoke( "glMapBufferRange" ) );
        _glFlushMappedBufferRange  = Marshal.GetDelegateForFunctionPointer< PFNGLFLUSHMAPPEDBUFFERRANGEPROC >( loader.Invoke( "glFlushMappedBufferRange" ) );
        _glBindVertexArray         = Marshal.GetDelegateForFunctionPointer< PFNGLBINDVERTEXARRAYPROC >( loader.Invoke( "glBindVertexArray" ) );
        _glDeleteVertexArrays      = Marshal.GetDelegateForFunctionPointer< PFNGLDELETEVERTEXARRAYSPROC >( loader.Invoke( "glDeleteVertexArrays" ) );
        _glGenVertexArrays         = Marshal.GetDelegateForFunctionPointer< PFNGLGENVERTEXARRAYSPROC >( loader.Invoke( "glGenVertexArrays" ) );
        _glIsVertexArray           = Marshal.GetDelegateForFunctionPointer< PFNGLISVERTEXARRAYPROC >( loader.Invoke( "glIsVertexArray" ) );
#endif
#if OGL_V_3_1 || OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glDrawArraysInstanced     = Marshal.GetDelegateForFunctionPointer< PFNGLDRAWARRAYSINSTANCEDPROC >( loader.Invoke( "glDrawArraysInstanced" ) );
        _glDrawElementsInstanced   = Marshal.GetDelegateForFunctionPointer< PFNGLDRAWELEMENTSINSTANCEDPROC >( loader.Invoke( "glDrawElementsInstanced" ) );
        _glTexBuffer               = Marshal.GetDelegateForFunctionPointer< PFNGLTEXBUFFERPROC >( loader.Invoke( "glTexBuffer" ) );
        _glPrimitiveRestartIndex   = Marshal.GetDelegateForFunctionPointer< PFNGLPRIMITIVERESTARTINDEXPROC >( loader.Invoke( "glPrimitiveRestartIndex" ) );
        _glCopyBufferSubData       = Marshal.GetDelegateForFunctionPointer< PFNGLCOPYBUFFERSUBDATAPROC >( loader.Invoke( "glCopyBufferSubData" ) );
        _glGetUniformIndices       = Marshal.GetDelegateForFunctionPointer< PFNGLGETUNIFORMINDICESPROC >( loader.Invoke( "glGetUniformIndices" ) );
        _glGetActiveUniformsiv     = Marshal.GetDelegateForFunctionPointer< PFNGLGETACTIVEUNIFORMSIVPROC >( loader.Invoke( "glGetActiveUniformsiv" ) );
        _glGetActiveUniformName    = Marshal.GetDelegateForFunctionPointer< PFNGLGETACTIVEUNIFORMNAMEPROC >( loader.Invoke( "glGetActiveUniformName" ) );
        _glGetUniformBlockIndex    = Marshal.GetDelegateForFunctionPointer< PFNGLGETUNIFORMBLOCKINDEXPROC >( loader.Invoke( "glGetUniformBlockIndex" ) );
        _glGetActiveUniformBlockiv = Marshal.GetDelegateForFunctionPointer< PFNGLGETACTIVEUNIFORMBLOCKIVPROC >( loader.Invoke( "glGetActiveUniformBlockiv" ) );

        _glGetActiveUniformBlockName
            = Marshal.GetDelegateForFunctionPointer< PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC >( loader.Invoke( "glGetActiveUniformBlockName" ) );

        _glUniformBlockBinding = Marshal.GetDelegateForFunctionPointer< PFNGLUNIFORMBLOCKBINDINGPROC >( loader.Invoke( "glUniformBlockBinding" ) );
#endif
#if OGL_V_3_2 || OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glDrawElementsBaseVertex = Marshal.GetDelegateForFunctionPointer< PFNGLDRAWELEMENTSBASEVERTEXPROC >( loader.Invoke( "glDrawElementsBaseVertex" ) );

        _glDrawRangeElementsBaseVertex =
            Marshal.GetDelegateForFunctionPointer< PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC >( loader.Invoke( "glDrawRangeElementsBaseVertex" ) );

        _glDrawElementsInstancedBaseVertex =
            Marshal.GetDelegateForFunctionPointer< PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC >( loader.Invoke( "glDrawElementsInstancedBaseVertex" ) );

        _glMultiDrawElementsBaseVertex =
            Marshal.GetDelegateForFunctionPointer< PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC >( loader.Invoke( "glMultiDrawElementsBaseVertex" ) );

        _glProvokingVertex        = Marshal.GetDelegateForFunctionPointer< PFNGLPROVOKINGVERTEXPROC >( loader.Invoke( "glProvokingVertex" ) );
        _glFenceSync              = Marshal.GetDelegateForFunctionPointer< PFNGLFENCESYNCPROC >( loader.Invoke( "glFenceSync" ) );
        _glIsSync                 = Marshal.GetDelegateForFunctionPointer< PFNGLISSYNCPROC >( loader.Invoke( "glIsSync" ) );
        _glDeleteSync             = Marshal.GetDelegateForFunctionPointer< PFNGLDELETESYNCPROC >( loader.Invoke( "glDeleteSync" ) );
        _glClientWaitSync         = Marshal.GetDelegateForFunctionPointer< PFNGLCLIENTWAITSYNCPROC >( loader.Invoke( "glClientWaitSync" ) );
        _glWaitSync               = Marshal.GetDelegateForFunctionPointer< PFNGLWAITSYNCPROC >( loader.Invoke( "glWaitSync" ) );
        _glGetInteger64v          = Marshal.GetDelegateForFunctionPointer< PFNGLGETINTEGER64VPROC >( loader.Invoke( "glGetInteger64v" ) );
        _glGetSynciv              = Marshal.GetDelegateForFunctionPointer< PFNGLGETSYNCIVPROC >( loader.Invoke( "glGetSynciv" ) );
        _glGetInteger64i_v        = Marshal.GetDelegateForFunctionPointer< PFNGLGETINTEGER64I_VPROC >( loader.Invoke( "glGetInteger64i_v" ) );
        _glGetBufferParameteri64v = Marshal.GetDelegateForFunctionPointer< PFNGLGETBUFFERPARAMETERI64VPROC >( loader.Invoke( "glGetBufferParameteri64v" ) );
        _glFramebufferTexture     = Marshal.GetDelegateForFunctionPointer< PFNGLFRAMEBUFFERTEXTUREPROC >( loader.Invoke( "glFramebufferTexture" ) );
        _glTexImage2DMultisample  = Marshal.GetDelegateForFunctionPointer< PFNGLTEXIMAGE2DMULTISAMPLEPROC >( loader.Invoke( "glTexImage2DMultisample" ) );
        _glTexImage3DMultisample  = Marshal.GetDelegateForFunctionPointer< PFNGLTEXIMAGE3DMULTISAMPLEPROC >( loader.Invoke( "glTexImage3DMultisample" ) );
        _glGetMultisamplefv       = Marshal.GetDelegateForFunctionPointer< PFNGLGETMULTISAMPLEFVPROC >( loader.Invoke( "glGetMultisamplefv" ) );
        _glSampleMaski            = Marshal.GetDelegateForFunctionPointer< PFNGLSAMPLEMASKIPROC >( loader.Invoke( "glSampleMaski" ) );
#endif
#if OGL_V_3_3 || OGL_V_3_4 || OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glBindFragDataLocationIndexed =
            Marshal.GetDelegateForFunctionPointer< PFNGLBINDFRAGDATALOCATIONINDEXEDPROC >( loader.Invoke( "glBindFragDataLocationIndexed" ) );

        _glGetFragDataIndex        = Marshal.GetDelegateForFunctionPointer< PFNGLGETFRAGDATAINDEXPROC >( loader.Invoke( "glGetFragDataIndex" ) );
        _glGenSamplers             = Marshal.GetDelegateForFunctionPointer< PFNGLGENSAMPLERSPROC >( loader.Invoke( "glGenSamplers" ) );
        _glDeleteSamplers          = Marshal.GetDelegateForFunctionPointer< PFNGLDELETESAMPLERSPROC >( loader.Invoke( "glDeleteSamplers" ) );
        _glIsSampler               = Marshal.GetDelegateForFunctionPointer< PFNGLISSAMPLERPROC >( loader.Invoke( "glIsSampler" ) );
        _glBindSampler             = Marshal.GetDelegateForFunctionPointer< PFNGLBINDSAMPLERPROC >( loader.Invoke( "glBindSampler" ) );
        _glSamplerParameteri       = Marshal.GetDelegateForFunctionPointer< PFNGLSAMPLERPARAMETERIPROC >( loader.Invoke( "glSamplerParameteri" ) );
        _glSamplerParameteriv      = Marshal.GetDelegateForFunctionPointer< PFNGLSAMPLERPARAMETERIVPROC >( loader.Invoke( "glSamplerParameteriv" ) );
        _glSamplerParameterf       = Marshal.GetDelegateForFunctionPointer< PFNGLSAMPLERPARAMETERFPROC >( loader.Invoke( "glSamplerParameterf" ) );
        _glSamplerParameterfv      = Marshal.GetDelegateForFunctionPointer< PFNGLSAMPLERPARAMETERFVPROC >( loader.Invoke( "glSamplerParameterfv" ) );
        _glSamplerParameterIiv     = Marshal.GetDelegateForFunctionPointer< PFNGLSAMPLERPARAMETERIIVPROC >( loader.Invoke( "glSamplerParameterIiv" ) );
        _glSamplerParameterIuiv    = Marshal.GetDelegateForFunctionPointer< PFNGLSAMPLERPARAMETERIUIVPROC >( loader.Invoke( "glSamplerParameterIuiv" ) );
        _glGetSamplerParameteriv   = Marshal.GetDelegateForFunctionPointer< PFNGLGETSAMPLERPARAMETERIVPROC >( loader.Invoke( "glGetSamplerParameteriv" ) );
        _glGetSamplerParameterIiv  = Marshal.GetDelegateForFunctionPointer< PFNGLGETSAMPLERPARAMETERIIVPROC >( loader.Invoke( "glGetSamplerParameterIiv" ) );
        _glGetSamplerParameterfv   = Marshal.GetDelegateForFunctionPointer< PFNGLGETSAMPLERPARAMETERFVPROC >( loader.Invoke( "glGetSamplerParameterfv" ) );
        _glGetSamplerParameterIuiv = Marshal.GetDelegateForFunctionPointer< PFNGLGETSAMPLERPARAMETERIUIVPROC >( loader.Invoke( "glGetSamplerParameterIuiv" ) );
        _glQueryCounter            = Marshal.GetDelegateForFunctionPointer< PFNGLQUERYCOUNTERPROC >( loader.Invoke( "glQueryCounter" ) );
        _glGetQueryObjecti64v      = Marshal.GetDelegateForFunctionPointer< PFNGLGETQUERYOBJECTI64VPROC >( loader.Invoke( "glGetQueryObjecti64v" ) );
        _glGetQueryObjectui64v     = Marshal.GetDelegateForFunctionPointer< PFNGLGETQUERYOBJECTUI64VPROC >( loader.Invoke( "glGetQueryObjectui64v" ) );
        _glVertexAttribDivisor     = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBDIVISORPROC >( loader.Invoke( "glVertexAttribDivisor" ) );
        _glVertexAttribP1ui        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBP1UIPROC >( loader.Invoke( "glVertexAttribP1ui" ) );
        _glVertexAttribP1uiv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBP1UIVPROC >( loader.Invoke( "glVertexAttribP1uiv" ) );
        _glVertexAttribP2ui        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBP2UIPROC >( loader.Invoke( "glVertexAttribP2ui" ) );
        _glVertexAttribP2uiv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBP2UIVPROC >( loader.Invoke( "glVertexAttribP2uiv" ) );
        _glVertexAttribP3ui        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBP3UIPROC >( loader.Invoke( "glVertexAttribP3ui" ) );
        _glVertexAttribP3uiv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBP3UIVPROC >( loader.Invoke( "glVertexAttribP3uiv" ) );
        _glVertexAttribP4ui        = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBP4UIPROC >( loader.Invoke( "glVertexAttribP4ui" ) );
        _glVertexAttribP4uiv       = Marshal.GetDelegateForFunctionPointer< PFNGLVERTEXATTRIBP4UIVPROC >( loader.Invoke( "glVertexAttribP4uiv" ) );
#endif
#if OGL_V_4_0 || OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glMinSampleShading = Marshal.GetDelegateForFunctionPointer<PFNGLMINSAMPLESHADINGPROC>(loader.Invoke("glMinSampleShading"));
        _glBlendEquationi = Marshal.GetDelegateForFunctionPointer<PFNGLBLENDEQUATIONIPROC>(loader.Invoke("glBlendEquationi"));
        _glBlendEquationSeparatei = Marshal.GetDelegateForFunctionPointer<PFNGLBLENDEQUATIONSEPARATEIPROC>(loader.Invoke("glBlendEquationSeparatei"));
        _glBlendFunci = Marshal.GetDelegateForFunctionPointer<PFNGLBLENDFUNCIPROC>(loader.Invoke("glBlendFunci"));
        _glBlendFuncSeparatei = Marshal.GetDelegateForFunctionPointer<PFNGLBLENDFUNCSEPARATEIPROC>(loader.Invoke("glBlendFuncSeparatei"));
        _glDrawArraysIndirect = Marshal.GetDelegateForFunctionPointer<PFNGLDRAWARRAYSINDIRECTPROC>(loader.Invoke("glDrawArraysIndirect"));
        _glDrawElementsIndirect = Marshal.GetDelegateForFunctionPointer<PFNGLDRAWELEMENTSINDIRECTPROC>(loader.Invoke("glDrawElementsIndirect"));
        _glUniform1d = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORM1DPROC>(loader.Invoke("glUniform1d"));
        _glUniform2d = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORM2DPROC>(loader.Invoke("glUniform2d"));
        _glUniform3d = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORM3DPROC>(loader.Invoke("glUniform3d"));
        _glUniform4d = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORM4DPROC>(loader.Invoke("glUniform4d"));
        _glUniform1dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORM1DVPROC>(loader.Invoke("glUniform1dv"));
        _glUniform2dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORM2DVPROC>(loader.Invoke("glUniform2dv"));
        _glUniform3dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORM3DVPROC>(loader.Invoke("glUniform3dv"));
        _glUniform4dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORM4DVPROC>(loader.Invoke("glUniform4dv"));
        _glUniformMatrix2dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORMMATRIX2DVPROC>(loader.Invoke("glUniformMatrix2dv"));
        _glUniformMatrix3dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORMMATRIX3DVPROC>(loader.Invoke("glUniformMatrix3dv"));
        _glUniformMatrix4dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORMMATRIX4DVPROC>(loader.Invoke("glUniformMatrix4dv"));
        _glUniformMatrix2x3dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORMMATRIX2X3DVPROC>(loader.Invoke("glUniformMatrix2x3dv"));
        _glUniformMatrix2x4dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORMMATRIX2X4DVPROC>(loader.Invoke("glUniformMatrix2x4dv"));
        _glUniformMatrix3x2dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORMMATRIX3X2DVPROC>(loader.Invoke("glUniformMatrix3x2dv"));
        _glUniformMatrix3x4dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORMMATRIX3X4DVPROC>(loader.Invoke("glUniformMatrix3x4dv"));
        _glUniformMatrix4x2dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORMMATRIX4X2DVPROC>(loader.Invoke("glUniformMatrix4x2dv"));
        _glUniformMatrix4x3dv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORMMATRIX4X3DVPROC>(loader.Invoke("glUniformMatrix4x3dv"));
        _glGetUniformdv = Marshal.GetDelegateForFunctionPointer<PFNGLGETUNIFORMDVPROC>(loader.Invoke("glGetUniformdv"));
        _glGetSubroutineUniformLocation =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC>(loader.Invoke("glGetSubroutineUniformLocation"));
        _glGetSubroutineIndex = Marshal.GetDelegateForFunctionPointer<PFNGLGETSUBROUTINEINDEXPROC>(loader.Invoke("glGetSubroutineIndex"));
        _glGetActiveSubroutineUniformiv =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC>(loader.Invoke("glGetActiveSubroutineUniformiv"));
        _glGetActiveSubroutineUniformName =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC>(loader.Invoke("glGetActiveSubroutineUniformName"));
        _glGetActiveSubroutineName = Marshal.GetDelegateForFunctionPointer<PFNGLGETACTIVESUBROUTINENAMEPROC>(loader.Invoke("glGetActiveSubroutineName"));
        _glUniformSubroutinesuiv = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORMSUBROUTINESUIVPROC>(loader.Invoke("glUniformSubroutinesuiv"));
        _glGetUniformSubroutineuiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETUNIFORMSUBROUTINEUIVPROC>(loader.Invoke("glGetUniformSubroutineuiv"));
        _glGetProgramStageiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETPROGRAMSTAGEIVPROC>(loader.Invoke("glGetProgramStageiv"));
        _glPatchParameteri = Marshal.GetDelegateForFunctionPointer<PFNGLPATCHPARAMETERIPROC>(loader.Invoke("glPatchParameteri"));
        _glPatchParameterfv = Marshal.GetDelegateForFunctionPointer<PFNGLPATCHPARAMETERFVPROC>(loader.Invoke("glPatchParameterfv"));
        _glBindTransformFeedback = Marshal.GetDelegateForFunctionPointer<PFNGLBINDTRANSFORMFEEDBACKPROC>(loader.Invoke("glBindTransformFeedback"));
        _glDeleteTransformFeedbacks = Marshal.GetDelegateForFunctionPointer<PFNGLDELETETRANSFORMFEEDBACKSPROC>(loader.Invoke("glDeleteTransformFeedbacks"));
        _glGenTransformFeedbacks = Marshal.GetDelegateForFunctionPointer<PFNGLGENTRANSFORMFEEDBACKSPROC>(loader.Invoke("glGenTransformFeedbacks"));
        _glIsTransformFeedback = Marshal.GetDelegateForFunctionPointer<PFNGLISTRANSFORMFEEDBACKPROC>(loader.Invoke("glIsTransformFeedback"));
        _glPauseTransformFeedback = Marshal.GetDelegateForFunctionPointer<PFNGLPAUSETRANSFORMFEEDBACKPROC>(loader.Invoke("glPauseTransformFeedback"));
        _glResumeTransformFeedback = Marshal.GetDelegateForFunctionPointer<PFNGLRESUMETRANSFORMFEEDBACKPROC>(loader.Invoke("glResumeTransformFeedback"));
        _glDrawTransformFeedback = Marshal.GetDelegateForFunctionPointer<PFNGLDRAWTRANSFORMFEEDBACKPROC>(loader.Invoke("glDrawTransformFeedback"));
        _glDrawTransformFeedbackStream =
 Marshal.GetDelegateForFunctionPointer<PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC>(loader.Invoke("glDrawTransformFeedbackStream"));
        _glBeginQueryIndexed = Marshal.GetDelegateForFunctionPointer<PFNGLBEGINQUERYINDEXEDPROC>(loader.Invoke("glBeginQueryIndexed"));
        _glEndQueryIndexed = Marshal.GetDelegateForFunctionPointer<PFNGLENDQUERYINDEXEDPROC>(loader.Invoke("glEndQueryIndexed"));
        _glGetQueryIndexediv = Marshal.GetDelegateForFunctionPointer<PFNGLGETQUERYINDEXEDIVPROC>(loader.Invoke("glGetQueryIndexediv"));
#endif
#if OGL_V_4_1 || OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glReleaseShaderCompiler = Marshal.GetDelegateForFunctionPointer<PFNGLRELEASESHADERCOMPILERPROC>(loader.Invoke("glReleaseShaderCompiler"));
        _glShaderBinary = Marshal.GetDelegateForFunctionPointer<PFNGLSHADERBINARYPROC>(loader.Invoke("glShaderBinary"));
        _glGetShaderPrecisionFormat = Marshal.GetDelegateForFunctionPointer<PFNGLGETSHADERPRECISIONFORMATPROC>(loader.Invoke("glGetShaderPrecisionFormat"));
        _glDepthRangef = Marshal.GetDelegateForFunctionPointer<PFNGLDEPTHRANGEFPROC>(loader.Invoke("glDepthRangef"));
        _glClearDepthf = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARDEPTHFPROC>(loader.Invoke("glClearDepthf"));
        _glGetProgramBinary = Marshal.GetDelegateForFunctionPointer<PFNGLGETPROGRAMBINARYPROC>(loader.Invoke("glGetProgramBinary"));
        _glProgramBinary = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMBINARYPROC>(loader.Invoke("glProgramBinary"));
        _glProgramParameteri = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMPARAMETERIPROC>(loader.Invoke("glProgramParameteri"));
        _glUseProgramStages = Marshal.GetDelegateForFunctionPointer<PFNGLUSEPROGRAMSTAGESPROC>(loader.Invoke("glUseProgramStages"));
        _glActiveShaderProgram = Marshal.GetDelegateForFunctionPointer<PFNGLACTIVESHADERPROGRAMPROC>(loader.Invoke("glActiveShaderProgram"));
        _glCreateShaderProgramv = Marshal.GetDelegateForFunctionPointer<PFNGLCREATESHADERPROGRAMVPROC>(loader.Invoke("glCreateShaderProgramv"));
        _glBindProgramPipeline = Marshal.GetDelegateForFunctionPointer<PFNGLBINDPROGRAMPIPELINEPROC>(loader.Invoke("glBindProgramPipeline"));
        _glDeleteProgramPipelines = Marshal.GetDelegateForFunctionPointer<PFNGLDELETEPROGRAMPIPELINESPROC>(loader.Invoke("glDeleteProgramPipelines"));
        _glGenProgramPipelines = Marshal.GetDelegateForFunctionPointer<PFNGLGENPROGRAMPIPELINESPROC>(loader.Invoke("glGenProgramPipelines"));
        _glIsProgramPipeline = Marshal.GetDelegateForFunctionPointer<PFNGLISPROGRAMPIPELINEPROC>(loader.Invoke("glIsProgramPipeline"));
        _glGetProgramPipelineiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETPROGRAMPIPELINEIVPROC>(loader.Invoke("glGetProgramPipelineiv"));
        _glProgramUniform1i = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM1IPROC>(loader.Invoke("glProgramUniform1i"));
        _glProgramUniform1iv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM1IVPROC>(loader.Invoke("glProgramUniform1iv"));
        _glProgramUniform1f = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM1FPROC>(loader.Invoke("glProgramUniform1f"));
        _glProgramUniform1fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM1FVPROC>(loader.Invoke("glProgramUniform1fv"));
        _glProgramUniform1d = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM1DPROC>(loader.Invoke("glProgramUniform1d"));
        _glProgramUniform1dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM1DVPROC>(loader.Invoke("glProgramUniform1dv"));
        _glProgramUniform1ui = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM1UIPROC>(loader.Invoke("glProgramUniform1ui"));
        _glProgramUniform1uiv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM1UIVPROC>(loader.Invoke("glProgramUniform1uiv"));
        _glProgramUniform2i = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM2IPROC>(loader.Invoke("glProgramUniform2i"));
        _glProgramUniform2iv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM2IVPROC>(loader.Invoke("glProgramUniform2iv"));
        _glProgramUniform2f = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM2FPROC>(loader.Invoke("glProgramUniform2f"));
        _glProgramUniform2fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM2FVPROC>(loader.Invoke("glProgramUniform2fv"));
        _glProgramUniform2d = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM2DPROC>(loader.Invoke("glProgramUniform2d"));
        _glProgramUniform2dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM2DVPROC>(loader.Invoke("glProgramUniform2dv"));
        _glProgramUniform2ui = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM2UIPROC>(loader.Invoke("glProgramUniform2ui"));
        _glProgramUniform2uiv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM2UIVPROC>(loader.Invoke("glProgramUniform2uiv"));
        _glProgramUniform3i = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM3IPROC>(loader.Invoke("glProgramUniform3i"));
        _glProgramUniform3iv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM3IVPROC>(loader.Invoke("glProgramUniform3iv"));
        _glProgramUniform3f = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM3FPROC>(loader.Invoke("glProgramUniform3f"));
        _glProgramUniform3fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM3FVPROC>(loader.Invoke("glProgramUniform3fv"));
        _glProgramUniform3d = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM3DPROC>(loader.Invoke("glProgramUniform3d"));
        _glProgramUniform3dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM3DVPROC>(loader.Invoke("glProgramUniform3dv"));
        _glProgramUniform3ui = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM3UIPROC>(loader.Invoke("glProgramUniform3ui"));
        _glProgramUniform3uiv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM3UIVPROC>(loader.Invoke("glProgramUniform3uiv"));
        _glProgramUniform4i = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM4IPROC>(loader.Invoke("glProgramUniform4i"));
        _glProgramUniform4iv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM4IVPROC>(loader.Invoke("glProgramUniform4iv"));
        _glProgramUniform4f = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM4FPROC>(loader.Invoke("glProgramUniform4f"));
        _glProgramUniform4fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM4FVPROC>(loader.Invoke("glProgramUniform4fv"));
        _glProgramUniform4d = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM4DPROC>(loader.Invoke("glProgramUniform4d"));
        _glProgramUniform4dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM4DVPROC>(loader.Invoke("glProgramUniform4dv"));
        _glProgramUniform4ui = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM4UIPROC>(loader.Invoke("glProgramUniform4ui"));
        _glProgramUniform4uiv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORM4UIVPROC>(loader.Invoke("glProgramUniform4uiv"));
        _glProgramUniformMatrix2fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX2FVPROC>(loader.Invoke("glProgramUniformMatrix2fv"));
        _glProgramUniformMatrix3fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX3FVPROC>(loader.Invoke("glProgramUniformMatrix3fv"));
        _glProgramUniformMatrix4fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX4FVPROC>(loader.Invoke("glProgramUniformMatrix4fv"));
        _glProgramUniformMatrix2dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX2DVPROC>(loader.Invoke("glProgramUniformMatrix2dv"));
        _glProgramUniformMatrix3dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX3DVPROC>(loader.Invoke("glProgramUniformMatrix3dv"));
        _glProgramUniformMatrix4dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX4DVPROC>(loader.Invoke("glProgramUniformMatrix4dv"));
        _glProgramUniformMatrix2x3fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC>(loader.Invoke("glProgramUniformMatrix2x3fv"));
        _glProgramUniformMatrix3x2fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC>(loader.Invoke("glProgramUniformMatrix3x2fv"));
        _glProgramUniformMatrix2x4fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC>(loader.Invoke("glProgramUniformMatrix2x4fv"));
        _glProgramUniformMatrix4x2fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC>(loader.Invoke("glProgramUniformMatrix4x2fv"));
        _glProgramUniformMatrix3x4fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC>(loader.Invoke("glProgramUniformMatrix3x4fv"));
        _glProgramUniformMatrix4x3fv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC>(loader.Invoke("glProgramUniformMatrix4x3fv"));
        _glProgramUniformMatrix2x3dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC>(loader.Invoke("glProgramUniformMatrix2x3dv"));
        _glProgramUniformMatrix3x2dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC>(loader.Invoke("glProgramUniformMatrix3x2dv"));
        _glProgramUniformMatrix2x4dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC>(loader.Invoke("glProgramUniformMatrix2x4dv"));
        _glProgramUniformMatrix4x2dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC>(loader.Invoke("glProgramUniformMatrix4x2dv"));
        _glProgramUniformMatrix3x4dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC>(loader.Invoke("glProgramUniformMatrix3x4dv"));
        _glProgramUniformMatrix4x3dv = Marshal.GetDelegateForFunctionPointer<PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC>(loader.Invoke("glProgramUniformMatrix4x3dv"));
        _glValidateProgramPipeline = Marshal.GetDelegateForFunctionPointer<PFNGLVALIDATEPROGRAMPIPELINEPROC>(loader.Invoke("glValidateProgramPipeline"));
        _glGetProgramPipelineInfoLog = Marshal.GetDelegateForFunctionPointer<PFNGLGETPROGRAMPIPELINEINFOLOGPROC>(loader.Invoke("glGetProgramPipelineInfoLog"));
        _glVertexAttribL1d = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBL1DPROC>(loader.Invoke("glVertexAttribL1d"));
        _glVertexAttribL2d = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBL2DPROC>(loader.Invoke("glVertexAttribL2d"));
        _glVertexAttribL3d = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBL3DPROC>(loader.Invoke("glVertexAttribL3d"));
        _glVertexAttribL4d = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBL4DPROC>(loader.Invoke("glVertexAttribL4d"));
        _glVertexAttribL1dv = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBL1DVPROC>(loader.Invoke("glVertexAttribL1dv"));
        _glVertexAttribL2dv = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBL2DVPROC>(loader.Invoke("glVertexAttribL2dv"));
        _glVertexAttribL3dv = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBL3DVPROC>(loader.Invoke("glVertexAttribL3dv"));
        _glVertexAttribL4dv = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBL4DVPROC>(loader.Invoke("glVertexAttribL4dv"));
        _glVertexAttribLPointer = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBLPOINTERPROC>(loader.Invoke("glVertexAttribLPointer"));
        _glGetVertexAttribLdv = Marshal.GetDelegateForFunctionPointer<PFNGLGETVERTEXATTRIBLDVPROC>(loader.Invoke("glGetVertexAttribLdv"));
        _glViewportArrayv = Marshal.GetDelegateForFunctionPointer<PFNGLVIEWPORTARRAYVPROC>(loader.Invoke("glViewportArrayv"));
        _glViewportIndexedf = Marshal.GetDelegateForFunctionPointer<PFNGLVIEWPORTINDEXEDFPROC>(loader.Invoke("glViewportIndexedf"));
        _glViewportIndexedfv = Marshal.GetDelegateForFunctionPointer<PFNGLVIEWPORTINDEXEDFVPROC>(loader.Invoke("glViewportIndexedfv"));
        _glScissorArrayv = Marshal.GetDelegateForFunctionPointer<PFNGLSCISSORARRAYVPROC>(loader.Invoke("glScissorArrayv"));
        _glScissorIndexed = Marshal.GetDelegateForFunctionPointer<PFNGLSCISSORINDEXEDPROC>(loader.Invoke("glScissorIndexed"));
        _glScissorIndexedv = Marshal.GetDelegateForFunctionPointer<PFNGLSCISSORINDEXEDVPROC>(loader.Invoke("glScissorIndexedv"));
        _glDepthRangeArrayv = Marshal.GetDelegateForFunctionPointer<PFNGLDEPTHRANGEARRAYVPROC>(loader.Invoke("glDepthRangeArrayv"));
        _glDepthRangeIndexed = Marshal.GetDelegateForFunctionPointer<PFNGLDEPTHRANGEINDEXEDPROC>(loader.Invoke("glDepthRangeIndexed"));
        _glGetFloati_v = Marshal.GetDelegateForFunctionPointer<PFNGLGETFLOATI_VPROC>(loader.Invoke("glGetFloati_v"));
        _glGetDoublei_v = Marshal.GetDelegateForFunctionPointer<PFNGLGETDOUBLEI_VPROC>(loader.Invoke("glGetDoublei_v"));
#endif
#if OGL_V_4_2 || OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glDrawArraysInstancedBaseInstance =
 Marshal.GetDelegateForFunctionPointer<PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC>(loader.Invoke("glDrawArraysInstancedBaseInstance"));
        _glDrawElementsInstancedBaseInstance =
 Marshal.GetDelegateForFunctionPointer<PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC>(loader.Invoke("glDrawElementsInstancedBaseInstance"));
        _glDrawElementsInstancedBaseVertexBaseInstance =
 Marshal.GetDelegateForFunctionPointer<PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC>(loader.Invoke("glDrawElementsInstancedBaseVertexBaseInstance"));
        _glGetInternalformativ = Marshal.GetDelegateForFunctionPointer<PFNGLGETINTERNALFORMATIVPROC>(loader.Invoke("glGetInternalformativ"));
        _glGetActiveAtomicCounterBufferiv =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC>(loader.Invoke("glGetActiveAtomicCounterBufferiv"));
        _glBindImageTexture = Marshal.GetDelegateForFunctionPointer<PFNGLBINDIMAGETEXTUREPROC>(loader.Invoke("glBindImageTexture"));
        _glMemoryBarrier = Marshal.GetDelegateForFunctionPointer<PFNGLMEMORYBARRIERPROC>(loader.Invoke("glMemoryBarrier"));
        _glTexStorage1D = Marshal.GetDelegateForFunctionPointer<PFNGLTEXSTORAGE1DPROC>(loader.Invoke("glTexStorage1D"));
        _glTexStorage2D = Marshal.GetDelegateForFunctionPointer<PFNGLTEXSTORAGE2DPROC>(loader.Invoke("glTexStorage2D"));
        _glTexStorage3D = Marshal.GetDelegateForFunctionPointer<PFNGLTEXSTORAGE3DPROC>(loader.Invoke("glTexStorage3D"));
        _glDrawTransformFeedbackInstanced =
 Marshal.GetDelegateForFunctionPointer<PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC>(loader.Invoke("glDrawTransformFeedbackInstanced"));
        _glDrawTransformFeedbackStreamInstanced =
 Marshal.GetDelegateForFunctionPointer<PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC>(loader.Invoke("glDrawTransformFeedbackStreamInstanced"));
#endif
#if OGL_V_4_3 || OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glGetPointerv = Marshal.GetDelegateForFunctionPointer<PFNGLGETPOINTERVPROC>(loader.Invoke("glGetPointerv"));
        _glClearBufferData = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARBUFFERDATAPROC>(loader.Invoke("glClearBufferData"));
        _glClearBufferSubData = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARBUFFERSUBDATAPROC>(loader.Invoke("glClearBufferSubData"));
        _glDispatchCompute = Marshal.GetDelegateForFunctionPointer<PFNGLDISPATCHCOMPUTEPROC>(loader.Invoke("glDispatchCompute"));
        _glDispatchComputeIndirect = Marshal.GetDelegateForFunctionPointer<PFNGLDISPATCHCOMPUTEINDIRECTPROC>(loader.Invoke("glDispatchComputeIndirect"));
        _glCopyImageSubData = Marshal.GetDelegateForFunctionPointer<PFNGLCOPYIMAGESUBDATAPROC>(loader.Invoke("glCopyImageSubData"));
        _glFramebufferParameteri = Marshal.GetDelegateForFunctionPointer<PFNGLFRAMEBUFFERPARAMETERIPROC>(loader.Invoke("glFramebufferParameteri"));
        _glGetFramebufferParameteriv = Marshal.GetDelegateForFunctionPointer<PFNGLGETFRAMEBUFFERPARAMETERIVPROC>(loader.Invoke("glGetFramebufferParameteriv"));
        _glGetInternalformati64v = Marshal.GetDelegateForFunctionPointer<PFNGLGETINTERNALFORMATI64VPROC>(loader.Invoke("glGetInternalformati64v"));
        _glInvalidateTexSubImage = Marshal.GetDelegateForFunctionPointer<PFNGLINVALIDATETEXSUBIMAGEPROC>(loader.Invoke("glInvalidateTexSubImage"));
        _glInvalidateTexImage = Marshal.GetDelegateForFunctionPointer<PFNGLINVALIDATETEXIMAGEPROC>(loader.Invoke("glInvalidateTexImage"));
        _glInvalidateBufferSubData = Marshal.GetDelegateForFunctionPointer<PFNGLINVALIDATEBUFFERSUBDATAPROC>(loader.Invoke("glInvalidateBufferSubData"));
        _glInvalidateBufferData = Marshal.GetDelegateForFunctionPointer<PFNGLINVALIDATEBUFFERDATAPROC>(loader.Invoke("glInvalidateBufferData"));
        _glInvalidateFramebuffer = Marshal.GetDelegateForFunctionPointer<PFNGLINVALIDATEFRAMEBUFFERPROC>(loader.Invoke("glInvalidateFramebuffer"));
        _glInvalidateSubFramebuffer = Marshal.GetDelegateForFunctionPointer<PFNGLINVALIDATESUBFRAMEBUFFERPROC>(loader.Invoke("glInvalidateSubFramebuffer"));
        _glMultiDrawArraysIndirect = Marshal.GetDelegateForFunctionPointer<PFNGLMULTIDRAWARRAYSINDIRECTPROC>(loader.Invoke("glMultiDrawArraysIndirect"));
        _glMultiDrawElementsIndirect = Marshal.GetDelegateForFunctionPointer<PFNGLMULTIDRAWELEMENTSINDIRECTPROC>(loader.Invoke("glMultiDrawElementsIndirect"));
        _glGetProgramInterfaceiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETPROGRAMINTERFACEIVPROC>(loader.Invoke("glGetProgramInterfaceiv"));
        _glGetProgramResourceIndex = Marshal.GetDelegateForFunctionPointer<PFNGLGETPROGRAMRESOURCEINDEXPROC>(loader.Invoke("glGetProgramResourceIndex"));
        _glGetProgramResourceName = Marshal.GetDelegateForFunctionPointer<PFNGLGETPROGRAMRESOURCENAMEPROC>(loader.Invoke("glGetProgramResourceName"));
        _glGetProgramResourceiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETPROGRAMRESOURCEIVPROC>(loader.Invoke("glGetProgramResourceiv"));
        _glGetProgramResourceLocation =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETPROGRAMRESOURCELOCATIONPROC>(loader.Invoke("glGetProgramResourceLocation"));
        _glGetProgramResourceLocationIndex =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC>(loader.Invoke("glGetProgramResourceLocationIndex"));
        _glShaderStorageBlockBinding = Marshal.GetDelegateForFunctionPointer<PFNGLSHADERSTORAGEBLOCKBINDINGPROC>(loader.Invoke("glShaderStorageBlockBinding"));
        _glTexBufferRange = Marshal.GetDelegateForFunctionPointer<PFNGLTEXBUFFERRANGEPROC>(loader.Invoke("glTexBufferRange"));
        _glTexStorage2DMultisample = Marshal.GetDelegateForFunctionPointer<PFNGLTEXSTORAGE2DMULTISAMPLEPROC>(loader.Invoke("glTexStorage2DMultisample"));
        _glTexStorage3DMultisample = Marshal.GetDelegateForFunctionPointer<PFNGLTEXSTORAGE3DMULTISAMPLEPROC>(loader.Invoke("glTexStorage3DMultisample"));
        _glTextureView = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTUREVIEWPROC>(loader.Invoke("glTextureView"));
        _glBindVertexBuffer = Marshal.GetDelegateForFunctionPointer<PFNGLBINDVERTEXBUFFERPROC>(loader.Invoke("glBindVertexBuffer"));
        _glVertexAttribFormat = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBFORMATPROC>(loader.Invoke("glVertexAttribFormat"));
        _glVertexAttribIFormat = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBIFORMATPROC>(loader.Invoke("glVertexAttribIFormat"));
        _glVertexAttribLFormat = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBLFORMATPROC>(loader.Invoke("glVertexAttribLFormat"));
        _glVertexAttribBinding = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXATTRIBBINDINGPROC>(loader.Invoke("glVertexAttribBinding"));
        _glVertexBindingDivisor = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXBINDINGDIVISORPROC>(loader.Invoke("glVertexBindingDivisor"));
        _glDebugMessageControl = Marshal.GetDelegateForFunctionPointer<PFNGLDEBUGMESSAGECONTROLPROC>(loader.Invoke("glDebugMessageControl"));
        _glDebugMessageInsert = Marshal.GetDelegateForFunctionPointer<PFNGLDEBUGMESSAGEINSERTPROC>(loader.Invoke("glDebugMessageInsert"));
        _glDebugMessageCallback = Marshal.GetDelegateForFunctionPointer<PFNGLDEBUGMESSAGECALLBACKPROC>(loader.Invoke("glDebugMessageCallback"));
        _glGetDebugMessageLog = Marshal.GetDelegateForFunctionPointer<PFNGLGETDEBUGMESSAGELOGPROC>(loader.Invoke("glGetDebugMessageLog"));
        _glPushDebugGroup = Marshal.GetDelegateForFunctionPointer<PFNGLPUSHDEBUGGROUPPROC>(loader.Invoke("glPushDebugGroup"));
        _glPopDebugGroup = Marshal.GetDelegateForFunctionPointer<PFNGLPOPDEBUGGROUPPROC>(loader.Invoke("glPopDebugGroup"));
        _glObjectLabel = Marshal.GetDelegateForFunctionPointer<PFNGLOBJECTLABELPROC>(loader.Invoke("glObjectLabel"));
        _glGetObjectLabel = Marshal.GetDelegateForFunctionPointer<PFNGLGETOBJECTLABELPROC>(loader.Invoke("glGetObjectLabel"));
        _glObjectPtrLabel = Marshal.GetDelegateForFunctionPointer<PFNGLOBJECTPTRLABELPROC>(loader.Invoke("glObjectPtrLabel"));
        _glGetObjectPtrLabel = Marshal.GetDelegateForFunctionPointer<PFNGLGETOBJECTPTRLABELPROC>(loader.Invoke("glGetObjectPtrLabel"));
#endif
#if OGL_V_4_4 || OGL_V_4_5 || OGL_V_4_6
        _glBufferStorage = Marshal.GetDelegateForFunctionPointer<PFNGLBUFFERSTORAGEPROC>(loader.Invoke("glBufferStorage"));
        _glClearTexImage = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARTEXIMAGEPROC>(loader.Invoke("glClearTexImage"));
        _glClearTexSubImage = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARTEXSUBIMAGEPROC>(loader.Invoke("glClearTexSubImage"));
        _glBindBuffersBase = Marshal.GetDelegateForFunctionPointer<PFNGLBINDBUFFERSBASEPROC>(loader.Invoke("glBindBuffersBase"));
        _glBindBuffersRange = Marshal.GetDelegateForFunctionPointer<PFNGLBINDBUFFERSRANGEPROC>(loader.Invoke("glBindBuffersRange"));
        _glBindTextures = Marshal.GetDelegateForFunctionPointer<PFNGLBINDTEXTURESPROC>(loader.Invoke("glBindTextures"));
        _glBindSamplers = Marshal.GetDelegateForFunctionPointer<PFNGLBINDSAMPLERSPROC>(loader.Invoke("glBindSamplers"));
        _glBindImageTextures = Marshal.GetDelegateForFunctionPointer<PFNGLBINDIMAGETEXTURESPROC>(loader.Invoke("glBindImageTextures"));
        _glBindVertexBuffers = Marshal.GetDelegateForFunctionPointer<PFNGLBINDVERTEXBUFFERSPROC>(loader.Invoke("glBindVertexBuffers"));
#endif
#if OGL_V_4_5 || OGL_V_4_6
        _glClipControl = Marshal.GetDelegateForFunctionPointer<PFNGLCLIPCONTROLPROC>(loader.Invoke("glClipControl"));
        _glCreateTransformFeedbacks = Marshal.GetDelegateForFunctionPointer<PFNGLCREATETRANSFORMFEEDBACKSPROC>(loader.Invoke("glCreateTransformFeedbacks"));
        _glTransformFeedbackBufferBase =
 Marshal.GetDelegateForFunctionPointer<PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC>(loader.Invoke("glTransformFeedbackBufferBase"));
        _glTransformFeedbackBufferRange =
 Marshal.GetDelegateForFunctionPointer<PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC>(loader.Invoke("glTransformFeedbackBufferRange"));
        _glGetTransformFeedbackiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETTRANSFORMFEEDBACKIVPROC>(loader.Invoke("glGetTransformFeedbackiv"));
        _glGetTransformFeedbacki_v = Marshal.GetDelegateForFunctionPointer<PFNGLGETTRANSFORMFEEDBACKI_VPROC>(loader.Invoke("glGetTransformFeedbacki_v"));
        _glGetTransformFeedbacki64_v = Marshal.GetDelegateForFunctionPointer<PFNGLGETTRANSFORMFEEDBACKI64_VPROC>(loader.Invoke("glGetTransformFeedbacki64_v"));
        _glCreateBuffers = Marshal.GetDelegateForFunctionPointer<PFNGLCREATEBUFFERSPROC>(loader.Invoke("glCreateBuffers"));
        _glNamedBufferStorage = Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDBUFFERSTORAGEPROC>(loader.Invoke("glNamedBufferStorage"));
        _glNamedBufferData = Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDBUFFERDATAPROC>(loader.Invoke("glNamedBufferData"));
        _glNamedBufferSubData = Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDBUFFERSUBDATAPROC>(loader.Invoke("glNamedBufferSubData"));
        _glCopyNamedBufferSubData = Marshal.GetDelegateForFunctionPointer<PFNGLCOPYNAMEDBUFFERSUBDATAPROC>(loader.Invoke("glCopyNamedBufferSubData"));
        _glClearNamedBufferData = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARNAMEDBUFFERDATAPROC>(loader.Invoke("glClearNamedBufferData"));
        _glClearNamedBufferSubData = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARNAMEDBUFFERSUBDATAPROC>(loader.Invoke("glClearNamedBufferSubData"));
        _glMapNamedBuffer = Marshal.GetDelegateForFunctionPointer<PFNGLMAPNAMEDBUFFERPROC>(loader.Invoke("glMapNamedBuffer"));
        _glMapNamedBufferRange = Marshal.GetDelegateForFunctionPointer<PFNGLMAPNAMEDBUFFERRANGEPROC>(loader.Invoke("glMapNamedBufferRange"));
        _glUnmapNamedBuffer = Marshal.GetDelegateForFunctionPointer<PFNGLUNMAPNAMEDBUFFERPROC>(loader.Invoke("glUnmapNamedBuffer"));
        _glFlushMappedNamedBufferRange =
 Marshal.GetDelegateForFunctionPointer<PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC>(loader.Invoke("glFlushMappedNamedBufferRange"));
        _glGetNamedBufferParameteriv = Marshal.GetDelegateForFunctionPointer<PFNGLGETNAMEDBUFFERPARAMETERIVPROC>(loader.Invoke("glGetNamedBufferParameteriv"));
        _glGetNamedBufferParameteri64v =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETNAMEDBUFFERPARAMETERI64VPROC>(loader.Invoke("glGetNamedBufferParameteri64v"));
        _glGetNamedBufferPointerv = Marshal.GetDelegateForFunctionPointer<PFNGLGETNAMEDBUFFERPOINTERVPROC>(loader.Invoke("glGetNamedBufferPointerv"));
        _glGetNamedBufferSubData = Marshal.GetDelegateForFunctionPointer<PFNGLGETNAMEDBUFFERSUBDATAPROC>(loader.Invoke("glGetNamedBufferSubData"));
        _glCreateFramebuffers = Marshal.GetDelegateForFunctionPointer<PFNGLCREATEFRAMEBUFFERSPROC>(loader.Invoke("glCreateFramebuffers"));
        _glNamedFramebufferRenderbuffer =
 Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC>(loader.Invoke("glNamedFramebufferRenderbuffer"));
        _glNamedFramebufferParameteri =
 Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC>(loader.Invoke("glNamedFramebufferParameteri"));
        _glNamedFramebufferTexture = Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDFRAMEBUFFERTEXTUREPROC>(loader.Invoke("glNamedFramebufferTexture"));
        _glNamedFramebufferTextureLayer =
 Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC>(loader.Invoke("glNamedFramebufferTextureLayer"));
        _glNamedFramebufferDrawBuffer =
 Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC>(loader.Invoke("glNamedFramebufferDrawBuffer"));
        _glNamedFramebufferDrawBuffers =
 Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC>(loader.Invoke("glNamedFramebufferDrawBuffers"));
        _glNamedFramebufferReadBuffer =
 Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC>(loader.Invoke("glNamedFramebufferReadBuffer"));
        _glInvalidateNamedFramebufferData =
 Marshal.GetDelegateForFunctionPointer<PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC>(loader.Invoke("glInvalidateNamedFramebufferData"));
        _glInvalidateNamedFramebufferSubData =
 Marshal.GetDelegateForFunctionPointer<PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC>(loader.Invoke("glInvalidateNamedFramebufferSubData"));
        _glClearNamedFramebufferiv = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARNAMEDFRAMEBUFFERIVPROC>(loader.Invoke("glClearNamedFramebufferiv"));
        _glClearNamedFramebufferuiv = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC>(loader.Invoke("glClearNamedFramebufferuiv"));
        _glClearNamedFramebufferfv = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARNAMEDFRAMEBUFFERFVPROC>(loader.Invoke("glClearNamedFramebufferfv"));
        _glClearNamedFramebufferfi = Marshal.GetDelegateForFunctionPointer<PFNGLCLEARNAMEDFRAMEBUFFERFIPROC>(loader.Invoke("glClearNamedFramebufferfi"));
        _glBlitNamedFramebuffer = Marshal.GetDelegateForFunctionPointer<PFNGLBLITNAMEDFRAMEBUFFERPROC>(loader.Invoke("glBlitNamedFramebuffer"));
        _glCheckNamedFramebufferStatus =
 Marshal.GetDelegateForFunctionPointer<PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC>(loader.Invoke("glCheckNamedFramebufferStatus"));
        _glGetNamedFramebufferParameteriv =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC>(loader.Invoke("glGetNamedFramebufferParameteriv"));
        _glGetNamedFramebufferAttachmentParameteriv =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC>(loader.Invoke("glGetNamedFramebufferAttachmentParameteriv"));
        _glCreateRenderbuffers = Marshal.GetDelegateForFunctionPointer<PFNGLCREATERENDERBUFFERSPROC>(loader.Invoke("glCreateRenderbuffers"));
        _glNamedRenderbufferStorage = Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDRENDERBUFFERSTORAGEPROC>(loader.Invoke("glNamedRenderbufferStorage"));
        _glNamedRenderbufferStorageMultisample =
 Marshal.GetDelegateForFunctionPointer<PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC>(loader.Invoke("glNamedRenderbufferStorageMultisample"));
        _glGetNamedRenderbufferParameteriv =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC>(loader.Invoke("glGetNamedRenderbufferParameteriv"));
        _glCreateTextures = Marshal.GetDelegateForFunctionPointer<PFNGLCREATETEXTURESPROC>(loader.Invoke("glCreateTextures"));
        _glTextureBuffer = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTUREBUFFERPROC>(loader.Invoke("glTextureBuffer"));
        _glTextureBufferRange = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTUREBUFFERRANGEPROC>(loader.Invoke("glTextureBufferRange"));
        _glTextureStorage1D = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTURESTORAGE1DPROC>(loader.Invoke("glTextureStorage1D"));
        _glTextureStorage2D = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTURESTORAGE2DPROC>(loader.Invoke("glTextureStorage2D"));
        _glTextureStorage3D = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTURESTORAGE3DPROC>(loader.Invoke("glTextureStorage3D"));
        _glTextureStorage2DMultisample =
 Marshal.GetDelegateForFunctionPointer<PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC>(loader.Invoke("glTextureStorage2DMultisample"));
        _glTextureStorage3DMultisample =
 Marshal.GetDelegateForFunctionPointer<PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC>(loader.Invoke("glTextureStorage3DMultisample"));
        _glTextureSubImage1D = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTURESUBIMAGE1DPROC>(loader.Invoke("glTextureSubImage1D"));
        _glTextureSubImage2D = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTURESUBIMAGE2DPROC>(loader.Invoke("glTextureSubImage2D"));
        _glTextureSubImage3D = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTURESUBIMAGE3DPROC>(loader.Invoke("glTextureSubImage3D"));
        _glCompressedTextureSubImage1D =
 Marshal.GetDelegateForFunctionPointer<PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC>(loader.Invoke("glCompressedTextureSubImage1D"));
        _glCompressedTextureSubImage2D =
 Marshal.GetDelegateForFunctionPointer<PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC>(loader.Invoke("glCompressedTextureSubImage2D"));
        _glCompressedTextureSubImage3D =
 Marshal.GetDelegateForFunctionPointer<PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC>(loader.Invoke("glCompressedTextureSubImage3D"));
        _glCopyTextureSubImage1D = Marshal.GetDelegateForFunctionPointer<PFNGLCOPYTEXTURESUBIMAGE1DPROC>(loader.Invoke("glCopyTextureSubImage1D"));
        _glCopyTextureSubImage2D = Marshal.GetDelegateForFunctionPointer<PFNGLCOPYTEXTURESUBIMAGE2DPROC>(loader.Invoke("glCopyTextureSubImage2D"));
        _glCopyTextureSubImage3D = Marshal.GetDelegateForFunctionPointer<PFNGLCOPYTEXTURESUBIMAGE3DPROC>(loader.Invoke("glCopyTextureSubImage3D"));
        _glTextureParameterf = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTUREPARAMETERFPROC>(loader.Invoke("glTextureParameterf"));
        _glTextureParameterfv = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTUREPARAMETERFVPROC>(loader.Invoke("glTextureParameterfv"));
        _glTextureParameteri = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTUREPARAMETERIPROC>(loader.Invoke("glTextureParameteri"));
        _glTextureParameterIiv = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTUREPARAMETERIIVPROC>(loader.Invoke("glTextureParameterIiv"));
        _glTextureParameterIuiv = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTUREPARAMETERIUIVPROC>(loader.Invoke("glTextureParameterIuiv"));
        _glTextureParameteriv = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTUREPARAMETERIVPROC>(loader.Invoke("glTextureParameteriv"));
        _glGenerateTextureMipmap = Marshal.GetDelegateForFunctionPointer<PFNGLGENERATETEXTUREMIPMAPPROC>(loader.Invoke("glGenerateTextureMipmap"));
        _glBindTextureUnit = Marshal.GetDelegateForFunctionPointer<PFNGLBINDTEXTUREUNITPROC>(loader.Invoke("glBindTextureUnit"));
        _glGetTextureImage = Marshal.GetDelegateForFunctionPointer<PFNGLGETTEXTUREIMAGEPROC>(loader.Invoke("glGetTextureImage"));
        _glGetCompressedTextureImage = Marshal.GetDelegateForFunctionPointer<PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC>(loader.Invoke("glGetCompressedTextureImage"));
        _glGetTextureLevelParameterfv =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETTEXTURELEVELPARAMETERFVPROC>(loader.Invoke("glGetTextureLevelParameterfv"));
        _glGetTextureLevelParameteriv =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETTEXTURELEVELPARAMETERIVPROC>(loader.Invoke("glGetTextureLevelParameteriv"));
        _glGetTextureParameterfv = Marshal.GetDelegateForFunctionPointer<PFNGLGETTEXTUREPARAMETERFVPROC>(loader.Invoke("glGetTextureParameterfv"));
        _glGetTextureParameterIiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETTEXTUREPARAMETERIIVPROC>(loader.Invoke("glGetTextureParameterIiv"));
        _glGetTextureParameterIuiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETTEXTUREPARAMETERIUIVPROC>(loader.Invoke("glGetTextureParameterIuiv"));
        _glGetTextureParameteriv = Marshal.GetDelegateForFunctionPointer<PFNGLGETTEXTUREPARAMETERIVPROC>(loader.Invoke("glGetTextureParameteriv"));
        _glCreateVertexArrays = Marshal.GetDelegateForFunctionPointer<PFNGLCREATEVERTEXARRAYSPROC>(loader.Invoke("glCreateVertexArrays"));
        _glDisableVertexArrayAttrib = Marshal.GetDelegateForFunctionPointer<PFNGLDISABLEVERTEXARRAYATTRIBPROC>(loader.Invoke("glDisableVertexArrayAttrib"));
        _glEnableVertexArrayAttrib = Marshal.GetDelegateForFunctionPointer<PFNGLENABLEVERTEXARRAYATTRIBPROC>(loader.Invoke("glEnableVertexArrayAttrib"));
        _glVertexArrayElementBuffer = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXARRAYELEMENTBUFFERPROC>(loader.Invoke("glVertexArrayElementBuffer"));
        _glVertexArrayVertexBuffer = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXARRAYVERTEXBUFFERPROC>(loader.Invoke("glVertexArrayVertexBuffer"));
        _glVertexArrayVertexBuffers = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXARRAYVERTEXBUFFERSPROC>(loader.Invoke("glVertexArrayVertexBuffers"));
        _glVertexArrayAttribBinding = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXARRAYATTRIBBINDINGPROC>(loader.Invoke("glVertexArrayAttribBinding"));
        _glVertexArrayAttribFormat = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXARRAYATTRIBFORMATPROC>(loader.Invoke("glVertexArrayAttribFormat"));
        _glVertexArrayAttribIFormat = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXARRAYATTRIBIFORMATPROC>(loader.Invoke("glVertexArrayAttribIFormat"));
        _glVertexArrayAttribLFormat = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXARRAYATTRIBLFORMATPROC>(loader.Invoke("glVertexArrayAttribLFormat"));
        _glVertexArrayBindingDivisor = Marshal.GetDelegateForFunctionPointer<PFNGLVERTEXARRAYBINDINGDIVISORPROC>(loader.Invoke("glVertexArrayBindingDivisor"));
        _glGetVertexArrayiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETVERTEXARRAYIVPROC>(loader.Invoke("glGetVertexArrayiv"));
        _glGetVertexArrayIndexediv = Marshal.GetDelegateForFunctionPointer<PFNGLGETVERTEXARRAYINDEXEDIVPROC>(loader.Invoke("glGetVertexArrayIndexediv"));
        _glGetVertexArrayIndexed64iv = Marshal.GetDelegateForFunctionPointer<PFNGLGETVERTEXARRAYINDEXED64IVPROC>(loader.Invoke("glGetVertexArrayIndexed64iv"));
        _glCreateSamplers = Marshal.GetDelegateForFunctionPointer<PFNGLCREATESAMPLERSPROC>(loader.Invoke("glCreateSamplers"));
        _glCreateProgramPipelines = Marshal.GetDelegateForFunctionPointer<PFNGLCREATEPROGRAMPIPELINESPROC>(loader.Invoke("glCreateProgramPipelines"));
        _glCreateQueries = Marshal.GetDelegateForFunctionPointer<PFNGLCREATEQUERIESPROC>(loader.Invoke("glCreateQueries"));
        _glGetQueryBufferObjecti64v = Marshal.GetDelegateForFunctionPointer<PFNGLGETQUERYBUFFEROBJECTI64VPROC>(loader.Invoke("glGetQueryBufferObjecti64v"));
        _glGetQueryBufferObjectiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETQUERYBUFFEROBJECTIVPROC>(loader.Invoke("glGetQueryBufferObjectiv"));
        _glGetQueryBufferObjectui64v = Marshal.GetDelegateForFunctionPointer<PFNGLGETQUERYBUFFEROBJECTUI64VPROC>(loader.Invoke("glGetQueryBufferObjectui64v"));
        _glGetQueryBufferObjectuiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETQUERYBUFFEROBJECTUIVPROC>(loader.Invoke("glGetQueryBufferObjectuiv"));
        _glMemoryBarrierByRegion = Marshal.GetDelegateForFunctionPointer<PFNGLMEMORYBARRIERBYREGIONPROC>(loader.Invoke("glMemoryBarrierByRegion"));
        _glGetTextureSubImage = Marshal.GetDelegateForFunctionPointer<PFNGLGETTEXTURESUBIMAGEPROC>(loader.Invoke("glGetTextureSubImage"));
        _glGetCompressedTextureSubImage =
 Marshal.GetDelegateForFunctionPointer<PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC>(loader.Invoke("glGetCompressedTextureSubImage"));
        _glGetGraphicsResetStatus = Marshal.GetDelegateForFunctionPointer<PFNGLGETGRAPHICSRESETSTATUSPROC>(loader.Invoke("glGetGraphicsResetStatus"));
        _glGetnCompressedTexImage = Marshal.GetDelegateForFunctionPointer<PFNGLGETNCOMPRESSEDTEXIMAGEPROC>(loader.Invoke("glGetnCompressedTexImage"));
        _glGetnTexImage = Marshal.GetDelegateForFunctionPointer<PFNGLGETNTEXIMAGEPROC>(loader.Invoke("glGetnTexImage"));
        _glGetnUniformdv = Marshal.GetDelegateForFunctionPointer<PFNGLGETNUNIFORMDVPROC>(loader.Invoke("glGetnUniformdv"));
        _glGetnUniformfv = Marshal.GetDelegateForFunctionPointer<PFNGLGETNUNIFORMFVPROC>(loader.Invoke("glGetnUniformfv"));
        _glGetnUniformiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETNUNIFORMIVPROC>(loader.Invoke("glGetnUniformiv"));
        _glGetnUniformuiv = Marshal.GetDelegateForFunctionPointer<PFNGLGETNUNIFORMUIVPROC>(loader.Invoke("glGetnUniformuiv"));
        _glReadnPixels = Marshal.GetDelegateForFunctionPointer<PFNGLREADNPIXELSPROC>(loader.Invoke("glReadnPixels"));
        _glTextureBarrier = Marshal.GetDelegateForFunctionPointer<PFNGLTEXTUREBARRIERPROC>(loader.Invoke("glTextureBarrier"));
#endif
#if OGL_V_4_6
        _glSpecializeShader = Marshal.GetDelegateForFunctionPointer<PFNGLSPECIALIZESHADERPROC>(loader.Invoke("glSpecializeShader"));
        _glMultiDrawArraysIndirectCount =
 Marshal.GetDelegateForFunctionPointer<PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC>(loader.Invoke("glMultiDrawArraysIndirectCount"));
        _glMultiDrawElementsIndirectCount =
 Marshal.GetDelegateForFunctionPointer<PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC>(loader.Invoke("glMultiDrawElementsIndirectCount"));
        _glPolygonOffsetClamp = Marshal.GetDelegateForFunctionPointer<PFNGLPOLYGONOFFSETCLAMPPROC>(loader.Invoke("glPolygonOffsetClamp"));
#endif
    }
#endif
}

#pragma warning restore IDE0079 // Remove unnecessary suppression
#pragma warning restore CS8618  // Non-nullable field is uninitialized. Consider declaring as nullable.
#pragma warning restore CS8603  // Possible null reference return.
#pragma warning restore IDE0060 // Remove unused parameter.
#pragma warning restore IDE1006 // Naming Styles.
#pragma warning restore IDE0090 // Use 'new(...)'.
#pragma warning restore CS8500  // This takes the address of, gets the size of, or declares a pointer to a managed type